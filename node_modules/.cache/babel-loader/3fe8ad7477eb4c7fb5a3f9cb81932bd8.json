{"ast":null,"code":"var registerShader = require('../core/shader').registerShader;\n/**\n * Multi-channel signed distance field.\n * Used by text component.\n */\n\n\nmodule.exports.Shader = registerShader('msdf', {\n  schema: {\n    alphaTest: {\n      type: 'number',\n      is: 'uniform',\n      default: 0.5\n    },\n    color: {\n      type: 'color',\n      is: 'uniform',\n      default: 'white'\n    },\n    map: {\n      type: 'map',\n      is: 'uniform'\n    },\n    negate: {\n      type: 'boolean',\n      is: 'uniform',\n      default: true\n    },\n    opacity: {\n      type: 'number',\n      is: 'uniform',\n      default: 1.0\n    }\n  },\n  raw: true,\n  vertexShader: ['attribute vec2 uv;', 'attribute vec3 position;', 'uniform mat4 projectionMatrix;', 'uniform mat4 modelViewMatrix;', 'varying vec2 vUV;', 'void main(void) {', '  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);', '  vUV = uv;', '}'].join('\\n'),\n  fragmentShader: ['#ifdef GL_OES_standard_derivatives', '#extension GL_OES_standard_derivatives: enable', '#endif', 'precision highp float;', 'uniform bool negate;', 'uniform float alphaTest;', 'uniform float opacity;', 'uniform sampler2D map;', 'uniform vec3 color;', 'varying vec2 vUV;', 'float median(float r, float g, float b) {', '  return max(min(r, g), min(max(r, g), b));', '}', // FIXME: Experimentally determined constants.\n  '#define BIG_ENOUGH 0.001', '#define MODIFIED_ALPHATEST (0.02 * isBigEnough / BIG_ENOUGH)', 'void main() {', '  vec3 sample = texture2D(map, vUV).rgb;', '  if (negate) { sample = 1.0 - sample; }', '  float sigDist = median(sample.r, sample.g, sample.b) - 0.5;', '  float alpha = clamp(sigDist / fwidth(sigDist) + 0.5, 0.0, 1.0);', '  float dscale = 0.353505;', '  vec2 duv = dscale * (dFdx(vUV) + dFdy(vUV));', '  float isBigEnough = max(abs(duv.x), abs(duv.y));', // When texel is too small, blend raw alpha value rather than supersampling.\n  // FIXME: Experimentally determined constant.\n  '  // Do modified alpha test.', '  if (isBigEnough > BIG_ENOUGH) {', '    float ratio = BIG_ENOUGH / isBigEnough;', '    alpha = ratio * alpha + (1.0 - ratio) * (sigDist + 0.5);', '  }', '  // Do modified alpha test.', '  if (alpha < alphaTest * MODIFIED_ALPHATEST) { discard; return; }', '  gl_FragColor = vec4(color.xyz, alpha * opacity);', '}'].join('\\n')\n});","map":{"version":3,"sources":["C:/Users/Hannuri/Desktop/RoyalCyber/my-first-app/node_modules/aframe/src/shaders/msdf.js"],"names":["registerShader","require","module","exports","Shader","schema","alphaTest","type","is","default","color","map","negate","opacity","raw","vertexShader","join","fragmentShader"],"mappings":"AAAA,IAAIA,cAAc,GAAGC,OAAO,CAAC,gBAAD,CAAP,CAA0BD,cAA/C;AAEA;;;;;;AAIAE,MAAM,CAACC,OAAP,CAAeC,MAAf,GAAwBJ,cAAc,CAAC,MAAD,EAAS;AAC7CK,EAAAA,MAAM,EAAE;AACNC,IAAAA,SAAS,EAAE;AAACC,MAAAA,IAAI,EAAE,QAAP;AAAiBC,MAAAA,EAAE,EAAE,SAArB;AAAgCC,MAAAA,OAAO,EAAE;AAAzC,KADL;AAENC,IAAAA,KAAK,EAAE;AAACH,MAAAA,IAAI,EAAE,OAAP;AAAgBC,MAAAA,EAAE,EAAE,SAApB;AAA+BC,MAAAA,OAAO,EAAE;AAAxC,KAFD;AAGNE,IAAAA,GAAG,EAAE;AAACJ,MAAAA,IAAI,EAAE,KAAP;AAAcC,MAAAA,EAAE,EAAE;AAAlB,KAHC;AAINI,IAAAA,MAAM,EAAE;AAACL,MAAAA,IAAI,EAAE,SAAP;AAAkBC,MAAAA,EAAE,EAAE,SAAtB;AAAiCC,MAAAA,OAAO,EAAE;AAA1C,KAJF;AAKNI,IAAAA,OAAO,EAAE;AAACN,MAAAA,IAAI,EAAE,QAAP;AAAiBC,MAAAA,EAAE,EAAE,SAArB;AAAgCC,MAAAA,OAAO,EAAE;AAAzC;AALH,GADqC;AAS7CK,EAAAA,GAAG,EAAE,IATwC;AAW7CC,EAAAA,YAAY,EAAE,CACZ,oBADY,EAEZ,0BAFY,EAGZ,gCAHY,EAIZ,+BAJY,EAKZ,mBALY,EAMZ,mBANY,EAOZ,2EAPY,EAQZ,aARY,EASZ,GATY,EAUZC,IAVY,CAUP,IAVO,CAX+B;AAuB7CC,EAAAA,cAAc,EAAE,CACd,oCADc,EAEd,gDAFc,EAGd,QAHc,EAKd,wBALc,EAMd,sBANc,EAOd,0BAPc,EAQd,wBARc,EASd,wBATc,EAUd,qBAVc,EAWd,mBAXc,EAad,2CAbc,EAcd,6CAdc,EAed,GAfc,EAiBd;AACA,4BAlBc,EAmBd,8DAnBc,EAqBd,eArBc,EAsBd,0CAtBc,EAuBd,0CAvBc,EAyBd,+DAzBc,EA0Bd,mEA1Bc,EA2Bd,4BA3Bc,EA4Bd,gDA5Bc,EA6Bd,oDA7Bc,EA+Bd;AACA;AACA,gCAjCc,EAkCd,mCAlCc,EAmCd,6CAnCc,EAoCd,8DApCc,EAqCd,KArCc,EAuCd,8BAvCc,EAwCd,oEAxCc,EAyCd,oDAzCc,EA0Cd,GA1Cc,EA2CdD,IA3Cc,CA2CT,IA3CS;AAvB6B,CAAT,CAAtC","sourcesContent":["var registerShader = require('../core/shader').registerShader;\n\n/**\n * Multi-channel signed distance field.\n * Used by text component.\n */\nmodule.exports.Shader = registerShader('msdf', {\n  schema: {\n    alphaTest: {type: 'number', is: 'uniform', default: 0.5},\n    color: {type: 'color', is: 'uniform', default: 'white'},\n    map: {type: 'map', is: 'uniform'},\n    negate: {type: 'boolean', is: 'uniform', default: true},\n    opacity: {type: 'number', is: 'uniform', default: 1.0}\n  },\n\n  raw: true,\n\n  vertexShader: [\n    'attribute vec2 uv;',\n    'attribute vec3 position;',\n    'uniform mat4 projectionMatrix;',\n    'uniform mat4 modelViewMatrix;',\n    'varying vec2 vUV;',\n    'void main(void) {',\n    '  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',\n    '  vUV = uv;',\n    '}'\n  ].join('\\n'),\n\n  fragmentShader: [\n    '#ifdef GL_OES_standard_derivatives',\n    '#extension GL_OES_standard_derivatives: enable',\n    '#endif',\n\n    'precision highp float;',\n    'uniform bool negate;',\n    'uniform float alphaTest;',\n    'uniform float opacity;',\n    'uniform sampler2D map;',\n    'uniform vec3 color;',\n    'varying vec2 vUV;',\n\n    'float median(float r, float g, float b) {',\n    '  return max(min(r, g), min(max(r, g), b));',\n    '}',\n\n    // FIXME: Experimentally determined constants.\n    '#define BIG_ENOUGH 0.001',\n    '#define MODIFIED_ALPHATEST (0.02 * isBigEnough / BIG_ENOUGH)',\n\n    'void main() {',\n    '  vec3 sample = texture2D(map, vUV).rgb;',\n    '  if (negate) { sample = 1.0 - sample; }',\n\n    '  float sigDist = median(sample.r, sample.g, sample.b) - 0.5;',\n    '  float alpha = clamp(sigDist / fwidth(sigDist) + 0.5, 0.0, 1.0);',\n    '  float dscale = 0.353505;',\n    '  vec2 duv = dscale * (dFdx(vUV) + dFdy(vUV));',\n    '  float isBigEnough = max(abs(duv.x), abs(duv.y));',\n\n    // When texel is too small, blend raw alpha value rather than supersampling.\n    // FIXME: Experimentally determined constant.\n    '  // Do modified alpha test.',\n    '  if (isBigEnough > BIG_ENOUGH) {',\n    '    float ratio = BIG_ENOUGH / isBigEnough;',\n    '    alpha = ratio * alpha + (1.0 - ratio) * (sigDist + 0.5);',\n    '  }',\n\n    '  // Do modified alpha test.',\n    '  if (alpha < alphaTest * MODIFIED_ALPHATEST) { discard; return; }',\n    '  gl_FragColor = vec4(color.xyz, alpha * opacity);',\n    '}'\n  ].join('\\n')\n});\n"]},"metadata":{},"sourceType":"script"}