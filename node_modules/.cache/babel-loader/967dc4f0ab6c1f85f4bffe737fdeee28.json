{"ast":null,"code":"var components = require('./component');\n\nvar schema = require('./schema');\n\nvar utils = require('../utils/');\n\nvar parseProperties = schema.parseProperties;\nvar parseProperty = schema.parseProperty;\nvar processSchema = schema.process;\nvar isSingleProp = schema.isSingleProperty;\nvar styleParser = utils.styleParser;\nvar systems = module.exports.systems = {}; // Keep track of registered systems.\n\n/**\n * System class definition.\n *\n * Systems provide global scope and services to a group of instantiated components of the\n * same class. They can also help abstract logic away from components such that components\n * only have to worry about data.\n *\n * For example, a physics component that creates a physics world that oversees\n * all entities with a physics or rigid body component.\n *\n * TODO: Have the System prototype reuse the Component prototype. Most code is copied\n * and some pieces are missing from the Component facilities (e.g., attribute caching,\n * setAttribute behavior).\n *\n * @member {string} name - Name that system is registered under.\n * @member {Element} sceneEl - Handle to the scene element where system applies to.\n */\n\nvar System = module.exports.System = function (sceneEl) {\n  var component = components && components.components[this.name]; // Set reference to scene.\n\n  this.el = sceneEl;\n  this.sceneEl = sceneEl; // Set reference to matching component (if exists).\n\n  if (component) {\n    component.Component.prototype.system = this;\n  } // Process system configuration.\n\n\n  this.buildData();\n  this.init();\n  this.update({});\n};\n\nSystem.prototype = {\n  /**\n   * Schema to configure system.\n   */\n  schema: {},\n\n  /**\n   * Init handler. Called during scene initialization and is only run once.\n   * Systems can use this to set initial state.\n   */\n  init: function () {\n    /* no-op */\n  },\n\n  /**\n   * Update handler. Called during scene attribute updates.\n   * Systems can use this to dynamically update their state.\n   */\n  update: function (oldData) {\n    /* no-op */\n  },\n\n  /**\n   * Build data and call update handler.\n   *\n   * @private\n   */\n  updateProperties: function (rawData) {\n    var oldData = this.data;\n\n    if (!Object.keys(schema).length) {\n      return;\n    }\n\n    this.buildData(rawData);\n    this.update(oldData);\n  },\n\n  /**\n   * Parse data.\n   */\n  buildData: function (rawData) {\n    var schema = this.schema;\n\n    if (!Object.keys(schema).length) {\n      return;\n    }\n\n    rawData = rawData || window.HTMLElement.prototype.getAttribute.call(this.sceneEl, this.name);\n\n    if (isSingleProp(schema)) {\n      this.data = parseProperty(rawData, schema);\n    } else {\n      this.data = parseProperties(styleParser.parse(rawData) || {}, schema);\n    }\n  },\n\n  /**\n   * Tick handler.\n   * Called on each tick of the scene render loop.\n   * Affected by play and pause.\n   *\n   * @param {number} time - Scene tick time.\n   * @param {number} timeDelta - Difference in current render time and previous render time.\n   */\n  tick: undefined,\n\n  /**\n   * Tock handler.\n   * Called on each tock of the scene render loop.\n   * Affected by play and pause.\n   *\n   * @param {number} time - Scene tick time.\n   * @param {number} timeDelta - Difference in current render time and previous render time.\n   */\n  tock: undefined,\n\n  /**\n   * Called to start any dynamic behavior (e.g., animation, AI, events, physics).\n   */\n  play: function () {\n    /* no-op */\n  },\n\n  /**\n   * Called to stop any dynamic behavior (e.g., animation, AI, events, physics).\n   */\n  pause: function () {\n    /* no-op */\n  }\n};\n/**\n * Registers a system to A-Frame.\n *\n * @param {string} name - Component name.\n * @param {object} definition - Component property and methods.\n * @returns {object} Component.\n */\n\nmodule.exports.registerSystem = function (name, definition) {\n  var i;\n  var NewSystem;\n  var proto = {};\n  var scenes = utils.findAllScenes(document); // Format definition object to prototype object.\n\n  Object.keys(definition).forEach(function (key) {\n    proto[key] = {\n      value: definition[key],\n      writable: true\n    };\n  });\n\n  if (systems[name]) {\n    throw new Error('The system `' + name + '` has been already registered. ' + 'Check that you are not loading two versions of the same system ' + 'or two different systems of the same name.');\n  }\n\n  NewSystem = function (sceneEl) {\n    System.call(this, sceneEl);\n  };\n\n  NewSystem.prototype = Object.create(System.prototype, proto);\n  NewSystem.prototype.name = name;\n  NewSystem.prototype.constructor = NewSystem;\n  NewSystem.prototype.schema = utils.extend(processSchema(NewSystem.prototype.schema));\n  systems[name] = NewSystem; // Initialize systems for existing scenes\n\n  for (i = 0; i < scenes.length; i++) {\n    scenes[i].initSystem(name);\n  }\n};","map":{"version":3,"sources":["C:/Users/Hannuri/Desktop/RoyalCyber/my-first-app/node_modules/aframe/src/core/system.js"],"names":["components","require","schema","utils","parseProperties","parseProperty","processSchema","process","isSingleProp","isSingleProperty","styleParser","systems","module","exports","System","sceneEl","component","name","el","Component","prototype","system","buildData","init","update","oldData","updateProperties","rawData","data","Object","keys","length","window","HTMLElement","getAttribute","call","parse","tick","undefined","tock","play","pause","registerSystem","definition","i","NewSystem","proto","scenes","findAllScenes","document","forEach","key","value","writable","Error","create","constructor","extend","initSystem"],"mappings":"AAAA,IAAIA,UAAU,GAAGC,OAAO,CAAC,aAAD,CAAxB;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,UAAD,CAApB;;AACA,IAAIE,KAAK,GAAGF,OAAO,CAAC,WAAD,CAAnB;;AAEA,IAAIG,eAAe,GAAGF,MAAM,CAACE,eAA7B;AACA,IAAIC,aAAa,GAAGH,MAAM,CAACG,aAA3B;AACA,IAAIC,aAAa,GAAGJ,MAAM,CAACK,OAA3B;AACA,IAAIC,YAAY,GAAGN,MAAM,CAACO,gBAA1B;AACA,IAAIC,WAAW,GAAGP,KAAK,CAACO,WAAxB;AAEA,IAAIC,OAAO,GAAGC,MAAM,CAACC,OAAP,CAAeF,OAAf,GAAyB,EAAvC,C,CAA4C;;AAE5C;;;;;;;;;;;;;;;;;;AAiBA,IAAIG,MAAM,GAAGF,MAAM,CAACC,OAAP,CAAeC,MAAf,GAAwB,UAAUC,OAAV,EAAmB;AACtD,MAAIC,SAAS,GAAGhB,UAAU,IAAIA,UAAU,CAACA,UAAX,CAAsB,KAAKiB,IAA3B,CAA9B,CADsD,CAGtD;;AACA,OAAKC,EAAL,GAAUH,OAAV;AACA,OAAKA,OAAL,GAAeA,OAAf,CALsD,CAOtD;;AACA,MAAIC,SAAJ,EAAe;AAAEA,IAAAA,SAAS,CAACG,SAAV,CAAoBC,SAApB,CAA8BC,MAA9B,GAAuC,IAAvC;AAA8C,GART,CAUtD;;;AACA,OAAKC,SAAL;AACA,OAAKC,IAAL;AACA,OAAKC,MAAL,CAAY,EAAZ;AACD,CAdD;;AAgBAV,MAAM,CAACM,SAAP,GAAmB;AACjB;;;AAGAlB,EAAAA,MAAM,EAAE,EAJS;;AAMjB;;;;AAIAqB,EAAAA,IAAI,EAAE,YAAY;AAAE;AAAa,GAVhB;;AAYjB;;;;AAIAC,EAAAA,MAAM,EAAE,UAAUC,OAAV,EAAmB;AAAE;AAAa,GAhBzB;;AAkBjB;;;;;AAKAC,EAAAA,gBAAgB,EAAE,UAAUC,OAAV,EAAmB;AACnC,QAAIF,OAAO,GAAG,KAAKG,IAAnB;;AACA,QAAI,CAACC,MAAM,CAACC,IAAP,CAAY5B,MAAZ,EAAoB6B,MAAzB,EAAiC;AAAE;AAAS;;AAC5C,SAAKT,SAAL,CAAeK,OAAf;AACA,SAAKH,MAAL,CAAYC,OAAZ;AACD,GA5BgB;;AA8BjB;;;AAGAH,EAAAA,SAAS,EAAE,UAAUK,OAAV,EAAmB;AAC5B,QAAIzB,MAAM,GAAG,KAAKA,MAAlB;;AACA,QAAI,CAAC2B,MAAM,CAACC,IAAP,CAAY5B,MAAZ,EAAoB6B,MAAzB,EAAiC;AAAE;AAAS;;AAC5CJ,IAAAA,OAAO,GAAGA,OAAO,IAAIK,MAAM,CAACC,WAAP,CAAmBb,SAAnB,CAA6Bc,YAA7B,CAA0CC,IAA1C,CAA+C,KAAKpB,OAApD,EAA6D,KAAKE,IAAlE,CAArB;;AACA,QAAIT,YAAY,CAACN,MAAD,CAAhB,EAA0B;AACxB,WAAK0B,IAAL,GAAYvB,aAAa,CAACsB,OAAD,EAAUzB,MAAV,CAAzB;AACD,KAFD,MAEO;AACL,WAAK0B,IAAL,GAAYxB,eAAe,CAACM,WAAW,CAAC0B,KAAZ,CAAkBT,OAAlB,KAA8B,EAA/B,EAAmCzB,MAAnC,CAA3B;AACD;AACF,GA1CgB;;AA4CjB;;;;;;;;AAQAmC,EAAAA,IAAI,EAAEC,SApDW;;AAsDjB;;;;;;;;AAQAC,EAAAA,IAAI,EAAED,SA9DW;;AAgEjB;;;AAGAE,EAAAA,IAAI,EAAE,YAAY;AAAE;AAAa,GAnEhB;;AAqEjB;;;AAGAC,EAAAA,KAAK,EAAE,YAAY;AAAE;AAAa;AAxEjB,CAAnB;AA2EA;;;;;;;;AAOA7B,MAAM,CAACC,OAAP,CAAe6B,cAAf,GAAgC,UAAUzB,IAAV,EAAgB0B,UAAhB,EAA4B;AAC1D,MAAIC,CAAJ;AACA,MAAIC,SAAJ;AACA,MAAIC,KAAK,GAAG,EAAZ;AACA,MAAIC,MAAM,GAAG5C,KAAK,CAAC6C,aAAN,CAAoBC,QAApB,CAAb,CAJ0D,CAM1D;;AACApB,EAAAA,MAAM,CAACC,IAAP,CAAYa,UAAZ,EAAwBO,OAAxB,CAAgC,UAAUC,GAAV,EAAe;AAC7CL,IAAAA,KAAK,CAACK,GAAD,CAAL,GAAa;AACXC,MAAAA,KAAK,EAAET,UAAU,CAACQ,GAAD,CADN;AAEXE,MAAAA,QAAQ,EAAE;AAFC,KAAb;AAID,GALD;;AAOA,MAAI1C,OAAO,CAACM,IAAD,CAAX,EAAmB;AACjB,UAAM,IAAIqC,KAAJ,CAAU,iBAAiBrC,IAAjB,GAAwB,iCAAxB,GACA,iEADA,GAEA,4CAFV,CAAN;AAGD;;AACD4B,EAAAA,SAAS,GAAG,UAAU9B,OAAV,EAAmB;AAAED,IAAAA,MAAM,CAACqB,IAAP,CAAY,IAAZ,EAAkBpB,OAAlB;AAA6B,GAA9D;;AACA8B,EAAAA,SAAS,CAACzB,SAAV,GAAsBS,MAAM,CAAC0B,MAAP,CAAczC,MAAM,CAACM,SAArB,EAAgC0B,KAAhC,CAAtB;AACAD,EAAAA,SAAS,CAACzB,SAAV,CAAoBH,IAApB,GAA2BA,IAA3B;AACA4B,EAAAA,SAAS,CAACzB,SAAV,CAAoBoC,WAApB,GAAkCX,SAAlC;AACAA,EAAAA,SAAS,CAACzB,SAAV,CAAoBlB,MAApB,GAA6BC,KAAK,CAACsD,MAAN,CAAanD,aAAa,CAACuC,SAAS,CAACzB,SAAV,CAAoBlB,MAArB,CAA1B,CAA7B;AACAS,EAAAA,OAAO,CAACM,IAAD,CAAP,GAAgB4B,SAAhB,CAxB0D,CA0B1D;;AACA,OAAKD,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGG,MAAM,CAAChB,MAAvB,EAA+Ba,CAAC,EAAhC,EAAoC;AAAEG,IAAAA,MAAM,CAACH,CAAD,CAAN,CAAUc,UAAV,CAAqBzC,IAArB;AAA6B;AACpE,CA5BD","sourcesContent":["var components = require('./component');\nvar schema = require('./schema');\nvar utils = require('../utils/');\n\nvar parseProperties = schema.parseProperties;\nvar parseProperty = schema.parseProperty;\nvar processSchema = schema.process;\nvar isSingleProp = schema.isSingleProperty;\nvar styleParser = utils.styleParser;\n\nvar systems = module.exports.systems = {};  // Keep track of registered systems.\n\n/**\n * System class definition.\n *\n * Systems provide global scope and services to a group of instantiated components of the\n * same class. They can also help abstract logic away from components such that components\n * only have to worry about data.\n *\n * For example, a physics component that creates a physics world that oversees\n * all entities with a physics or rigid body component.\n *\n * TODO: Have the System prototype reuse the Component prototype. Most code is copied\n * and some pieces are missing from the Component facilities (e.g., attribute caching,\n * setAttribute behavior).\n *\n * @member {string} name - Name that system is registered under.\n * @member {Element} sceneEl - Handle to the scene element where system applies to.\n */\nvar System = module.exports.System = function (sceneEl) {\n  var component = components && components.components[this.name];\n\n  // Set reference to scene.\n  this.el = sceneEl;\n  this.sceneEl = sceneEl;\n\n  // Set reference to matching component (if exists).\n  if (component) { component.Component.prototype.system = this; }\n\n  // Process system configuration.\n  this.buildData();\n  this.init();\n  this.update({});\n};\n\nSystem.prototype = {\n  /**\n   * Schema to configure system.\n   */\n  schema: {},\n\n  /**\n   * Init handler. Called during scene initialization and is only run once.\n   * Systems can use this to set initial state.\n   */\n  init: function () { /* no-op */ },\n\n  /**\n   * Update handler. Called during scene attribute updates.\n   * Systems can use this to dynamically update their state.\n   */\n  update: function (oldData) { /* no-op */ },\n\n  /**\n   * Build data and call update handler.\n   *\n   * @private\n   */\n  updateProperties: function (rawData) {\n    var oldData = this.data;\n    if (!Object.keys(schema).length) { return; }\n    this.buildData(rawData);\n    this.update(oldData);\n  },\n\n  /**\n   * Parse data.\n   */\n  buildData: function (rawData) {\n    var schema = this.schema;\n    if (!Object.keys(schema).length) { return; }\n    rawData = rawData || window.HTMLElement.prototype.getAttribute.call(this.sceneEl, this.name);\n    if (isSingleProp(schema)) {\n      this.data = parseProperty(rawData, schema);\n    } else {\n      this.data = parseProperties(styleParser.parse(rawData) || {}, schema);\n    }\n  },\n\n  /**\n   * Tick handler.\n   * Called on each tick of the scene render loop.\n   * Affected by play and pause.\n   *\n   * @param {number} time - Scene tick time.\n   * @param {number} timeDelta - Difference in current render time and previous render time.\n   */\n  tick: undefined,\n\n  /**\n   * Tock handler.\n   * Called on each tock of the scene render loop.\n   * Affected by play and pause.\n   *\n   * @param {number} time - Scene tick time.\n   * @param {number} timeDelta - Difference in current render time and previous render time.\n   */\n  tock: undefined,\n\n  /**\n   * Called to start any dynamic behavior (e.g., animation, AI, events, physics).\n   */\n  play: function () { /* no-op */ },\n\n  /**\n   * Called to stop any dynamic behavior (e.g., animation, AI, events, physics).\n   */\n  pause: function () { /* no-op */ }\n};\n\n/**\n * Registers a system to A-Frame.\n *\n * @param {string} name - Component name.\n * @param {object} definition - Component property and methods.\n * @returns {object} Component.\n */\nmodule.exports.registerSystem = function (name, definition) {\n  var i;\n  var NewSystem;\n  var proto = {};\n  var scenes = utils.findAllScenes(document);\n\n  // Format definition object to prototype object.\n  Object.keys(definition).forEach(function (key) {\n    proto[key] = {\n      value: definition[key],\n      writable: true\n    };\n  });\n\n  if (systems[name]) {\n    throw new Error('The system `' + name + '` has been already registered. ' +\n                    'Check that you are not loading two versions of the same system ' +\n                    'or two different systems of the same name.');\n  }\n  NewSystem = function (sceneEl) { System.call(this, sceneEl); };\n  NewSystem.prototype = Object.create(System.prototype, proto);\n  NewSystem.prototype.name = name;\n  NewSystem.prototype.constructor = NewSystem;\n  NewSystem.prototype.schema = utils.extend(processSchema(NewSystem.prototype.schema));\n  systems[name] = NewSystem;\n\n  // Initialize systems for existing scenes\n  for (i = 0; i < scenes.length; i++) { scenes[i].initSystem(name); }\n};\n"]},"metadata":{},"sourceType":"script"}