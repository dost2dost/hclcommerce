{"ast":null,"code":"/**\n * @author Emmett Lalish / elalish\n *\n * This class generates custom mipmaps for a roughness map by encoding the lost variation in the\n * normal map mip levels as increased roughness in the corresponding roughness mip levels. This\n * helps with rendering accuracy for MeshStandardMaterial, and also helps with anti-aliasing when\n * using PMREM. If the normal map is larger than the roughness map, the roughness map will be\n * enlarged to match the dimensions of the normal map.\n */\nimport { LinearMipMapLinearFilter, MathUtils, Mesh, NoBlending, OrthographicCamera, PlaneBufferGeometry, RawShaderMaterial, Scene, Vector2, WebGLRenderTarget } from \"../../../build/three.module.js\";\n\nvar RoughnessMipmapper = function () {\n  var _mipmapMaterial = _getMipmapMaterial();\n\n  var _scene = new Scene();\n\n  _scene.add(new Mesh(new PlaneBufferGeometry(2, 2), _mipmapMaterial));\n\n  var _flatCamera = new OrthographicCamera(0, 1, 0, 1, 0, 1);\n\n  var _tempTarget = null;\n  var _renderer = null; // constructor\n\n  var RoughnessMipmapper = function (renderer) {\n    _renderer = renderer;\n\n    _renderer.compile(_scene, _flatCamera);\n  };\n\n  RoughnessMipmapper.prototype = {\n    constructor: RoughnessMipmapper,\n    generateMipmaps: function (material) {\n      var roughnessMap = material.roughnessMap,\n          normalMap = material.normalMap;\n      if (roughnessMap == null || normalMap == null || !roughnessMap.generateMipmaps || material.userData.roughnessUpdated) return;\n      material.userData.roughnessUpdated = true;\n      var width = Math.max(roughnessMap.image.width, normalMap.image.width);\n      var height = Math.max(roughnessMap.image.height, normalMap.image.height);\n      if (!MathUtils.isPowerOfTwo(width) || !MathUtils.isPowerOfTwo(height)) return;\n\n      var oldTarget = _renderer.getRenderTarget();\n\n      var autoClear = _renderer.autoClear;\n      _renderer.autoClear = false;\n\n      if (_tempTarget == null || _tempTarget.width !== width || _tempTarget.height !== height) {\n        if (_tempTarget != null) _tempTarget.dispose();\n        _tempTarget = new WebGLRenderTarget(width, height, {\n          depthBuffer: false,\n          stencilBuffer: false\n        });\n        _tempTarget.scissorTest = true;\n      }\n\n      if (width !== roughnessMap.image.width || height !== roughnessMap.image.height) {\n        var newRoughnessTarget = new WebGLRenderTarget(width, height, {\n          minFilter: LinearMipMapLinearFilter,\n          depthBuffer: false,\n          stencilBuffer: false\n        });\n        newRoughnessTarget.texture.generateMipmaps = true; // Setting the render target causes the memory to be allocated.\n\n        _renderer.setRenderTarget(newRoughnessTarget);\n\n        material.roughnessMap = newRoughnessTarget.texture;\n        if (material.metalnessMap == roughnessMap) material.metalnessMap = material.roughnessMap;\n        if (material.aoMap == roughnessMap) material.aoMap = material.roughnessMap;\n      }\n\n      _mipmapMaterial.uniforms.roughnessMap.value = roughnessMap;\n      _mipmapMaterial.uniforms.normalMap.value = normalMap;\n      var position = new Vector2(0, 0);\n      var texelSize = _mipmapMaterial.uniforms.texelSize.value;\n\n      for (var mip = 0; width >= 1 && height >= 1; ++mip, width /= 2, height /= 2) {\n        // Rendering to a mip level is not allowed in webGL1. Instead we must set\n        // up a secondary texture to write the result to, then copy it back to the\n        // proper mipmap level.\n        texelSize.set(1.0 / width, 1.0 / height);\n        if (mip == 0) texelSize.set(0.0, 0.0);\n\n        _tempTarget.viewport.set(position.x, position.y, width, height);\n\n        _tempTarget.scissor.set(position.x, position.y, width, height);\n\n        _renderer.setRenderTarget(_tempTarget);\n\n        _renderer.render(_scene, _flatCamera);\n\n        _renderer.copyFramebufferToTexture(position, material.roughnessMap, mip);\n\n        _mipmapMaterial.uniforms.roughnessMap.value = material.roughnessMap;\n      }\n\n      if (roughnessMap !== material.roughnessMap) roughnessMap.dispose();\n\n      _renderer.setRenderTarget(oldTarget);\n\n      _renderer.autoClear = autoClear;\n    },\n    dispose: function () {\n      _mipmapMaterial.dispose();\n\n      _scene.children[0].geometry.dispose();\n\n      if (_tempTarget != null) _tempTarget.dispose();\n    }\n  };\n\n  function _getMipmapMaterial() {\n    var shaderMaterial = new RawShaderMaterial({\n      uniforms: {\n        roughnessMap: {\n          value: null\n        },\n        normalMap: {\n          value: null\n        },\n        texelSize: {\n          value: new Vector2(1, 1)\n        }\n      },\n      vertexShader: `\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nvarying vec2 vUv;\nvoid main() {\n    vUv = uv;\n    gl_Position = vec4( position, 1.0 );\n}\n              `,\n      fragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec2 vUv;\nuniform sampler2D roughnessMap;\nuniform sampler2D normalMap;\nuniform vec2 texelSize;\n\n#define ENVMAP_TYPE_CUBE_UV\nvec4 envMapTexelToLinear(vec4 a){return a;}\n#include <cube_uv_reflection_fragment>\n\nfloat roughnessToVariance(float roughness) {\n  float variance = 0.0;\n  if (roughness >= r1) {\n    variance = (r0 - roughness) * (v1 - v0) / (r0 - r1) + v0;\n  } else if (roughness >= r4) {\n    variance = (r1 - roughness) * (v4 - v1) / (r1 - r4) + v1;\n  } else if (roughness >= r5) {\n    variance = (r4 - roughness) * (v5 - v4) / (r4 - r5) + v4;\n  } else {\n    float roughness2 = roughness * roughness;\n    variance = 1.79 * roughness2 * roughness2;\n  }\n  return variance;\n}\nfloat varianceToRoughness(float variance) {\n  float roughness = 0.0;\n  if (variance >= v1) {\n    roughness = (v0 - variance) * (r1 - r0) / (v0 - v1) + r0;\n  } else if (variance >= v4) {\n    roughness = (v1 - variance) * (r4 - r1) / (v1 - v4) + r1;\n  } else if (variance >= v5) {\n    roughness = (v4 - variance) * (r5 - r4) / (v4 - v5) + r4;\n  } else {\n    roughness = pow(0.559 * variance, 0.25);// 0.559 = 1.0 / 1.79\n  }\n  return roughness;\n}\n\nvoid main() {\n    gl_FragColor = texture2D(roughnessMap, vUv, -1.0);\n    if (texelSize.x == 0.0) return;\n    float roughness = gl_FragColor.g;\n    float variance = roughnessToVariance(roughness);\n    vec3 avgNormal;\n    for (float x = -1.0; x < 2.0; x += 2.0) {\n    for (float y = -1.0; y < 2.0; y += 2.0) {\n        vec2 uv = vUv + vec2(x, y) * 0.25 * texelSize;\n        avgNormal += normalize(texture2D(normalMap, uv, -1.0).xyz - 0.5);\n    }\n    }\n    variance += 1.0 - 0.25 * length(avgNormal);\n    gl_FragColor.g = varianceToRoughness(variance);\n}\n              `,\n      blending: NoBlending,\n      depthTest: false,\n      depthWrite: false\n    });\n    shaderMaterial.type = 'RoughnessMipmapper';\n    return shaderMaterial;\n  }\n\n  return RoughnessMipmapper;\n}();\n\nexport { RoughnessMipmapper };","map":{"version":3,"sources":["F:/_HCLCommece/node_modules/three/examples/jsm/utils/RoughnessMipmapper.js"],"names":["LinearMipMapLinearFilter","MathUtils","Mesh","NoBlending","OrthographicCamera","PlaneBufferGeometry","RawShaderMaterial","Scene","Vector2","WebGLRenderTarget","RoughnessMipmapper","_mipmapMaterial","_getMipmapMaterial","_scene","add","_flatCamera","_tempTarget","_renderer","renderer","compile","prototype","constructor","generateMipmaps","material","roughnessMap","normalMap","userData","roughnessUpdated","width","Math","max","image","height","isPowerOfTwo","oldTarget","getRenderTarget","autoClear","dispose","depthBuffer","stencilBuffer","scissorTest","newRoughnessTarget","minFilter","texture","setRenderTarget","metalnessMap","aoMap","uniforms","value","position","texelSize","mip","set","viewport","x","y","scissor","render","copyFramebufferToTexture","children","geometry","shaderMaterial","vertexShader","fragmentShader","blending","depthTest","depthWrite","type"],"mappings":"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","sourcesContent":["/**\n * @author Emmett Lalish / elalish\n *\n * This class generates custom mipmaps for a roughness map by encoding the lost variation in the\n * normal map mip levels as increased roughness in the corresponding roughness mip levels. This\n * helps with rendering accuracy for MeshStandardMaterial, and also helps with anti-aliasing when\n * using PMREM. If the normal map is larger than the roughness map, the roughness map will be\n * enlarged to match the dimensions of the normal map.\n */\n\nimport {\n\tLinearMipMapLinearFilter,\n\tMathUtils,\n\tMesh,\n\tNoBlending,\n\tOrthographicCamera,\n\tPlaneBufferGeometry,\n\tRawShaderMaterial,\n\tScene,\n\tVector2,\n\tWebGLRenderTarget\n} from \"../../../build/three.module.js\";\n\nvar RoughnessMipmapper = ( function () {\n\n\tvar _mipmapMaterial = _getMipmapMaterial();\n\tvar _scene = new Scene();\n\t_scene.add( new Mesh( new PlaneBufferGeometry( 2, 2 ), _mipmapMaterial ) );\n\n\tvar _flatCamera = new OrthographicCamera( 0, 1, 0, 1, 0, 1 );\n\tvar _tempTarget = null;\n\tvar _renderer = null;\n\n\t// constructor\n\tvar RoughnessMipmapper = function ( renderer ) {\n\n\t\t_renderer = renderer;\n\t\t_renderer.compile( _scene, _flatCamera );\n\n\t};\n\n\tRoughnessMipmapper.prototype = {\n\n\t\tconstructor: RoughnessMipmapper,\n\n\t\tgenerateMipmaps: function ( material ) {\n\n\t\t\tvar { roughnessMap, normalMap } = material;\n\t\t\tif ( roughnessMap == null || normalMap == null || ! roughnessMap.generateMipmaps ||\n                material.userData.roughnessUpdated ) return;\n\n\t\t\tmaterial.userData.roughnessUpdated = true;\n\n\t\t\tvar width = Math.max( roughnessMap.image.width, normalMap.image.width );\n\t\t\tvar height = Math.max( roughnessMap.image.height, normalMap.image.height );\n\t\t\tif ( ! MathUtils.isPowerOfTwo( width ) || ! MathUtils.isPowerOfTwo( height ) ) return;\n\n\t\t\tvar oldTarget = _renderer.getRenderTarget();\n\t\t\tvar autoClear = _renderer.autoClear;\n\t\t\t_renderer.autoClear = false;\n\n\t\t\tif ( _tempTarget == null || _tempTarget.width !== width || _tempTarget.height !== height ) {\n\n\t\t\t\tif ( _tempTarget != null ) _tempTarget.dispose();\n\n\t\t\t\t_tempTarget = new WebGLRenderTarget( width, height, { depthBuffer: false, stencilBuffer: false } );\n\t\t\t\t_tempTarget.scissorTest = true;\n\n\t\t\t}\n\n\t\t\tif ( width !== roughnessMap.image.width || height !== roughnessMap.image.height ) {\n\n\t\t\t\tvar newRoughnessTarget = new WebGLRenderTarget( width, height, {\n\t\t\t\t\tminFilter: LinearMipMapLinearFilter,\n\t\t\t\t\tdepthBuffer: false,\n\t\t\t\t\tstencilBuffer: false\n\t\t\t\t} );\n\t\t\t\tnewRoughnessTarget.texture.generateMipmaps = true;\n\t\t\t\t// Setting the render target causes the memory to be allocated.\n\t\t\t\t_renderer.setRenderTarget( newRoughnessTarget );\n\t\t\t\tmaterial.roughnessMap = newRoughnessTarget.texture;\n\t\t\t\tif ( material.metalnessMap == roughnessMap ) material.metalnessMap = material.roughnessMap;\n\t\t\t\tif ( material.aoMap == roughnessMap ) material.aoMap = material.roughnessMap;\n\n\t\t\t}\n\n\t\t\t_mipmapMaterial.uniforms.roughnessMap.value = roughnessMap;\n\t\t\t_mipmapMaterial.uniforms.normalMap.value = normalMap;\n\n\t\t\tvar position = new Vector2( 0, 0 );\n\t\t\tvar texelSize = _mipmapMaterial.uniforms.texelSize.value;\n\t\t\tfor ( var mip = 0; width >= 1 && height >= 1;\n\t\t\t\t++ mip, width /= 2, height /= 2 ) {\n\n\t\t\t\t// Rendering to a mip level is not allowed in webGL1. Instead we must set\n\t\t\t\t// up a secondary texture to write the result to, then copy it back to the\n\t\t\t\t// proper mipmap level.\n\t\t\t\ttexelSize.set( 1.0 / width, 1.0 / height );\n\t\t\t\tif ( mip == 0 ) texelSize.set( 0.0, 0.0 );\n\n\t\t\t\t_tempTarget.viewport.set( position.x, position.y, width, height );\n\t\t\t\t_tempTarget.scissor.set( position.x, position.y, width, height );\n\t\t\t\t_renderer.setRenderTarget( _tempTarget );\n\t\t\t\t_renderer.render( _scene, _flatCamera );\n\t\t\t\t_renderer.copyFramebufferToTexture( position, material.roughnessMap, mip );\n\t\t\t\t_mipmapMaterial.uniforms.roughnessMap.value = material.roughnessMap;\n\n\t\t\t}\n\n\t\t\tif ( roughnessMap !== material.roughnessMap ) roughnessMap.dispose();\n\n\t\t\t_renderer.setRenderTarget( oldTarget );\n\t\t\t_renderer.autoClear = autoClear;\n\n\t\t},\n\n\t\tdispose: function ( ) {\n\n\t\t\t_mipmapMaterial.dispose();\n\t\t\t_scene.children[ 0 ].geometry.dispose();\n\t\t\tif ( _tempTarget != null ) _tempTarget.dispose();\n\n\t\t}\n\n\t};\n\n\tfunction _getMipmapMaterial() {\n\n\t\tvar shaderMaterial = new RawShaderMaterial( {\n\n\t\t\tuniforms: {\n\t\t\t\troughnessMap: { value: null },\n\t\t\t\tnormalMap: { value: null },\n\t\t\t\ttexelSize: { value: new Vector2( 1, 1 ) }\n\t\t\t},\n\n\t\t\tvertexShader: `\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nvarying vec2 vUv;\nvoid main() {\n    vUv = uv;\n    gl_Position = vec4( position, 1.0 );\n}\n              `,\n\n\t\t\tfragmentShader: `\nprecision mediump float;\nprecision mediump int;\nvarying vec2 vUv;\nuniform sampler2D roughnessMap;\nuniform sampler2D normalMap;\nuniform vec2 texelSize;\n\n#define ENVMAP_TYPE_CUBE_UV\nvec4 envMapTexelToLinear(vec4 a){return a;}\n#include <cube_uv_reflection_fragment>\n\nfloat roughnessToVariance(float roughness) {\n  float variance = 0.0;\n  if (roughness >= r1) {\n    variance = (r0 - roughness) * (v1 - v0) / (r0 - r1) + v0;\n  } else if (roughness >= r4) {\n    variance = (r1 - roughness) * (v4 - v1) / (r1 - r4) + v1;\n  } else if (roughness >= r5) {\n    variance = (r4 - roughness) * (v5 - v4) / (r4 - r5) + v4;\n  } else {\n    float roughness2 = roughness * roughness;\n    variance = 1.79 * roughness2 * roughness2;\n  }\n  return variance;\n}\nfloat varianceToRoughness(float variance) {\n  float roughness = 0.0;\n  if (variance >= v1) {\n    roughness = (v0 - variance) * (r1 - r0) / (v0 - v1) + r0;\n  } else if (variance >= v4) {\n    roughness = (v1 - variance) * (r4 - r1) / (v1 - v4) + r1;\n  } else if (variance >= v5) {\n    roughness = (v4 - variance) * (r5 - r4) / (v4 - v5) + r4;\n  } else {\n    roughness = pow(0.559 * variance, 0.25);// 0.559 = 1.0 / 1.79\n  }\n  return roughness;\n}\n\nvoid main() {\n    gl_FragColor = texture2D(roughnessMap, vUv, -1.0);\n    if (texelSize.x == 0.0) return;\n    float roughness = gl_FragColor.g;\n    float variance = roughnessToVariance(roughness);\n    vec3 avgNormal;\n    for (float x = -1.0; x < 2.0; x += 2.0) {\n    for (float y = -1.0; y < 2.0; y += 2.0) {\n        vec2 uv = vUv + vec2(x, y) * 0.25 * texelSize;\n        avgNormal += normalize(texture2D(normalMap, uv, -1.0).xyz - 0.5);\n    }\n    }\n    variance += 1.0 - 0.25 * length(avgNormal);\n    gl_FragColor.g = varianceToRoughness(variance);\n}\n              `,\n\n\t\t\tblending: NoBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false\n\n\t\t} );\n\n\t\tshaderMaterial.type = 'RoughnessMipmapper';\n\n\t\treturn shaderMaterial;\n\n\t}\n\n\treturn RoughnessMipmapper;\n\n} )();\n\nexport { RoughnessMipmapper };\n"]},"metadata":{},"sourceType":"module"}