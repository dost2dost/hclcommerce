{"ast":null,"code":"/* global Node */\nvar schema = require('./schema');\n\nvar scenes = require('./scene/scenes');\n\nvar systems = require('./system');\n\nvar utils = require('../utils/');\n\nvar components = module.exports.components = {}; // Keep track of registered components.\n\nvar parseProperties = schema.parseProperties;\nvar parseProperty = schema.parseProperty;\nvar processSchema = schema.process;\nvar isSingleProp = schema.isSingleProperty;\nvar stringifyProperties = schema.stringifyProperties;\nvar stringifyProperty = schema.stringifyProperty;\nvar styleParser = utils.styleParser;\nvar warn = utils.debug('core:component:warn');\nvar aframeScript = document.currentScript;\nvar upperCaseRegExp = new RegExp('[A-Z]+'); // Object pools by component, created upon registration.\n\nvar objectPools = {};\n/**\n * Component class definition.\n *\n * Components configure appearance, modify behavior, or add functionality to\n * entities. The behavior and appearance of an entity can be changed at runtime\n * by adding, removing, or updating components. Entities do not share instances\n * of components.\n *\n * @member {object} el - Reference to the entity element.\n * @member {string} attrValue - Value of the corresponding HTML attribute.\n * @member {object} data - Component data populated by parsing the\n *         mapped attribute of the component plus applying defaults and mixins.\n */\n\nvar Component = module.exports.Component = function (el, attrValue, id) {\n  var self = this;\n  this.el = el;\n  this.id = id;\n  this.attrName = this.name + (id ? '__' + id : '');\n  this.evtDetail = {\n    id: this.id,\n    name: this.name\n  };\n  this.initialized = false;\n  this.isSingleProperty = isSingleProp(this.schema);\n  this.isSinglePropertyObject = this.isSingleProperty && isObject(parseProperty(undefined, this.schema)) && !(this.schema.default instanceof window.HTMLElement);\n  this.isObjectBased = !this.isSingleProperty || this.isSinglePropertyObject;\n  this.el.components[this.attrName] = this;\n  this.objectPool = objectPools[this.name];\n  const events = this.events;\n  this.events = {};\n  eventsBind(this, events); // Store component data from previous update call.\n\n  this.attrValue = undefined;\n\n  if (this.isObjectBased) {\n    this.nextData = this.objectPool.use(); // Drop any properties added by dynamic schemas in previous use\n\n    utils.objectPool.removeUnusedKeys(this.nextData, this.schema);\n    this.oldData = this.objectPool.use();\n    utils.objectPool.removeUnusedKeys(this.oldData, this.schema);\n    this.previousOldData = this.objectPool.use();\n    utils.objectPool.removeUnusedKeys(this.previousOldData, this.schema);\n    this.parsingAttrValue = this.objectPool.use();\n    utils.objectPool.removeUnusedKeys(this.parsingAttrValue, this.schema);\n  } else {\n    this.nextData = undefined;\n    this.oldData = undefined;\n    this.previousOldData = undefined;\n    this.parsingAttrValue = undefined;\n  } // Last value passed to updateProperties.\n\n\n  this.throttledEmitComponentChanged = utils.throttle(function emitChange() {\n    el.emit('componentchanged', self.evtDetail, false);\n  }, 200);\n  this.updateProperties(attrValue);\n};\n\nComponent.prototype = {\n  /**\n   * Contains the type schema and defaults for the data values.\n   * Data is coerced into the types of the values of the defaults.\n   */\n  schema: {},\n\n  /**\n   * Init handler. Similar to attachedCallback.\n   * Called during component initialization and is only run once.\n   * Components can use this to set initial state.\n   */\n  init: function () {\n    /* no-op */\n  },\n\n  /**\n   * Map of event names to binded event handlers that will be lifecycle-handled.\n   * Will be detached on pause / remove.\n   * Will be attached on play.\n   */\n  events: {},\n\n  /**\n   * Update handler. Similar to attributeChangedCallback.\n   * Called whenever component's data changes.\n   * Also called on component initialization when the component receives initial data.\n   *\n   * @param {object} prevData - Previous attributes of the component.\n   */\n  update: function (prevData) {\n    /* no-op */\n  },\n  updateSchema: undefined,\n\n  /**\n   * Tick handler.\n   * Called on each tick of the scene render loop.\n   * Affected by play and pause.\n   *\n   * @param {number} time - Scene tick time.\n   * @param {number} timeDelta - Difference in current render time and previous render time.\n   */\n  tick: undefined,\n\n  /**\n   * Tock handler.\n   * Called on each tock of the scene render loop.\n   * Affected by play and pause.\n   *\n   * @param {number} time - Scene tick time.\n   * @param {number} timeDelta - Difference in current render time and previous render time.\n   * @param {object} camera - Camera used to render the last frame.\n   */\n  tock: undefined,\n\n  /**\n   * Called to start any dynamic behavior (e.g., animation, AI, events, physics).\n   */\n  play: function () {\n    /* no-op */\n  },\n\n  /**\n   * Called to stop any dynamic behavior (e.g., animation, AI, events, physics).\n   */\n  pause: function () {\n    /* no-op */\n  },\n\n  /**\n   * Remove handler. Similar to detachedCallback.\n   * Called whenever component is removed from the entity (i.e., removeAttribute).\n   * Components can use this to reset behavior on the entity.\n   */\n  remove: function () {\n    /* no-op */\n  },\n\n  /**\n   * Parses each property based on property type.\n   * If component is single-property, then parses the single property value.\n   *\n   * @param {string} value - HTML attribute value.\n   * @param {boolean} silent - Suppress warning messages.\n   * @returns {object} Component data.\n   */\n  parse: function (value, silent) {\n    var schema = this.schema;\n\n    if (this.isSingleProperty) {\n      return parseProperty(value, schema);\n    }\n\n    return parseProperties(styleParser.parse(value), schema, true, this.name, silent);\n  },\n\n  /**\n   * Stringify properties if necessary.\n   *\n   * Only called from `Entity.setAttribute` for properties whose parsers accept a non-string\n   * value (e.g., selector, vec3 property types).\n   *\n   * @param {object} data - Complete component data.\n   * @returns {string}\n   */\n  stringify: function (data) {\n    var schema = this.schema;\n\n    if (typeof data === 'string') {\n      return data;\n    }\n\n    if (this.isSingleProperty) {\n      return stringifyProperty(data, schema);\n    }\n\n    data = stringifyProperties(data, schema);\n    return styleParser.stringify(data);\n  },\n\n  /**\n   * Update the cache of the pre-parsed attribute value.\n   *\n   * @param {string} value - New data.\n   * @param {boolean } clobber - Whether to wipe out and replace previous data.\n   */\n  updateCachedAttrValue: function (value, clobber) {\n    var newAttrValue;\n    var tempObject;\n    var property;\n\n    if (value === undefined) {\n      return;\n    } // If null value is the new attribute value, make the attribute value falsy.\n\n\n    if (value === null) {\n      if (this.isObjectBased && this.attrValue) {\n        this.objectPool.recycle(this.attrValue);\n      }\n\n      this.attrValue = undefined;\n      return;\n    }\n\n    if (value instanceof Object && !(value instanceof window.HTMLElement)) {\n      // If value is an object, copy it to our pooled newAttrValue object to use to update\n      // the attrValue.\n      tempObject = this.objectPool.use();\n      newAttrValue = utils.extend(tempObject, value);\n    } else {\n      newAttrValue = this.parseAttrValueForCache(value);\n    } // Merge new data with previous `attrValue` if updating and not clobbering.\n\n\n    if (this.isObjectBased && !clobber && this.attrValue) {\n      for (property in this.attrValue) {\n        if (newAttrValue[property] === undefined) {\n          newAttrValue[property] = this.attrValue[property];\n        }\n      }\n    } // Update attrValue.\n\n\n    if (this.isObjectBased && !this.attrValue) {\n      this.attrValue = this.objectPool.use();\n    }\n\n    utils.objectPool.clearObject(this.attrValue);\n    this.attrValue = extendProperties(this.attrValue, newAttrValue, this.isObjectBased);\n    utils.objectPool.clearObject(tempObject);\n  },\n\n  /**\n   * Given an HTML attribute value parses the string based on the component schema.\n   * To avoid double parsings of strings into strings we store the original instead\n   * of the parsed one\n   *\n   * @param {string} value - HTML attribute value\n   */\n  parseAttrValueForCache: function (value) {\n    var parsedValue;\n\n    if (typeof value !== 'string') {\n      return value;\n    }\n\n    if (this.isSingleProperty) {\n      parsedValue = this.schema.parse(value);\n      /**\n       * To avoid bogus double parsings. Cached values will be parsed when building\n       * component data. For instance when parsing a src id to its url, we want to cache\n       * original string and not the parsed one (#monster -> models/monster.dae)\n       * so when building data we parse the expected value.\n       */\n\n      if (typeof parsedValue === 'string') {\n        parsedValue = value;\n      }\n    } else {\n      // Parse using the style parser to avoid double parsing of individual properties.\n      utils.objectPool.clearObject(this.parsingAttrValue);\n      parsedValue = styleParser.parse(value, this.parsingAttrValue);\n    }\n\n    return parsedValue;\n  },\n\n  /**\n   * Write cached attribute data to the entity DOM element.\n   *\n   * @param {boolean} isDefault - Whether component is a default component. Always flush for\n   *   default components.\n   */\n  flushToDOM: function (isDefault) {\n    var attrValue = isDefault ? this.data : this.attrValue;\n\n    if (attrValue === null || attrValue === undefined) {\n      return;\n    }\n\n    window.HTMLElement.prototype.setAttribute.call(this.el, this.attrName, this.stringify(attrValue));\n  },\n\n  /**\n   * Apply new component data if data has changed (from setAttribute).\n   *\n   * @param {string} attrValue - HTML attribute value.\n   *        If undefined, use the cached attribute value and continue updating properties.\n   * @param {boolean} clobber - The previous component data is overwritten by the atrrValue\n   */\n  updateProperties: function (attrValue, clobber) {\n    var el = this.el; // Just cache the attribute if the entity has not loaded\n    // Components are not initialized until the entity has loaded\n\n    if (!el.hasLoaded) {\n      this.updateCachedAttrValue(attrValue);\n      return;\n    } // Parse the attribute value.\n    // Cache current attrValue for future updates. Updates `this.attrValue`.\n    // `null` means no value on purpose, do not set a default value, let mixins take over.\n\n\n    if (attrValue !== null) {\n      attrValue = this.parseAttrValueForCache(attrValue);\n    } // Cache current attrValue for future updates.\n\n\n    this.updateCachedAttrValue(attrValue, clobber);\n\n    if (this.initialized) {\n      this.updateComponent(attrValue, clobber);\n      this.callUpdateHandler();\n    } else {\n      this.initComponent();\n    }\n  },\n  initComponent: function () {\n    var el = this.el;\n    var initialOldData; // Build data.\n\n    if (this.updateSchema) {\n      this.updateSchema(this.buildData(this.attrValue, false, true));\n    }\n\n    this.data = this.buildData(this.attrValue); // Component is being already initialized.\n\n    if (el.initializingComponents[this.name]) {\n      return;\n    } // Prevent infinite loop in case of init method setting same component on the entity.\n\n\n    el.initializingComponents[this.name] = true; // Initialize component.\n\n    this.init();\n    this.initialized = true;\n    delete el.initializingComponents[this.name]; // Store current data as previous data for future updates.\n\n    this.oldData = extendProperties(this.oldData, this.data, this.isObjectBased); // For oldData, pass empty object to multiple-prop schemas or object single-prop schema.\n    // Pass undefined to rest of types.\n\n    initialOldData = this.isObjectBased ? this.objectPool.use() : undefined;\n    this.update(initialOldData);\n\n    if (this.isObjectBased) {\n      this.objectPool.recycle(initialOldData);\n    } // Play the component if the entity is playing.\n\n\n    if (el.isPlaying) {\n      this.play();\n    }\n\n    el.emit('componentinitialized', this.evtDetail, false);\n  },\n\n  /**\n   * @param attrValue - Passed argument from setAttribute.\n   */\n  updateComponent: function (attrValue, clobber) {\n    var key;\n    var mayNeedSchemaUpdate;\n\n    if (clobber) {\n      // Clobber. Rebuild.\n      if (this.updateSchema) {\n        this.updateSchema(this.buildData(this.attrValue, true, true));\n      }\n\n      this.data = this.buildData(this.attrValue, true, false);\n      return;\n    } // Apply new value to this.data in place since direct update.\n\n\n    if (this.isSingleProperty) {\n      if (this.isObjectBased) {\n        parseProperty(attrValue, this.schema);\n      } // Single-property (already parsed).\n\n\n      this.data = attrValue;\n      return;\n    }\n\n    parseProperties(attrValue, this.schema, true, this.name); // Check if we need to update schema.\n\n    if (this.schemaChangeKeys.length) {\n      for (key in attrValue) {\n        if (this.schema[key].schemaChange) {\n          mayNeedSchemaUpdate = true;\n          break;\n        }\n      }\n    }\n\n    if (mayNeedSchemaUpdate) {\n      // Rebuild data if need schema update.\n      if (this.updateSchema) {\n        this.updateSchema(this.buildData(this.attrValue, true, true));\n      }\n\n      this.data = this.buildData(this.attrValue, true, false);\n      return;\n    } // Normal update.\n\n\n    for (key in attrValue) {\n      if (attrValue[key] === undefined) {\n        continue;\n      }\n\n      this.data[key] = attrValue[key];\n    }\n  },\n\n  /**\n   * Check if component should fire update and fire update lifecycle handler.\n   */\n  callUpdateHandler: function () {\n    var hasComponentChanged; // Store the previous old data before we calculate the new oldData.\n\n    if (this.previousOldData instanceof Object) {\n      utils.objectPool.clearObject(this.previousOldData);\n    }\n\n    if (this.isObjectBased) {\n      copyData(this.previousOldData, this.oldData);\n    } else {\n      this.previousOldData = this.oldData;\n    }\n\n    hasComponentChanged = !utils.deepEqual(this.oldData, this.data); // Don't update if properties haven't changed.\n    // Always update rotation, position, scale.\n\n    if (!this.isPositionRotationScale && !hasComponentChanged) {\n      return;\n    } // Store current data as previous data for future updates.\n    // Reuse `this.oldData` object to try not to allocate another one.\n\n\n    if (this.oldData instanceof Object) {\n      utils.objectPool.clearObject(this.oldData);\n    }\n\n    this.oldData = extendProperties(this.oldData, this.data, this.isObjectBased); // Update component with the previous old data.\n\n    this.update(this.previousOldData);\n    this.throttledEmitComponentChanged();\n  },\n  handleMixinUpdate: function () {\n    this.data = this.buildData(this.attrValue);\n    this.callUpdateHandler();\n  },\n\n  /**\n   * Reset value of a property to the property's default value.\n   * If single-prop component, reset value to component's default value.\n   *\n   * @param {string} propertyName - Name of property to reset.\n   */\n  resetProperty: function (propertyName) {\n    if (this.isObjectBased) {\n      if (!(propertyName in this.attrValue)) {\n        return;\n      }\n\n      delete this.attrValue[propertyName];\n      this.data[propertyName] = this.schema[propertyName].default;\n    } else {\n      this.attrValue = this.schema.default;\n      this.data = this.schema.default;\n    }\n\n    this.updateProperties(this.attrValue);\n  },\n\n  /**\n   * Extend schema of component given a partial schema.\n   *\n   * Some components might want to mutate their schema based on certain properties.\n   * e.g., Material component changes its schema based on `shader` to account for different\n   * uniforms\n   *\n   * @param {object} schemaAddon - Schema chunk that extend base schema.\n   */\n  extendSchema: function (schemaAddon) {\n    var extendedSchema; // Clone base schema.\n\n    extendedSchema = utils.extend({}, components[this.name].schema); // Extend base schema with new schema chunk.\n\n    utils.extend(extendedSchema, schemaAddon);\n    this.schema = processSchema(extendedSchema);\n    this.el.emit('schemachanged', this.evtDetail);\n  },\n\n  /**\n   * Build component data from the current state of the entity.data.\n   *\n   * Precedence:\n   * 1. Defaults data\n   * 2. Mixin data.\n   * 3. Attribute data.\n   *\n   * Finally coerce the data to the types of the defaults.\n   *\n   * @param {object} newData - Element new data.\n   * @param {boolean} clobber - The previous data is completely replaced by the new one.\n   * @param {boolean} silent - Suppress warning messages.\n   * @return {object} The component data\n   */\n  buildData: function (newData, clobber, silent) {\n    var componentDefined;\n    var data;\n    var defaultValue;\n    var key;\n    var mixinData;\n    var nextData = this.nextData;\n    var schema = this.schema;\n    var i;\n    var mixinEls = this.el.mixinEls;\n    var previousData; // Whether component has a defined value. For arrays, treat empty as not defined.\n\n    componentDefined = newData && newData.constructor === Array ? newData.length : newData !== undefined && newData !== null;\n\n    if (this.isObjectBased) {\n      utils.objectPool.clearObject(nextData);\n    } // 1. Gather default values (lowest precendence).\n\n\n    if (this.isSingleProperty) {\n      if (this.isObjectBased) {\n        // If object-based single-prop, then copy over the data to our pooled object.\n        data = copyData(nextData, schema.default);\n      } else {\n        // If is plain single-prop, copy by value the default.\n        data = isObjectOrArray(schema.default) ? utils.clone(schema.default) : schema.default;\n      }\n    } else {\n      // Preserve previously set properties if clobber not enabled.\n      previousData = !clobber && this.attrValue; // Clone default value if object so components don't share object\n\n      data = previousData instanceof Object ? copyData(nextData, previousData) : nextData; // Apply defaults.\n\n      for (key in schema) {\n        defaultValue = schema[key].default;\n\n        if (data[key] !== undefined) {\n          continue;\n        } // Clone default value if object so components don't share object\n\n\n        data[key] = isObjectOrArray(defaultValue) ? utils.clone(defaultValue) : defaultValue;\n      }\n    } // 2. Gather mixin values.\n\n\n    for (i = 0; i < mixinEls.length; i++) {\n      mixinData = mixinEls[i].getAttribute(this.attrName);\n\n      if (!mixinData) {\n        continue;\n      }\n\n      data = extendProperties(data, mixinData, this.isObjectBased);\n    } // 3. Gather attribute values (highest precendence).\n\n\n    if (componentDefined) {\n      if (this.isSingleProperty) {\n        // If object-based, copy the value to not modify the original.\n        if (isObject(newData)) {\n          copyData(this.parsingAttrValue, newData);\n          return parseProperty(this.parsingAttrValue, schema);\n        }\n\n        return parseProperty(newData, schema);\n      }\n\n      data = extendProperties(data, newData, this.isObjectBased);\n    } else {\n      // Parse and coerce using the schema.\n      if (this.isSingleProperty) {\n        return parseProperty(data, schema);\n      }\n    }\n\n    return parseProperties(data, schema, undefined, this.name, silent);\n  },\n\n  /**\n   * Attach events from component-defined events map.\n   */\n  eventsAttach: function () {\n    var eventName; // Safety detach to prevent double-registration.\n\n    this.eventsDetach();\n\n    for (eventName in this.events) {\n      this.el.addEventListener(eventName, this.events[eventName]);\n    }\n  },\n\n  /**\n   * Detach events from component-defined events map.\n   */\n  eventsDetach: function () {\n    var eventName;\n\n    for (eventName in this.events) {\n      this.el.removeEventListener(eventName, this.events[eventName]);\n    }\n  },\n\n  /**\n   * Release and free memory.\n   */\n  destroy: function () {\n    this.objectPool.recycle(this.attrValue);\n    this.objectPool.recycle(this.oldData);\n    this.objectPool.recycle(this.parsingAttrValue);\n    this.attrValue = this.oldData = this.parsingAttrValue = undefined;\n  }\n};\n\nfunction eventsBind(component, events) {\n  var eventName;\n\n  for (eventName in events) {\n    component.events[eventName] = events[eventName].bind(component);\n  }\n} // For testing.\n\n\nif (window.debug) {\n  var registrationOrderWarnings = module.exports.registrationOrderWarnings = {};\n}\n/**\n * Register a component to A-Frame.\n *\n * @param {string} name - Component name.\n * @param {object} definition - Component schema and lifecycle method handlers.\n * @returns {object} Component.\n */\n\n\nmodule.exports.registerComponent = function (name, definition) {\n  var NewComponent;\n  var propertyName;\n  var proto = {};\n  var schema;\n  var schemaIsSingleProp; // Warning if component is statically registered after the scene.\n\n  if (document.currentScript && document.currentScript !== aframeScript) {\n    scenes.forEach(function checkPosition(sceneEl) {\n      // Okay to register component after the scene at runtime.\n      if (sceneEl.hasLoaded) {\n        return;\n      } // Check that component is declared before the scene.\n\n\n      if (document.currentScript.compareDocumentPosition(sceneEl) === Node.DOCUMENT_POSITION_FOLLOWING) {\n        return;\n      }\n\n      warn('The component `' + name + '` was registered in a <script> tag after the scene. ' + 'Component <script> tags in an HTML file should be declared *before* the scene ' + 'such that the component is available to entities during scene initialization.'); // For testing.\n\n      if (window.debug) {\n        registrationOrderWarnings[name] = true;\n      }\n    });\n  }\n\n  if (upperCaseRegExp.test(name) === true) {\n    warn('The component name `' + name + '` contains uppercase characters, but ' + 'HTML will ignore the capitalization of attribute names. ' + 'Change the name to be lowercase: `' + name.toLowerCase() + '`');\n  }\n\n  if (name.indexOf('__') !== -1) {\n    throw new Error('The component name `' + name + '` is not allowed. ' + 'The sequence __ (double underscore) is reserved to specify an id' + ' for multiple components of the same type');\n  } // Format definition object to prototype object.\n\n\n  Object.keys(definition).forEach(function (key) {\n    proto[key] = {\n      value: definition[key],\n      writable: true\n    };\n  });\n\n  if (components[name]) {\n    throw new Error('The component `' + name + '` has been already registered. ' + 'Check that you are not loading two versions of the same component ' + 'or two different components of the same name.');\n  }\n\n  NewComponent = function (el, attr, id) {\n    Component.call(this, el, attr, id);\n  };\n\n  NewComponent.prototype = Object.create(Component.prototype, proto);\n  NewComponent.prototype.name = name;\n  NewComponent.prototype.isPositionRotationScale = name === 'position' || name === 'rotation' || name === 'scale';\n  NewComponent.prototype.constructor = NewComponent;\n  NewComponent.prototype.system = systems && systems.systems[name];\n  NewComponent.prototype.play = wrapPlay(NewComponent.prototype.play);\n  NewComponent.prototype.pause = wrapPause(NewComponent.prototype.pause);\n  schema = utils.extend(processSchema(NewComponent.prototype.schema, NewComponent.prototype.name));\n  schemaIsSingleProp = isSingleProp(NewComponent.prototype.schema); // Keep track of keys that may potentially change the schema.\n\n  if (!schemaIsSingleProp) {\n    NewComponent.prototype.schemaChangeKeys = [];\n\n    for (propertyName in schema) {\n      if (schema[propertyName].schemaChange) {\n        NewComponent.prototype.schemaChangeKeys.push(propertyName);\n      }\n    }\n  } // Create object pool for class of components.\n\n\n  objectPools[name] = utils.objectPool.createPool();\n  components[name] = {\n    Component: NewComponent,\n    dependencies: NewComponent.prototype.dependencies,\n    isSingleProp: schemaIsSingleProp,\n    multiple: NewComponent.prototype.multiple,\n    name: name,\n    parse: NewComponent.prototype.parse,\n    parseAttrValueForCache: NewComponent.prototype.parseAttrValueForCache,\n    schema: schema,\n    stringify: NewComponent.prototype.stringify,\n    type: NewComponent.prototype.type\n  };\n  return NewComponent;\n};\n/**\n* Clone component data.\n* Clone only the properties that are plain objects while keeping a reference for the rest.\n*\n* @param data - Component data to clone.\n* @returns Cloned data.\n*/\n\n\nfunction copyData(dest, sourceData) {\n  var parsedProperty;\n  var key;\n\n  for (key in sourceData) {\n    if (sourceData[key] === undefined) {\n      continue;\n    }\n\n    parsedProperty = sourceData[key];\n    dest[key] = isObjectOrArray(parsedProperty) ? utils.clone(parsedProperty) : parsedProperty;\n  }\n\n  return dest;\n}\n/**\n* Object extending with checking for single-property schema.\n*\n* @param dest - Destination object or value.\n* @param source - Source object or value\n* @param {boolean} isObjectBased - Whether values are objects.\n* @returns Overridden object or value.\n*/\n\n\nfunction extendProperties(dest, source, isObjectBased) {\n  var key;\n\n  if (isObjectBased && source.constructor === Object) {\n    for (key in source) {\n      if (source[key] === undefined) {\n        continue;\n      }\n\n      if (source[key] && source[key].constructor === Object) {\n        dest[key] = utils.clone(source[key]);\n      } else {\n        dest[key] = source[key];\n      }\n    }\n\n    return dest;\n  }\n\n  return source;\n}\n/**\n * Checks if a component has defined a method that needs to run every frame.\n */\n\n\nfunction hasBehavior(component) {\n  return component.tick || component.tock;\n}\n/**\n * Wrapper for defined pause method.\n * Pause component by removing tick behavior and calling user's pause method.\n *\n * @param pauseMethod {function}\n */\n\n\nfunction wrapPause(pauseMethod) {\n  return function pause() {\n    var sceneEl = this.el.sceneEl;\n\n    if (!this.isPlaying) {\n      return;\n    }\n\n    pauseMethod.call(this);\n    this.isPlaying = false;\n    this.eventsDetach(); // Remove tick behavior.\n\n    if (!hasBehavior(this)) {\n      return;\n    }\n\n    sceneEl.removeBehavior(this);\n  };\n}\n/**\n * Wrapper for defined play method.\n * Play component by adding tick behavior and calling user's play method.\n *\n * @param playMethod {function}\n */\n\n\nfunction wrapPlay(playMethod) {\n  return function play() {\n    var sceneEl = this.el.sceneEl;\n    var shouldPlay = this.el.isPlaying && !this.isPlaying;\n\n    if (!this.initialized || !shouldPlay) {\n      return;\n    }\n\n    playMethod.call(this);\n    this.isPlaying = true;\n    this.eventsAttach(); // Add tick behavior.\n\n    if (!hasBehavior(this)) {\n      return;\n    }\n\n    sceneEl.addBehavior(this);\n  };\n}\n\nfunction isObject(value) {\n  return value && value.constructor === Object && !(value instanceof window.HTMLElement);\n}\n\nfunction isObjectOrArray(value) {\n  return value && (value.constructor === Object || value.constructor === Array) && !(value instanceof window.HTMLElement);\n}","map":{"version":3,"sources":["C:/Users/Hannuri/Desktop/RoyalCyber/my-first-app/node_modules/aframe/src/core/component.js"],"names":["schema","require","scenes","systems","utils","components","module","exports","parseProperties","parseProperty","processSchema","process","isSingleProp","isSingleProperty","stringifyProperties","stringifyProperty","styleParser","warn","debug","aframeScript","document","currentScript","upperCaseRegExp","RegExp","objectPools","Component","el","attrValue","id","self","attrName","name","evtDetail","initialized","isSinglePropertyObject","isObject","undefined","default","window","HTMLElement","isObjectBased","objectPool","events","eventsBind","nextData","use","removeUnusedKeys","oldData","previousOldData","parsingAttrValue","throttledEmitComponentChanged","throttle","emitChange","emit","updateProperties","prototype","init","update","prevData","updateSchema","tick","tock","play","pause","remove","parse","value","silent","stringify","data","updateCachedAttrValue","clobber","newAttrValue","tempObject","property","recycle","Object","extend","parseAttrValueForCache","clearObject","extendProperties","parsedValue","flushToDOM","isDefault","setAttribute","call","hasLoaded","updateComponent","callUpdateHandler","initComponent","initialOldData","buildData","initializingComponents","isPlaying","key","mayNeedSchemaUpdate","schemaChangeKeys","length","schemaChange","hasComponentChanged","copyData","deepEqual","isPositionRotationScale","handleMixinUpdate","resetProperty","propertyName","extendSchema","schemaAddon","extendedSchema","newData","componentDefined","defaultValue","mixinData","i","mixinEls","previousData","constructor","Array","isObjectOrArray","clone","getAttribute","eventsAttach","eventName","eventsDetach","addEventListener","removeEventListener","destroy","component","bind","registrationOrderWarnings","registerComponent","definition","NewComponent","proto","schemaIsSingleProp","forEach","checkPosition","sceneEl","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","test","toLowerCase","indexOf","Error","keys","writable","attr","create","system","wrapPlay","wrapPause","push","createPool","dependencies","multiple","type","dest","sourceData","parsedProperty","source","hasBehavior","pauseMethod","removeBehavior","playMethod","shouldPlay","addBehavior"],"mappings":"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","sourcesContent":["/* global Node */\nvar schema = require('./schema');\nvar scenes = require('./scene/scenes');\nvar systems = require('./system');\nvar utils = require('../utils/');\n\nvar components = module.exports.components = {};  // Keep track of registered components.\nvar parseProperties = schema.parseProperties;\nvar parseProperty = schema.parseProperty;\nvar processSchema = schema.process;\nvar isSingleProp = schema.isSingleProperty;\nvar stringifyProperties = schema.stringifyProperties;\nvar stringifyProperty = schema.stringifyProperty;\nvar styleParser = utils.styleParser;\nvar warn = utils.debug('core:component:warn');\n\nvar aframeScript = document.currentScript;\nvar upperCaseRegExp = new RegExp('[A-Z]+');\n\n// Object pools by component, created upon registration.\nvar objectPools = {};\n\n/**\n * Component class definition.\n *\n * Components configure appearance, modify behavior, or add functionality to\n * entities. The behavior and appearance of an entity can be changed at runtime\n * by adding, removing, or updating components. Entities do not share instances\n * of components.\n *\n * @member {object} el - Reference to the entity element.\n * @member {string} attrValue - Value of the corresponding HTML attribute.\n * @member {object} data - Component data populated by parsing the\n *         mapped attribute of the component plus applying defaults and mixins.\n */\nvar Component = module.exports.Component = function (el, attrValue, id) {\n  var self = this;\n  this.el = el;\n  this.id = id;\n  this.attrName = this.name + (id ? '__' + id : '');\n  this.evtDetail = {id: this.id, name: this.name};\n  this.initialized = false;\n  this.isSingleProperty = isSingleProp(this.schema);\n  this.isSinglePropertyObject = this.isSingleProperty &&\n                                isObject(parseProperty(undefined, this.schema)) &&\n                                !(this.schema.default instanceof window.HTMLElement);\n  this.isObjectBased = !this.isSingleProperty || this.isSinglePropertyObject;\n  this.el.components[this.attrName] = this;\n  this.objectPool = objectPools[this.name];\n\n  const events = this.events;\n  this.events = {};\n  eventsBind(this, events);\n\n  // Store component data from previous update call.\n  this.attrValue = undefined;\n  if (this.isObjectBased) {\n    this.nextData = this.objectPool.use();\n    // Drop any properties added by dynamic schemas in previous use\n    utils.objectPool.removeUnusedKeys(this.nextData, this.schema);\n    this.oldData = this.objectPool.use();\n    utils.objectPool.removeUnusedKeys(this.oldData, this.schema);\n    this.previousOldData = this.objectPool.use();\n    utils.objectPool.removeUnusedKeys(this.previousOldData, this.schema);\n    this.parsingAttrValue = this.objectPool.use();\n    utils.objectPool.removeUnusedKeys(this.parsingAttrValue, this.schema);\n  } else {\n    this.nextData = undefined;\n    this.oldData = undefined;\n    this.previousOldData = undefined;\n    this.parsingAttrValue = undefined;\n  }\n\n  // Last value passed to updateProperties.\n  this.throttledEmitComponentChanged = utils.throttle(function emitChange () {\n    el.emit('componentchanged', self.evtDetail, false);\n  }, 200);\n  this.updateProperties(attrValue);\n};\n\nComponent.prototype = {\n  /**\n   * Contains the type schema and defaults for the data values.\n   * Data is coerced into the types of the values of the defaults.\n   */\n  schema: {},\n\n  /**\n   * Init handler. Similar to attachedCallback.\n   * Called during component initialization and is only run once.\n   * Components can use this to set initial state.\n   */\n  init: function () { /* no-op */ },\n\n  /**\n   * Map of event names to binded event handlers that will be lifecycle-handled.\n   * Will be detached on pause / remove.\n   * Will be attached on play.\n   */\n  events: {},\n\n  /**\n   * Update handler. Similar to attributeChangedCallback.\n   * Called whenever component's data changes.\n   * Also called on component initialization when the component receives initial data.\n   *\n   * @param {object} prevData - Previous attributes of the component.\n   */\n  update: function (prevData) { /* no-op */ },\n\n  updateSchema: undefined,\n\n  /**\n   * Tick handler.\n   * Called on each tick of the scene render loop.\n   * Affected by play and pause.\n   *\n   * @param {number} time - Scene tick time.\n   * @param {number} timeDelta - Difference in current render time and previous render time.\n   */\n  tick: undefined,\n\n  /**\n   * Tock handler.\n   * Called on each tock of the scene render loop.\n   * Affected by play and pause.\n   *\n   * @param {number} time - Scene tick time.\n   * @param {number} timeDelta - Difference in current render time and previous render time.\n   * @param {object} camera - Camera used to render the last frame.\n   */\n  tock: undefined,\n\n  /**\n   * Called to start any dynamic behavior (e.g., animation, AI, events, physics).\n   */\n  play: function () { /* no-op */ },\n\n  /**\n   * Called to stop any dynamic behavior (e.g., animation, AI, events, physics).\n   */\n  pause: function () { /* no-op */ },\n\n  /**\n   * Remove handler. Similar to detachedCallback.\n   * Called whenever component is removed from the entity (i.e., removeAttribute).\n   * Components can use this to reset behavior on the entity.\n   */\n  remove: function () { /* no-op */ },\n\n  /**\n   * Parses each property based on property type.\n   * If component is single-property, then parses the single property value.\n   *\n   * @param {string} value - HTML attribute value.\n   * @param {boolean} silent - Suppress warning messages.\n   * @returns {object} Component data.\n   */\n  parse: function (value, silent) {\n    var schema = this.schema;\n    if (this.isSingleProperty) { return parseProperty(value, schema); }\n    return parseProperties(styleParser.parse(value), schema, true, this.name, silent);\n  },\n\n  /**\n   * Stringify properties if necessary.\n   *\n   * Only called from `Entity.setAttribute` for properties whose parsers accept a non-string\n   * value (e.g., selector, vec3 property types).\n   *\n   * @param {object} data - Complete component data.\n   * @returns {string}\n   */\n  stringify: function (data) {\n    var schema = this.schema;\n    if (typeof data === 'string') { return data; }\n    if (this.isSingleProperty) { return stringifyProperty(data, schema); }\n    data = stringifyProperties(data, schema);\n    return styleParser.stringify(data);\n  },\n\n  /**\n   * Update the cache of the pre-parsed attribute value.\n   *\n   * @param {string} value - New data.\n   * @param {boolean } clobber - Whether to wipe out and replace previous data.\n   */\n  updateCachedAttrValue: function (value, clobber) {\n    var newAttrValue;\n    var tempObject;\n    var property;\n\n    if (value === undefined) { return; }\n\n    // If null value is the new attribute value, make the attribute value falsy.\n    if (value === null) {\n      if (this.isObjectBased && this.attrValue) {\n        this.objectPool.recycle(this.attrValue);\n      }\n      this.attrValue = undefined;\n      return;\n    }\n\n    if (value instanceof Object && !(value instanceof window.HTMLElement)) {\n      // If value is an object, copy it to our pooled newAttrValue object to use to update\n      // the attrValue.\n      tempObject = this.objectPool.use();\n      newAttrValue = utils.extend(tempObject, value);\n    } else {\n      newAttrValue = this.parseAttrValueForCache(value);\n    }\n\n    // Merge new data with previous `attrValue` if updating and not clobbering.\n    if (this.isObjectBased && !clobber && this.attrValue) {\n      for (property in this.attrValue) {\n        if (newAttrValue[property] === undefined) {\n          newAttrValue[property] = this.attrValue[property];\n        }\n      }\n    }\n\n    // Update attrValue.\n    if (this.isObjectBased && !this.attrValue) {\n      this.attrValue = this.objectPool.use();\n    }\n    utils.objectPool.clearObject(this.attrValue);\n    this.attrValue = extendProperties(this.attrValue, newAttrValue, this.isObjectBased);\n    utils.objectPool.clearObject(tempObject);\n  },\n\n  /**\n   * Given an HTML attribute value parses the string based on the component schema.\n   * To avoid double parsings of strings into strings we store the original instead\n   * of the parsed one\n   *\n   * @param {string} value - HTML attribute value\n   */\n  parseAttrValueForCache: function (value) {\n    var parsedValue;\n    if (typeof value !== 'string') { return value; }\n    if (this.isSingleProperty) {\n      parsedValue = this.schema.parse(value);\n      /**\n       * To avoid bogus double parsings. Cached values will be parsed when building\n       * component data. For instance when parsing a src id to its url, we want to cache\n       * original string and not the parsed one (#monster -> models/monster.dae)\n       * so when building data we parse the expected value.\n       */\n      if (typeof parsedValue === 'string') { parsedValue = value; }\n    } else {\n      // Parse using the style parser to avoid double parsing of individual properties.\n      utils.objectPool.clearObject(this.parsingAttrValue);\n      parsedValue = styleParser.parse(value, this.parsingAttrValue);\n    }\n    return parsedValue;\n  },\n\n  /**\n   * Write cached attribute data to the entity DOM element.\n   *\n   * @param {boolean} isDefault - Whether component is a default component. Always flush for\n   *   default components.\n   */\n  flushToDOM: function (isDefault) {\n    var attrValue = isDefault ? this.data : this.attrValue;\n    if (attrValue === null || attrValue === undefined) { return; }\n    window.HTMLElement.prototype.setAttribute.call(this.el, this.attrName,\n                                                   this.stringify(attrValue));\n  },\n\n  /**\n   * Apply new component data if data has changed (from setAttribute).\n   *\n   * @param {string} attrValue - HTML attribute value.\n   *        If undefined, use the cached attribute value and continue updating properties.\n   * @param {boolean} clobber - The previous component data is overwritten by the atrrValue\n   */\n  updateProperties: function (attrValue, clobber) {\n    var el = this.el;\n\n    // Just cache the attribute if the entity has not loaded\n    // Components are not initialized until the entity has loaded\n    if (!el.hasLoaded) {\n      this.updateCachedAttrValue(attrValue);\n      return;\n    }\n\n    // Parse the attribute value.\n    // Cache current attrValue for future updates. Updates `this.attrValue`.\n    // `null` means no value on purpose, do not set a default value, let mixins take over.\n    if (attrValue !== null) {\n      attrValue = this.parseAttrValueForCache(attrValue);\n    }\n\n    // Cache current attrValue for future updates.\n    this.updateCachedAttrValue(attrValue, clobber);\n\n    if (this.initialized) {\n      this.updateComponent(attrValue, clobber);\n      this.callUpdateHandler();\n    } else {\n      this.initComponent();\n    }\n  },\n\n  initComponent: function () {\n    var el = this.el;\n    var initialOldData;\n\n    // Build data.\n    if (this.updateSchema) { this.updateSchema(this.buildData(this.attrValue, false, true)); }\n    this.data = this.buildData(this.attrValue);\n\n    // Component is being already initialized.\n    if (el.initializingComponents[this.name]) { return; }\n\n    // Prevent infinite loop in case of init method setting same component on the entity.\n    el.initializingComponents[this.name] = true;\n    // Initialize component.\n    this.init();\n    this.initialized = true;\n    delete el.initializingComponents[this.name];\n\n    // Store current data as previous data for future updates.\n    this.oldData = extendProperties(this.oldData, this.data, this.isObjectBased);\n\n    // For oldData, pass empty object to multiple-prop schemas or object single-prop schema.\n    // Pass undefined to rest of types.\n    initialOldData = this.isObjectBased ? this.objectPool.use() : undefined;\n    this.update(initialOldData);\n    if (this.isObjectBased) { this.objectPool.recycle(initialOldData); }\n\n    // Play the component if the entity is playing.\n    if (el.isPlaying) { this.play(); }\n    el.emit('componentinitialized', this.evtDetail, false);\n  },\n\n  /**\n   * @param attrValue - Passed argument from setAttribute.\n   */\n  updateComponent: function (attrValue, clobber) {\n    var key;\n    var mayNeedSchemaUpdate;\n\n    if (clobber) {\n      // Clobber. Rebuild.\n      if (this.updateSchema) {\n        this.updateSchema(this.buildData(this.attrValue, true, true));\n      }\n      this.data = this.buildData(this.attrValue, true, false);\n      return;\n    }\n\n    // Apply new value to this.data in place since direct update.\n    if (this.isSingleProperty) {\n      if (this.isObjectBased) {\n        parseProperty(attrValue, this.schema);\n      }\n      // Single-property (already parsed).\n      this.data = attrValue;\n      return;\n    }\n\n    parseProperties(attrValue, this.schema, true, this.name);\n\n    // Check if we need to update schema.\n    if (this.schemaChangeKeys.length) {\n      for (key in attrValue) {\n        if (this.schema[key].schemaChange) {\n          mayNeedSchemaUpdate = true;\n          break;\n        }\n      }\n    }\n    if (mayNeedSchemaUpdate) {\n      // Rebuild data if need schema update.\n      if (this.updateSchema) {\n        this.updateSchema(this.buildData(this.attrValue, true, true));\n      }\n      this.data = this.buildData(this.attrValue, true, false);\n      return;\n    }\n\n    // Normal update.\n    for (key in attrValue) {\n      if (attrValue[key] === undefined) { continue; }\n      this.data[key] = attrValue[key];\n    }\n  },\n\n  /**\n   * Check if component should fire update and fire update lifecycle handler.\n   */\n  callUpdateHandler: function () {\n    var hasComponentChanged;\n\n    // Store the previous old data before we calculate the new oldData.\n    if (this.previousOldData instanceof Object) {\n      utils.objectPool.clearObject(this.previousOldData);\n    }\n    if (this.isObjectBased) {\n      copyData(this.previousOldData, this.oldData);\n    } else {\n      this.previousOldData = this.oldData;\n    }\n\n    hasComponentChanged = !utils.deepEqual(this.oldData, this.data);\n\n    // Don't update if properties haven't changed.\n    // Always update rotation, position, scale.\n    if (!this.isPositionRotationScale && !hasComponentChanged) { return; }\n\n    // Store current data as previous data for future updates.\n    // Reuse `this.oldData` object to try not to allocate another one.\n    if (this.oldData instanceof Object) { utils.objectPool.clearObject(this.oldData); }\n    this.oldData = extendProperties(this.oldData, this.data, this.isObjectBased);\n\n    // Update component with the previous old data.\n    this.update(this.previousOldData);\n\n    this.throttledEmitComponentChanged();\n  },\n\n  handleMixinUpdate: function () {\n    this.data = this.buildData(this.attrValue);\n    this.callUpdateHandler();\n  },\n\n  /**\n   * Reset value of a property to the property's default value.\n   * If single-prop component, reset value to component's default value.\n   *\n   * @param {string} propertyName - Name of property to reset.\n   */\n  resetProperty: function (propertyName) {\n    if (this.isObjectBased) {\n      if (!(propertyName in this.attrValue)) { return; }\n      delete this.attrValue[propertyName];\n      this.data[propertyName] = this.schema[propertyName].default;\n    } else {\n      this.attrValue = this.schema.default;\n      this.data = this.schema.default;\n    }\n    this.updateProperties(this.attrValue);\n  },\n\n  /**\n   * Extend schema of component given a partial schema.\n   *\n   * Some components might want to mutate their schema based on certain properties.\n   * e.g., Material component changes its schema based on `shader` to account for different\n   * uniforms\n   *\n   * @param {object} schemaAddon - Schema chunk that extend base schema.\n   */\n  extendSchema: function (schemaAddon) {\n    var extendedSchema;\n    // Clone base schema.\n    extendedSchema = utils.extend({}, components[this.name].schema);\n    // Extend base schema with new schema chunk.\n    utils.extend(extendedSchema, schemaAddon);\n    this.schema = processSchema(extendedSchema);\n    this.el.emit('schemachanged', this.evtDetail);\n  },\n\n  /**\n   * Build component data from the current state of the entity.data.\n   *\n   * Precedence:\n   * 1. Defaults data\n   * 2. Mixin data.\n   * 3. Attribute data.\n   *\n   * Finally coerce the data to the types of the defaults.\n   *\n   * @param {object} newData - Element new data.\n   * @param {boolean} clobber - The previous data is completely replaced by the new one.\n   * @param {boolean} silent - Suppress warning messages.\n   * @return {object} The component data\n   */\n  buildData: function (newData, clobber, silent) {\n    var componentDefined;\n    var data;\n    var defaultValue;\n    var key;\n    var mixinData;\n    var nextData = this.nextData;\n    var schema = this.schema;\n    var i;\n    var mixinEls = this.el.mixinEls;\n    var previousData;\n\n    // Whether component has a defined value. For arrays, treat empty as not defined.\n    componentDefined = newData && newData.constructor === Array\n      ? newData.length\n      : newData !== undefined && newData !== null;\n\n    if (this.isObjectBased) { utils.objectPool.clearObject(nextData); }\n\n    // 1. Gather default values (lowest precendence).\n    if (this.isSingleProperty) {\n      if (this.isObjectBased) {\n        // If object-based single-prop, then copy over the data to our pooled object.\n        data = copyData(nextData, schema.default);\n      } else {\n        // If is plain single-prop, copy by value the default.\n        data = isObjectOrArray(schema.default)\n          ? utils.clone(schema.default)\n          : schema.default;\n      }\n    } else {\n      // Preserve previously set properties if clobber not enabled.\n      previousData = !clobber && this.attrValue;\n\n      // Clone default value if object so components don't share object\n      data = previousData instanceof Object\n        ? copyData(nextData, previousData)\n        : nextData;\n\n      // Apply defaults.\n      for (key in schema) {\n        defaultValue = schema[key].default;\n        if (data[key] !== undefined) { continue; }\n        // Clone default value if object so components don't share object\n        data[key] = isObjectOrArray(defaultValue)\n          ? utils.clone(defaultValue)\n          : defaultValue;\n      }\n    }\n\n    // 2. Gather mixin values.\n    for (i = 0; i < mixinEls.length; i++) {\n      mixinData = mixinEls[i].getAttribute(this.attrName);\n      if (!mixinData) { continue; }\n      data = extendProperties(data, mixinData, this.isObjectBased);\n    }\n\n    // 3. Gather attribute values (highest precendence).\n    if (componentDefined) {\n      if (this.isSingleProperty) {\n        // If object-based, copy the value to not modify the original.\n        if (isObject(newData)) {\n          copyData(this.parsingAttrValue, newData);\n          return parseProperty(this.parsingAttrValue, schema);\n        }\n        return parseProperty(newData, schema);\n      }\n      data = extendProperties(data, newData, this.isObjectBased);\n    } else {\n      // Parse and coerce using the schema.\n      if (this.isSingleProperty) { return parseProperty(data, schema); }\n    }\n\n    return parseProperties(data, schema, undefined, this.name, silent);\n  },\n\n  /**\n   * Attach events from component-defined events map.\n   */\n  eventsAttach: function () {\n    var eventName;\n    // Safety detach to prevent double-registration.\n    this.eventsDetach();\n    for (eventName in this.events) {\n      this.el.addEventListener(eventName, this.events[eventName]);\n    }\n  },\n\n  /**\n   * Detach events from component-defined events map.\n   */\n  eventsDetach: function () {\n    var eventName;\n    for (eventName in this.events) {\n      this.el.removeEventListener(eventName, this.events[eventName]);\n    }\n  },\n\n  /**\n   * Release and free memory.\n   */\n  destroy: function () {\n    this.objectPool.recycle(this.attrValue);\n    this.objectPool.recycle(this.oldData);\n    this.objectPool.recycle(this.parsingAttrValue);\n    this.attrValue = this.oldData = this.parsingAttrValue = undefined;\n  }\n};\n\nfunction eventsBind (component, events) {\n  var eventName;\n  for (eventName in events) {\n    component.events[eventName] = events[eventName].bind(component);\n  }\n}\n\n// For testing.\nif (window.debug) {\n  var registrationOrderWarnings = module.exports.registrationOrderWarnings = {};\n}\n\n/**\n * Register a component to A-Frame.\n *\n * @param {string} name - Component name.\n * @param {object} definition - Component schema and lifecycle method handlers.\n * @returns {object} Component.\n */\nmodule.exports.registerComponent = function (name, definition) {\n  var NewComponent;\n  var propertyName;\n  var proto = {};\n  var schema;\n  var schemaIsSingleProp;\n\n  // Warning if component is statically registered after the scene.\n  if (document.currentScript && document.currentScript !== aframeScript) {\n    scenes.forEach(function checkPosition (sceneEl) {\n      // Okay to register component after the scene at runtime.\n      if (sceneEl.hasLoaded) { return; }\n\n      // Check that component is declared before the scene.\n      if (document.currentScript.compareDocumentPosition(sceneEl) ===\n          Node.DOCUMENT_POSITION_FOLLOWING) { return; }\n\n      warn('The component `' + name + '` was registered in a <script> tag after the scene. ' +\n           'Component <script> tags in an HTML file should be declared *before* the scene ' +\n           'such that the component is available to entities during scene initialization.');\n\n      // For testing.\n      if (window.debug) { registrationOrderWarnings[name] = true; }\n    });\n  }\n\n  if (upperCaseRegExp.test(name) === true) {\n    warn('The component name `' + name + '` contains uppercase characters, but ' +\n         'HTML will ignore the capitalization of attribute names. ' +\n         'Change the name to be lowercase: `' + name.toLowerCase() + '`');\n  }\n\n  if (name.indexOf('__') !== -1) {\n    throw new Error('The component name `' + name + '` is not allowed. ' +\n                    'The sequence __ (double underscore) is reserved to specify an id' +\n                    ' for multiple components of the same type');\n  }\n\n  // Format definition object to prototype object.\n  Object.keys(definition).forEach(function (key) {\n    proto[key] = {\n      value: definition[key],\n      writable: true\n    };\n  });\n\n  if (components[name]) {\n    throw new Error('The component `' + name + '` has been already registered. ' +\n                    'Check that you are not loading two versions of the same component ' +\n                    'or two different components of the same name.');\n  }\n\n  NewComponent = function (el, attr, id) {\n    Component.call(this, el, attr, id);\n  };\n\n  NewComponent.prototype = Object.create(Component.prototype, proto);\n  NewComponent.prototype.name = name;\n  NewComponent.prototype.isPositionRotationScale =\n    name === 'position' || name === 'rotation' || name === 'scale';\n  NewComponent.prototype.constructor = NewComponent;\n  NewComponent.prototype.system = systems && systems.systems[name];\n  NewComponent.prototype.play = wrapPlay(NewComponent.prototype.play);\n  NewComponent.prototype.pause = wrapPause(NewComponent.prototype.pause);\n\n  schema = utils.extend(processSchema(NewComponent.prototype.schema,\n                                      NewComponent.prototype.name));\n  schemaIsSingleProp = isSingleProp(NewComponent.prototype.schema);\n\n  // Keep track of keys that may potentially change the schema.\n  if (!schemaIsSingleProp) {\n    NewComponent.prototype.schemaChangeKeys = [];\n    for (propertyName in schema) {\n      if (schema[propertyName].schemaChange) {\n        NewComponent.prototype.schemaChangeKeys.push(propertyName);\n      }\n    }\n  }\n\n  // Create object pool for class of components.\n  objectPools[name] = utils.objectPool.createPool();\n\n  components[name] = {\n    Component: NewComponent,\n    dependencies: NewComponent.prototype.dependencies,\n    isSingleProp: schemaIsSingleProp,\n    multiple: NewComponent.prototype.multiple,\n    name: name,\n    parse: NewComponent.prototype.parse,\n    parseAttrValueForCache: NewComponent.prototype.parseAttrValueForCache,\n    schema: schema,\n    stringify: NewComponent.prototype.stringify,\n    type: NewComponent.prototype.type\n  };\n  return NewComponent;\n};\n\n/**\n* Clone component data.\n* Clone only the properties that are plain objects while keeping a reference for the rest.\n*\n* @param data - Component data to clone.\n* @returns Cloned data.\n*/\nfunction copyData (dest, sourceData) {\n  var parsedProperty;\n  var key;\n  for (key in sourceData) {\n    if (sourceData[key] === undefined) { continue; }\n    parsedProperty = sourceData[key];\n    dest[key] = isObjectOrArray(parsedProperty)\n      ? utils.clone(parsedProperty)\n      : parsedProperty;\n  }\n  return dest;\n}\n\n/**\n* Object extending with checking for single-property schema.\n*\n* @param dest - Destination object or value.\n* @param source - Source object or value\n* @param {boolean} isObjectBased - Whether values are objects.\n* @returns Overridden object or value.\n*/\nfunction extendProperties (dest, source, isObjectBased) {\n  var key;\n  if (isObjectBased && source.constructor === Object) {\n    for (key in source) {\n      if (source[key] === undefined) { continue; }\n      if (source[key] && source[key].constructor === Object) {\n        dest[key] = utils.clone(source[key]);\n      } else {\n        dest[key] = source[key];\n      }\n    }\n    return dest;\n  }\n  return source;\n}\n\n/**\n * Checks if a component has defined a method that needs to run every frame.\n */\nfunction hasBehavior (component) {\n  return component.tick || component.tock;\n}\n\n/**\n * Wrapper for defined pause method.\n * Pause component by removing tick behavior and calling user's pause method.\n *\n * @param pauseMethod {function}\n */\nfunction wrapPause (pauseMethod) {\n  return function pause () {\n    var sceneEl = this.el.sceneEl;\n    if (!this.isPlaying) { return; }\n    pauseMethod.call(this);\n    this.isPlaying = false;\n    this.eventsDetach();\n    // Remove tick behavior.\n    if (!hasBehavior(this)) { return; }\n    sceneEl.removeBehavior(this);\n  };\n}\n\n/**\n * Wrapper for defined play method.\n * Play component by adding tick behavior and calling user's play method.\n *\n * @param playMethod {function}\n */\nfunction wrapPlay (playMethod) {\n  return function play () {\n    var sceneEl = this.el.sceneEl;\n    var shouldPlay = this.el.isPlaying && !this.isPlaying;\n    if (!this.initialized || !shouldPlay) { return; }\n    playMethod.call(this);\n    this.isPlaying = true;\n    this.eventsAttach();\n    // Add tick behavior.\n    if (!hasBehavior(this)) { return; }\n    sceneEl.addBehavior(this);\n  };\n}\n\nfunction isObject (value) {\n  return value && value.constructor === Object && !(value instanceof window.HTMLElement);\n}\n\nfunction isObjectOrArray (value) {\n  return value && (value.constructor === Object || value.constructor === Array) &&\n         !(value instanceof window.HTMLElement);\n}\n"]},"metadata":{},"sourceType":"script"}