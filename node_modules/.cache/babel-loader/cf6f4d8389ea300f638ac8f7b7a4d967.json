{"ast":null,"code":"var registerShader = require('../core/shader').registerShader;\n/**\n * Signed distance field.\n * Used by text component.\n */\n\n\nmodule.exports.Shader = registerShader('sdf', {\n  schema: {\n    alphaTest: {\n      type: 'number',\n      is: 'uniform',\n      default: 0.5\n    },\n    color: {\n      type: 'color',\n      is: 'uniform',\n      default: 'white'\n    },\n    map: {\n      type: 'map',\n      is: 'uniform'\n    },\n    opacity: {\n      type: 'number',\n      is: 'uniform',\n      default: 1.0\n    }\n  },\n  raw: true,\n  vertexShader: ['attribute vec2 uv;', 'attribute vec3 position;', 'uniform mat4 projectionMatrix;', 'uniform mat4 modelViewMatrix;', 'varying vec2 vUV;', 'void main(void) {', '  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);', '  vUV = uv;', '}'].join('\\n'),\n  fragmentShader: ['#ifdef GL_OES_standard_derivatives', '#extension GL_OES_standard_derivatives: enable', '#endif', 'precision highp float;', 'uniform float alphaTest;', 'uniform float opacity;', 'uniform sampler2D map;', 'uniform vec3 color;', 'varying vec2 vUV;', '#ifdef GL_OES_standard_derivatives', '  float contour(float width, float value) {', '    return smoothstep(0.5 - value, 0.5 + value, width);', '  }', '#else', '  float aastep(float value, float afwidth) {', '    return smoothstep(0.5 - afwidth, 0.5 + afwidth, value);', '  }', '#endif', // FIXME: Experimentally determined constants.\n  '#define BIG_ENOUGH 0.001', '#define MODIFIED_ALPHATEST (0.02 * isBigEnough / BIG_ENOUGH)', '#define ALL_SMOOTH 0.4', '#define ALL_ROUGH 0.02', '#define DISCARD_ALPHA (alphaTest / (2.2 - 1.2 * ratio))', 'void main() {', // When we have derivatives and can get texel size for supersampling.\n  '  #ifdef GL_OES_standard_derivatives', '    vec2 uv = vUV;', '    vec4 texColor = texture2D(map, uv);', '    float dist = texColor.a;', '    float width = fwidth(dist);', '    float alpha = contour(dist, width);', '    float dscale = 0.353505;', '    vec2 duv = dscale * (dFdx(uv) + dFdy(uv));', '    float isBigEnough = max(abs(duv.x), abs(duv.y));', // When texel is too small, blend raw alpha value rather than supersampling.\n  // FIXME: experimentally determined constant\n  '    if (isBigEnough > BIG_ENOUGH) {', '      float ratio = BIG_ENOUGH / isBigEnough;', '      alpha = ratio * alpha + (1.0 - ratio) * dist;', '    }', // Otherwise do weighted supersampling.\n  // FIXME: why this weighting?\n  '    if (isBigEnough <= BIG_ENOUGH) {', '      vec4 box = vec4 (uv - duv, uv + duv);', '      alpha = (alpha + 0.5 * (', '        contour(texture2D(map, box.xy).a, width)', '        + contour(texture2D(map, box.zw).a, width)', '        + contour(texture2D(map, box.xw).a, width)', '        + contour(texture2D(map, box.zy).a, width)', '      )) / 3.0;', '    }', // Do modified alpha test.\n  '    if (alpha < alphaTest * MODIFIED_ALPHATEST) { discard; return; }', '  #else', // When we don't have derivatives, use approximations.\n  '    vec4 texColor = texture2D(map, vUV);', '    float value = texColor.a;', // FIXME: if we understood font pixel dimensions, this could probably be improved\n  '    float afwidth = (1.0 / 32.0) * (1.4142135623730951 / (2.0 * gl_FragCoord.w));', '    float alpha = aastep(value, afwidth);', // Use gl_FragCoord.w to guess when we should blend.\n  // FIXME: If we understood font pixel dimensions, this could probably be improved.\n  '    float ratio = (gl_FragCoord.w >= ALL_SMOOTH) ? 1.0 : (gl_FragCoord.w < ALL_ROUGH) ? 0.0 : (gl_FragCoord.w - ALL_ROUGH) / (ALL_SMOOTH - ALL_ROUGH);', '    if (alpha < alphaTest) { if (ratio >= 1.0) { discard; return; } alpha = 0.0; }', '    alpha = alpha * ratio + (1.0 - ratio) * value;', '    if (ratio < 1.0 && alpha <= DISCARD_ALPHA) { discard; return; }', '  #endif', '  gl_FragColor = vec4(color, opacity * alpha);', '}'].join('\\n')\n});","map":{"version":3,"sources":["C:/Users/Hannuri/Desktop/RoyalCyber/my-first-app/node_modules/aframe/src/shaders/sdf.js"],"names":["registerShader","require","module","exports","Shader","schema","alphaTest","type","is","default","color","map","opacity","raw","vertexShader","join","fragmentShader"],"mappings":"AAAA,IAAIA,cAAc,GAAGC,OAAO,CAAC,gBAAD,CAAP,CAA0BD,cAA/C;AAEA;;;;;;AAIAE,MAAM,CAACC,OAAP,CAAeC,MAAf,GAAwBJ,cAAc,CAAC,KAAD,EAAQ;AAC5CK,EAAAA,MAAM,EAAE;AACNC,IAAAA,SAAS,EAAE;AAACC,MAAAA,IAAI,EAAE,QAAP;AAAiBC,MAAAA,EAAE,EAAE,SAArB;AAAgCC,MAAAA,OAAO,EAAE;AAAzC,KADL;AAENC,IAAAA,KAAK,EAAE;AAACH,MAAAA,IAAI,EAAE,OAAP;AAAgBC,MAAAA,EAAE,EAAE,SAApB;AAA+BC,MAAAA,OAAO,EAAE;AAAxC,KAFD;AAGNE,IAAAA,GAAG,EAAE;AAACJ,MAAAA,IAAI,EAAE,KAAP;AAAcC,MAAAA,EAAE,EAAE;AAAlB,KAHC;AAINI,IAAAA,OAAO,EAAE;AAACL,MAAAA,IAAI,EAAE,QAAP;AAAiBC,MAAAA,EAAE,EAAE,SAArB;AAAgCC,MAAAA,OAAO,EAAE;AAAzC;AAJH,GADoC;AAQ5CI,EAAAA,GAAG,EAAE,IARuC;AAU5CC,EAAAA,YAAY,EAAE,CACZ,oBADY,EAEZ,0BAFY,EAGZ,gCAHY,EAIZ,+BAJY,EAKZ,mBALY,EAMZ,mBANY,EAOZ,2EAPY,EAQZ,aARY,EASZ,GATY,EAUZC,IAVY,CAUP,IAVO,CAV8B;AAsB5CC,EAAAA,cAAc,EAAE,CACd,oCADc,EAEd,gDAFc,EAGd,QAHc,EAKd,wBALc,EAMd,0BANc,EAOd,wBAPc,EAQd,wBARc,EASd,qBATc,EAUd,mBAVc,EAYd,oCAZc,EAad,6CAbc,EAcd,yDAdc,EAed,KAfc,EAgBd,OAhBc,EAiBd,8CAjBc,EAkBd,6DAlBc,EAmBd,KAnBc,EAoBd,QApBc,EAsBd;AACA,4BAvBc,EAwBd,8DAxBc,EAyBd,wBAzBc,EA0Bd,wBA1Bc,EA2Bd,yDA3Bc,EA6Bd,eA7Bc,EA8BX;AACH,wCA/Bc,EAgCd,oBAhCc,EAiCd,yCAjCc,EAkCd,8BAlCc,EAmCd,iCAnCc,EAoCd,yCApCc,EAqCd,8BArCc,EAuCd,gDAvCc,EAwCd,sDAxCc,EA0CT;AACA;AACL,uCA5Cc,EA6Cd,+CA7Cc,EA8Cd,qDA9Cc,EA+Cd,OA/Cc,EAiDT;AACA;AACL,wCAnDc,EAoDd,6CApDc,EAqDd,gCArDc,EAsDd,kDAtDc,EAuDd,oDAvDc,EAwDd,oDAxDc,EAyDd,oDAzDc,EA0Dd,iBA1Dc,EA2Dd,OA3Dc,EA6DT;AACL,wEA9Dc,EAgEd,SAhEc,EAiET;AACL,4CAlEc,EAmEd,+BAnEc,EAoET;AACL,qFArEc,EAsEd,2CAtEc,EAwET;AACA;AACL,0JA1Ec,EA2Ed,oFA3Ec,EA4Ed,oDA5Ec,EA6Ed,qEA7Ec,EA8Ed,UA9Ec,EAgFd,gDAhFc,EAiFd,GAjFc,EAkFdD,IAlFc,CAkFT,IAlFS;AAtB4B,CAAR,CAAtC","sourcesContent":["var registerShader = require('../core/shader').registerShader;\n\n/**\n * Signed distance field.\n * Used by text component.\n */\nmodule.exports.Shader = registerShader('sdf', {\n  schema: {\n    alphaTest: {type: 'number', is: 'uniform', default: 0.5},\n    color: {type: 'color', is: 'uniform', default: 'white'},\n    map: {type: 'map', is: 'uniform'},\n    opacity: {type: 'number', is: 'uniform', default: 1.0}\n  },\n\n  raw: true,\n\n  vertexShader: [\n    'attribute vec2 uv;',\n    'attribute vec3 position;',\n    'uniform mat4 projectionMatrix;',\n    'uniform mat4 modelViewMatrix;',\n    'varying vec2 vUV;',\n    'void main(void) {',\n    '  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',\n    '  vUV = uv;',\n    '}'\n  ].join('\\n'),\n\n  fragmentShader: [\n    '#ifdef GL_OES_standard_derivatives',\n    '#extension GL_OES_standard_derivatives: enable',\n    '#endif',\n\n    'precision highp float;',\n    'uniform float alphaTest;',\n    'uniform float opacity;',\n    'uniform sampler2D map;',\n    'uniform vec3 color;',\n    'varying vec2 vUV;',\n\n    '#ifdef GL_OES_standard_derivatives',\n    '  float contour(float width, float value) {',\n    '    return smoothstep(0.5 - value, 0.5 + value, width);',\n    '  }',\n    '#else',\n    '  float aastep(float value, float afwidth) {',\n    '    return smoothstep(0.5 - afwidth, 0.5 + afwidth, value);',\n    '  }',\n    '#endif',\n\n    // FIXME: Experimentally determined constants.\n    '#define BIG_ENOUGH 0.001',\n    '#define MODIFIED_ALPHATEST (0.02 * isBigEnough / BIG_ENOUGH)',\n    '#define ALL_SMOOTH 0.4',\n    '#define ALL_ROUGH 0.02',\n    '#define DISCARD_ALPHA (alphaTest / (2.2 - 1.2 * ratio))',\n\n    'void main() {',\n       // When we have derivatives and can get texel size for supersampling.\n    '  #ifdef GL_OES_standard_derivatives',\n    '    vec2 uv = vUV;',\n    '    vec4 texColor = texture2D(map, uv);',\n    '    float dist = texColor.a;',\n    '    float width = fwidth(dist);',\n    '    float alpha = contour(dist, width);',\n    '    float dscale = 0.353505;',\n\n    '    vec2 duv = dscale * (dFdx(uv) + dFdy(uv));',\n    '    float isBigEnough = max(abs(duv.x), abs(duv.y));',\n\n         // When texel is too small, blend raw alpha value rather than supersampling.\n         // FIXME: experimentally determined constant\n    '    if (isBigEnough > BIG_ENOUGH) {',\n    '      float ratio = BIG_ENOUGH / isBigEnough;',\n    '      alpha = ratio * alpha + (1.0 - ratio) * dist;',\n    '    }',\n\n         // Otherwise do weighted supersampling.\n         // FIXME: why this weighting?\n    '    if (isBigEnough <= BIG_ENOUGH) {',\n    '      vec4 box = vec4 (uv - duv, uv + duv);',\n    '      alpha = (alpha + 0.5 * (',\n    '        contour(texture2D(map, box.xy).a, width)',\n    '        + contour(texture2D(map, box.zw).a, width)',\n    '        + contour(texture2D(map, box.xw).a, width)',\n    '        + contour(texture2D(map, box.zy).a, width)',\n    '      )) / 3.0;',\n    '    }',\n\n         // Do modified alpha test.\n    '    if (alpha < alphaTest * MODIFIED_ALPHATEST) { discard; return; }',\n\n    '  #else',\n         // When we don't have derivatives, use approximations.\n    '    vec4 texColor = texture2D(map, vUV);',\n    '    float value = texColor.a;',\n         // FIXME: if we understood font pixel dimensions, this could probably be improved\n    '    float afwidth = (1.0 / 32.0) * (1.4142135623730951 / (2.0 * gl_FragCoord.w));',\n    '    float alpha = aastep(value, afwidth);',\n\n         // Use gl_FragCoord.w to guess when we should blend.\n         // FIXME: If we understood font pixel dimensions, this could probably be improved.\n    '    float ratio = (gl_FragCoord.w >= ALL_SMOOTH) ? 1.0 : (gl_FragCoord.w < ALL_ROUGH) ? 0.0 : (gl_FragCoord.w - ALL_ROUGH) / (ALL_SMOOTH - ALL_ROUGH);',\n    '    if (alpha < alphaTest) { if (ratio >= 1.0) { discard; return; } alpha = 0.0; }',\n    '    alpha = alpha * ratio + (1.0 - ratio) * value;',\n    '    if (ratio < 1.0 && alpha <= DISCARD_ALPHA) { discard; return; }',\n    '  #endif',\n\n    '  gl_FragColor = vec4(color, opacity * alpha);',\n    '}'\n  ].join('\\n')\n});\n"]},"metadata":{},"sourceType":"script"}