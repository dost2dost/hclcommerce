{"ast":null,"code":"/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a;\n\nimport { Model } from './model.js';\nconst $model = Symbol('model');\nconst $elementsByInternalId = Symbol('elementsByInternalId');\n/**\n * ModelGraft\n *\n * This is a coordination primitive between a scene graph as represented by the\n * output for Three.js' GLTFLoader and a counterpart 3DOM facade. Since this is\n * the Three.js-specific implementation of the facade, the input is a GLTF-like\n * object whose keys refer to Three.js-specific constructs (e.g., gltf.scene is\n * a THREE.Scene).\n *\n * When created, the ModelGraft produces a Model that can be traversed and\n * manipulated to mutate the Three.js scene graph synchronously (but\n * indirectly). The benefit of this is that mutations to the Three.js scene can\n * be performed in a Three.js-agnostic fashion that is potentially portable to\n * alternative rendering backends.\n *\n * The scene graph representation produced by the ModelGraft is designed to\n * match the structures described in the glTF 2.0 spec as closely as possible.\n * Where there are deviations, it is usually for the purpose of making\n * synchronization easier, or else for ergonomics. For example, in glTF 2.0, the\n * graph is a series of flat arrays where nodes cross-reference each other by\n * index to represent hierarchy, but in a Model nodes have array members\n * containing refrences to their hierarchical children.\n *\n * An important goal of ModelGraft is to enable a scene in one JavaScript\n * context to be manipulated by script in a remote context, such as a distant\n * worker thread or even a different process. So, every node in the graph\n * is able to be serialized, and the serialized form includes an ID that is\n * locally unique to the ModelGraft instance that the node came from so that\n * the remote context can refer back to it. A ModelGraft can be thought of as\n * the host execution context counterpart to the ModelKernel in the scene graph\n * execution context.\n */\n\nexport class ModelGraft extends EventTarget {\n  constructor(modelUri, gltf) {\n    super();\n    this[_a] = new Map();\n    this[$model] = new Model(this, modelUri, gltf);\n  }\n\n  get model() {\n    return this[$model];\n  }\n\n  getElementByInternalId(id) {\n    const element = this[$elementsByInternalId].get(id);\n\n    if (element == null) {\n      return null;\n    }\n\n    return element;\n  }\n\n  adopt(element) {\n    this[$elementsByInternalId].set(element.internalID, element);\n  }\n\n  async mutate(id, property, value) {\n    // TODO(#1005): Manipulations probably need to be validated against\n    // allowed capabilities here. We already do this on the scene graph\n    // execution context side, but it would be safer to do it on both sides\n    const element = this.getElementByInternalId(id);\n\n    if (element != null && property in element) {\n      element[property] = value;\n      this.dispatchEvent(new CustomEvent('mutation', {\n        detail: {\n          element: element\n        }\n      }));\n    }\n  }\n\n}\n_a = $elementsByInternalId;","map":{"version":3,"sources":["../../../src/facade/three-js/model-graft.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAmBA,SAAQ,KAAR,QAAoB,YAApB;AAGA,MAAM,MAAM,GAAG,MAAM,CAAC,OAAD,CAArB;AACA,MAAM,qBAAqB,GAAG,MAAM,CAAC,sBAAD,CAApC;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCA,OAAM,MAAO,UAAP,SAA0B,WAA1B,CAAqC;AAKzC,EAAA,WAAA,CAAY,QAAZ,EAA8B,IAA9B,EAAwC;AACtC;AAHK,SAAA,EAAA,IAA0B,IAAI,GAAJ,EAA1B;AAIL,SAAK,MAAL,IAAe,IAAI,KAAJ,CAAU,IAAV,EAAgB,QAAhB,EAA0B,IAA1B,CAAf;AACD;;AAED,MAAI,KAAJ,GAAS;AACP,WAAO,KAAK,MAAL,CAAP;AACD;;AAED,EAAA,sBAAsB,CAAC,EAAD,EAAW;AAC/B,UAAM,OAAO,GAAG,KAAK,qBAAL,EAA4B,GAA5B,CAAgC,EAAhC,CAAhB;;AAEA,QAAI,OAAO,IAAI,IAAf,EAAqB;AACnB,aAAO,IAAP;AACD;;AAED,WAAO,OAAP;AACD;;AAED,EAAA,KAAK,CAAC,OAAD,EAAyB;AAC5B,SAAK,qBAAL,EAA4B,GAA5B,CAAgC,OAAO,CAAC,UAAxC,EAAoD,OAApD;AACD;;AAED,QAAM,MAAN,CAAa,EAAb,EAAyB,QAAzB,EAA2C,KAA3C,EAAyD;AACvD;AACA;AACA;AACA,UAAM,OAAO,GAAG,KAAK,sBAAL,CAA4B,EAA5B,CAAhB;;AAEA,QAAI,OAAO,IAAI,IAAX,IAAmB,QAAQ,IAAI,OAAnC,EAA4C;AACzC,MAAA,OAAiD,CAAC,QAAD,CAAjD,GAA8D,KAA9D;AAED,WAAK,aAAL,CACI,IAAI,WAAJ,CAAgB,UAAhB,EAA4B;AAAC,QAAA,MAAM,EAAE;AAAC,UAAA,OAAO,EAAE;AAAV;AAAT,OAA5B,CADJ;AAED;AACF;;AAxCwC;KAGjC,qB","sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {GLTF} from 'three/examples/jsm/loaders/GLTFLoader.js';\n\nimport {ModelGraft as ModelGraftInterface} from '../api.js';\n\nimport {Model} from './model.js';\nimport {ThreeDOMElement} from './three-dom-element.js';\n\nconst $model = Symbol('model');\nconst $elementsByInternalId = Symbol('elementsByInternalId');\n\n/**\n * ModelGraft\n *\n * This is a coordination primitive between a scene graph as represented by the\n * output for Three.js' GLTFLoader and a counterpart 3DOM facade. Since this is\n * the Three.js-specific implementation of the facade, the input is a GLTF-like\n * object whose keys refer to Three.js-specific constructs (e.g., gltf.scene is\n * a THREE.Scene).\n *\n * When created, the ModelGraft produces a Model that can be traversed and\n * manipulated to mutate the Three.js scene graph synchronously (but\n * indirectly). The benefit of this is that mutations to the Three.js scene can\n * be performed in a Three.js-agnostic fashion that is potentially portable to\n * alternative rendering backends.\n *\n * The scene graph representation produced by the ModelGraft is designed to\n * match the structures described in the glTF 2.0 spec as closely as possible.\n * Where there are deviations, it is usually for the purpose of making\n * synchronization easier, or else for ergonomics. For example, in glTF 2.0, the\n * graph is a series of flat arrays where nodes cross-reference each other by\n * index to represent hierarchy, but in a Model nodes have array members\n * containing refrences to their hierarchical children.\n *\n * An important goal of ModelGraft is to enable a scene in one JavaScript\n * context to be manipulated by script in a remote context, such as a distant\n * worker thread or even a different process. So, every node in the graph\n * is able to be serialized, and the serialized form includes an ID that is\n * locally unique to the ModelGraft instance that the node came from so that\n * the remote context can refer back to it. A ModelGraft can be thought of as\n * the host execution context counterpart to the ModelKernel in the scene graph\n * execution context.\n */\nexport class ModelGraft extends EventTarget implements ModelGraftInterface {\n  private[$model]: Model;\n\n  private[$elementsByInternalId] = new Map<number, ThreeDOMElement>();\n\n  constructor(modelUri: string, gltf: GLTF) {\n    super();\n    this[$model] = new Model(this, modelUri, gltf);\n  }\n\n  get model() {\n    return this[$model];\n  }\n\n  getElementByInternalId(id: number): ThreeDOMElement|null {\n    const element = this[$elementsByInternalId].get(id);\n\n    if (element == null) {\n      return null;\n    }\n\n    return element;\n  }\n\n  adopt(element: ThreeDOMElement) {\n    this[$elementsByInternalId].set(element.internalID, element);\n  }\n\n  async mutate(id: number, property: string, value: unknown) {\n    // TODO(#1005): Manipulations probably need to be validated against\n    // allowed capabilities here. We already do this on the scene graph\n    // execution context side, but it would be safer to do it on both sides\n    const element = this.getElementByInternalId(id);\n\n    if (element != null && property in element) {\n      (element as unknown as {[index: string]: unknown})[property] = value;\n\n      this.dispatchEvent(\n          new CustomEvent('mutation', {detail: {element: element}}));\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}