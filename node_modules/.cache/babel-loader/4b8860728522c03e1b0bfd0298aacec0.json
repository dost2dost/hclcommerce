{"ast":null,"code":"/* global THREE */\nvar registerComponent = require('../core/component').registerComponent;\n\nvar bind = require('../utils/bind');\n\nvar trackedControlsUtils = require('../utils/tracked-controls');\n\nvar checkControllerPresentAndSetup = trackedControlsUtils.checkControllerPresentAndSetup;\nvar emitIfAxesChanged = trackedControlsUtils.emitIfAxesChanged;\nvar onButtonEvent = trackedControlsUtils.onButtonEvent;\n\nvar utils = require('../utils/');\n\nvar debug = utils.debug('components:windows-motion-controls:debug');\nvar warn = utils.debug('components:windows-motion-controls:warn');\n\nvar DEFAULT_HANDEDNESS = require('../constants').DEFAULT_HANDEDNESS;\n\nvar MODEL_BASE_URL = 'https://cdn.aframe.io/controllers/microsoft/';\nvar MODEL_FILENAMES = {\n  left: 'left.glb',\n  right: 'right.glb',\n  default: 'universal.glb'\n};\n\nvar isWebXRAvailable = require('../utils/').device.isWebXRAvailable;\n\nvar GAMEPAD_ID_WEBXR = 'windows-mixed-reality';\nvar GAMEPAD_ID_WEBVR = 'Spatial Controller (Spatial Interaction Source) ';\nvar GAMEPAD_ID_PATTERN = /([0-9a-zA-Z]+-[0-9a-zA-Z]+)$/;\nvar GAMEPAD_ID_PREFIX = isWebXRAvailable ? GAMEPAD_ID_WEBXR : GAMEPAD_ID_WEBVR;\nvar INPUT_MAPPING_WEBVR = {\n  // A-Frame specific semantic axis names\n  axes: {\n    'thumbstick': [0, 1],\n    'trackpad': [2, 3]\n  },\n  // A-Frame specific semantic button names\n  buttons: ['thumbstick', 'trigger', 'grip', 'menu', 'trackpad'],\n  // A mapping of the semantic name to node name in the glTF model file,\n  // that should be transformed by axis value.\n  // This array mirrors the browser Gamepad.axes array, such that\n  // the mesh corresponding to axis 0 is in this array index 0.\n  axisMeshNames: ['THUMBSTICK_X', 'THUMBSTICK_Y', 'TOUCHPAD_TOUCH_X', 'TOUCHPAD_TOUCH_Y'],\n  // A mapping of the semantic name to button node name in the glTF model file,\n  // that should be transformed by button value.\n  buttonMeshNames: {\n    'trigger': 'SELECT',\n    'menu': 'MENU',\n    'grip': 'GRASP',\n    'thumbstick': 'THUMBSTICK_PRESS',\n    'trackpad': 'TOUCHPAD_PRESS'\n  },\n  pointingPoseMeshName: 'POINTING_POSE'\n};\nvar INPUT_MAPPING_WEBXR = {\n  // A-Frame specific semantic axis names\n  axes: {\n    'touchpad': [0, 1],\n    'thumbstick': [2, 3]\n  },\n  // A-Frame specific semantic button names\n  buttons: ['trigger', 'squeeze', 'touchpad', 'thumbstick', 'menu'],\n  // A mapping of the semantic name to node name in the glTF model file,\n  // that should be transformed by axis value.\n  // This array mirrors the browser Gamepad.axes array, such that\n  // the mesh corresponding to axis 0 is in this array index 0.\n  axisMeshNames: ['TOUCHPAD_TOUCH_X', 'TOUCHPAD_TOUCH_X', 'THUMBSTICK_X', 'THUMBSTICK_Y'],\n  // A mapping of the semantic name to button node name in the glTF model file,\n  // that should be transformed by button value.\n  buttonMeshNames: {\n    'trigger': 'SELECT',\n    'menu': 'MENU',\n    'squeeze': 'GRASP',\n    'thumbstick': 'THUMBSTICK_PRESS',\n    'touchpad': 'TOUCHPAD_PRESS'\n  },\n  pointingPoseMeshName: 'POINTING_POSE'\n};\nvar INPUT_MAPPING = isWebXRAvailable ? INPUT_MAPPING_WEBXR : INPUT_MAPPING_WEBVR;\n/**\n * Windows Motion Controller controls.\n * Interface with Windows Motion Controller controllers and map Gamepad events to\n * controller buttons: trackpad, trigger, grip, menu, thumbstick\n * Load a controller model and transform the pressed buttons.\n */\n\nmodule.exports.Component = registerComponent('windows-motion-controls', {\n  schema: {\n    hand: {\n      default: DEFAULT_HANDEDNESS\n    },\n    // It is possible to have multiple pairs of controllers attached (a pair has both left and right).\n    // Set this to 1 to use a controller from the second pair, 2 from the third pair, etc.\n    pair: {\n      default: 0\n    },\n    // If true, loads the controller glTF asset.\n    model: {\n      default: true\n    },\n    // If true, will hide the model from the scene if no matching gamepad (based on ID & hand) is connected.\n    hideDisconnected: {\n      default: true\n    }\n  },\n  mapping: INPUT_MAPPING,\n  bindMethods: function () {\n    this.onModelError = bind(this.onModelError, this);\n    this.onModelLoaded = bind(this.onModelLoaded, this);\n    this.onControllersUpdate = bind(this.onControllersUpdate, this);\n    this.checkIfControllerPresent = bind(this.checkIfControllerPresent, this);\n    this.onAxisMoved = bind(this.onAxisMoved, this);\n  },\n  init: function () {\n    var self = this;\n    var el = this.el;\n    this.onButtonChanged = bind(this.onButtonChanged, this);\n\n    this.onButtonDown = function (evt) {\n      onButtonEvent(evt.detail.id, 'down', self);\n    };\n\n    this.onButtonUp = function (evt) {\n      onButtonEvent(evt.detail.id, 'up', self);\n    };\n\n    this.onButtonTouchStart = function (evt) {\n      onButtonEvent(evt.detail.id, 'touchstart', self);\n    };\n\n    this.onButtonTouchEnd = function (evt) {\n      onButtonEvent(evt.detail.id, 'touchend', self);\n    };\n\n    this.onControllerConnected = function () {\n      self.setModelVisibility(true);\n    };\n\n    this.onControllerDisconnected = function () {\n      self.setModelVisibility(false);\n    };\n\n    this.controllerPresent = false;\n    this.lastControllerCheck = 0;\n    this.previousButtonValues = {};\n    this.bindMethods(); // Cache for submeshes that we have looked up by name.\n\n    this.loadedMeshInfo = {\n      buttonMeshes: null,\n      axisMeshes: null\n    }; // Pointing poses\n\n    this.rayOrigin = {\n      origin: new THREE.Vector3(),\n      direction: new THREE.Vector3(0, 0, -1),\n      createdFromMesh: false\n    };\n    el.addEventListener('controllerconnected', this.onControllerConnected);\n    el.addEventListener('controllerdisconnected', this.onControllerDisconnected);\n  },\n  addEventListeners: function () {\n    var el = this.el;\n    el.addEventListener('buttonchanged', this.onButtonChanged);\n    el.addEventListener('buttondown', this.onButtonDown);\n    el.addEventListener('buttonup', this.onButtonUp);\n    el.addEventListener('touchstart', this.onButtonTouchStart);\n    el.addEventListener('touchend', this.onButtonTouchEnd);\n    el.addEventListener('axismove', this.onAxisMoved);\n    el.addEventListener('model-error', this.onModelError);\n    el.addEventListener('model-loaded', this.onModelLoaded);\n    this.controllerEventsActive = true;\n  },\n  removeEventListeners: function () {\n    var el = this.el;\n    el.removeEventListener('buttonchanged', this.onButtonChanged);\n    el.removeEventListener('buttondown', this.onButtonDown);\n    el.removeEventListener('buttonup', this.onButtonUp);\n    el.removeEventListener('touchstart', this.onButtonTouchStart);\n    el.removeEventListener('touchend', this.onButtonTouchEnd);\n    el.removeEventListener('axismove', this.onAxisMoved);\n    el.removeEventListener('model-error', this.onModelError);\n    el.removeEventListener('model-loaded', this.onModelLoaded);\n    this.controllerEventsActive = false;\n  },\n  checkIfControllerPresent: function () {\n    checkControllerPresentAndSetup(this, GAMEPAD_ID_PREFIX, {\n      hand: this.data.hand,\n      index: this.data.pair\n    });\n  },\n  play: function () {\n    this.checkIfControllerPresent();\n    this.addControllersUpdateListener();\n  },\n  pause: function () {\n    this.removeEventListeners();\n    this.removeControllersUpdateListener();\n  },\n  updateControllerModel: function () {\n    // If we do not want to load a model, or, have already loaded the model, emit the controllermodelready event.\n    if (!this.data.model || this.rayOrigin.createdFromMesh) {\n      this.modelReady();\n      return;\n    }\n\n    var sourceUrl = this.createControllerModelUrl();\n    this.loadModel(sourceUrl);\n  },\n\n  /**\n   * Helper function that constructs a URL from the controller ID suffix, for future proofed\n   * art assets.\n   */\n  createControllerModelUrl: function (forceDefault) {\n    // Determine the device specific folder based on the ID suffix\n    var trackedControlsComponent = this.el.components['tracked-controls'];\n    var controller = trackedControlsComponent ? trackedControlsComponent.controller : null;\n    var device = 'default';\n    var hand = this.data.hand;\n    var filename;\n\n    if (controller && !window.hasNativeWebXRImplementation) {\n      // Read hand directly from the controller, rather than this.data, as in the case that the controller\n      // is unhanded this.data will still have 'left' or 'right' (depending on what the user inserted in to the scene).\n      // In this case, we want to load the universal model, so need to get the '' from the controller.\n      hand = controller.hand;\n\n      if (!forceDefault) {\n        var match = controller.id.match(GAMEPAD_ID_PATTERN);\n        device = match && match[0] || device;\n      }\n    } // Hand\n\n\n    filename = MODEL_FILENAMES[hand] || MODEL_FILENAMES.default; // Final url\n\n    return MODEL_BASE_URL + device + '/' + filename;\n  },\n  injectTrackedControls: function () {\n    var data = this.data;\n    this.el.setAttribute('tracked-controls', {\n      idPrefix: GAMEPAD_ID_PREFIX,\n      controller: data.pair,\n      hand: data.hand,\n      armModel: false\n    });\n    this.updateControllerModel();\n  },\n  addControllersUpdateListener: function () {\n    this.el.sceneEl.addEventListener('controllersupdated', this.onControllersUpdate, false);\n  },\n  removeControllersUpdateListener: function () {\n    this.el.sceneEl.removeEventListener('controllersupdated', this.onControllersUpdate, false);\n  },\n  onControllersUpdate: function () {\n    this.checkIfControllerPresent();\n  },\n  onModelError: function (evt) {\n    var defaultUrl = this.createControllerModelUrl(true);\n\n    if (evt.detail.src !== defaultUrl) {\n      warn('Failed to load controller model for device, attempting to load default.');\n      this.loadModel(defaultUrl);\n    } else {\n      warn('Failed to load default controller model.');\n    }\n  },\n  loadModel: function (url) {\n    // The model is loaded by the gltf-model compoent when this attribute is initially set,\n    // removed and re-loaded if the given url changes.\n    this.el.setAttribute('gltf-model', 'url(' + url + ')');\n  },\n  onModelLoaded: function (evt) {\n    var rootNode = this.controllerModel = evt.detail.model;\n    var loadedMeshInfo = this.loadedMeshInfo;\n    var i;\n    var meshName;\n    var mesh;\n    var meshInfo;\n    debug('Processing model'); // Reset the caches\n\n    loadedMeshInfo.buttonMeshes = {};\n    loadedMeshInfo.axisMeshes = {}; // Cache our meshes so we aren't traversing the hierarchy per frame\n\n    if (rootNode) {\n      // Button Meshes\n      for (i = 0; i < this.mapping.buttons.length; i++) {\n        meshName = this.mapping.buttonMeshNames[this.mapping.buttons[i]];\n\n        if (!meshName) {\n          debug('Skipping unknown button at index: ' + i + ' with mapped name: ' + this.mapping.buttons[i]);\n          continue;\n        }\n\n        mesh = rootNode.getObjectByName(meshName);\n\n        if (!mesh) {\n          warn('Missing button mesh with name: ' + meshName);\n          continue;\n        }\n\n        meshInfo = {\n          index: i,\n          value: getImmediateChildByName(mesh, 'VALUE'),\n          pressed: getImmediateChildByName(mesh, 'PRESSED'),\n          unpressed: getImmediateChildByName(mesh, 'UNPRESSED')\n        };\n\n        if (meshInfo.value && meshInfo.pressed && meshInfo.unpressed) {\n          loadedMeshInfo.buttonMeshes[this.mapping.buttons[i]] = meshInfo;\n        } else {\n          // If we didn't find the mesh, it simply means this button won't have transforms applied as mapped button value changes.\n          warn('Missing button submesh under mesh with name: ' + meshName + '(VALUE: ' + !!meshInfo.value + ', PRESSED: ' + !!meshInfo.pressed + ', UNPRESSED:' + !!meshInfo.unpressed + ')');\n        }\n      } // Axis Meshes\n\n\n      for (i = 0; i < this.mapping.axisMeshNames.length; i++) {\n        meshName = this.mapping.axisMeshNames[i];\n\n        if (!meshName) {\n          debug('Skipping unknown axis at index: ' + i);\n          continue;\n        }\n\n        mesh = rootNode.getObjectByName(meshName);\n\n        if (!mesh) {\n          warn('Missing axis mesh with name: ' + meshName);\n          continue;\n        }\n\n        meshInfo = {\n          index: i,\n          value: getImmediateChildByName(mesh, 'VALUE'),\n          min: getImmediateChildByName(mesh, 'MIN'),\n          max: getImmediateChildByName(mesh, 'MAX')\n        };\n\n        if (meshInfo.value && meshInfo.min && meshInfo.max) {\n          loadedMeshInfo.axisMeshes[i] = meshInfo;\n        } else {\n          // If we didn't find the mesh, it simply means this axis won't have transforms applied as mapped axis values change.\n          warn('Missing axis submesh under mesh with name: ' + meshName + '(VALUE: ' + !!meshInfo.value + ', MIN: ' + !!meshInfo.min + ', MAX:' + !!meshInfo.max + ')');\n        }\n      }\n\n      this.calculateRayOriginFromMesh(rootNode); // Determine if the model has to be visible or not.\n\n      this.setModelVisibility();\n    }\n\n    debug('Model load complete.'); // Look through only immediate children. This will return null if no mesh exists with the given name.\n\n    function getImmediateChildByName(object3d, value) {\n      for (var i = 0, l = object3d.children.length; i < l; i++) {\n        var obj = object3d.children[i];\n\n        if (obj && obj['name'] === value) {\n          return obj;\n        }\n      }\n\n      return undefined;\n    }\n  },\n  calculateRayOriginFromMesh: function () {\n    var quaternion = new THREE.Quaternion();\n    return function (rootNode) {\n      var mesh; // Calculate the pointer pose (used for rays), by applying the world transform of th POINTER_POSE node\n      // in the glTF (assumes that root node is at world origin)\n\n      this.rayOrigin.origin.set(0, 0, 0);\n      this.rayOrigin.direction.set(0, 0, -1);\n      this.rayOrigin.createdFromMesh = true; // Try to read Pointing pose from the source model\n\n      mesh = rootNode.getObjectByName(this.mapping.pointingPoseMeshName);\n\n      if (mesh) {\n        var parent = rootNode.parent; // We need to read pose transforms accumulated from the root of the glTF, not the scene.\n\n        if (parent) {\n          rootNode.parent = null;\n          rootNode.updateMatrixWorld(true);\n          rootNode.parent = parent;\n        }\n\n        mesh.getWorldPosition(this.rayOrigin.origin);\n        mesh.getWorldQuaternion(quaternion);\n        this.rayOrigin.direction.applyQuaternion(quaternion); // Recalculate the world matrices now that the rootNode is re-attached to the parent.\n\n        if (parent) {\n          rootNode.updateMatrixWorld(true);\n        }\n      } else {\n        debug('Mesh does not contain pointing origin data, defaulting to none.');\n      } // Emit event stating that our pointing ray is now accurate.\n\n\n      this.modelReady();\n    };\n  }(),\n  lerpAxisTransform: function () {\n    var quaternion = new THREE.Quaternion();\n    return function (axis, axisValue) {\n      var axisMeshInfo = this.loadedMeshInfo.axisMeshes[axis];\n      if (!axisMeshInfo) return;\n      var min = axisMeshInfo.min;\n      var max = axisMeshInfo.max;\n      var target = axisMeshInfo.value; // Convert from gamepad value range (-1 to +1) to lerp range (0 to 1)\n\n      var lerpValue = axisValue * 0.5 + 0.5;\n      target.setRotationFromQuaternion(quaternion.copy(min.quaternion).slerp(max.quaternion, lerpValue));\n      target.position.lerpVectors(min.position, max.position, lerpValue);\n    };\n  }(),\n  lerpButtonTransform: function () {\n    var quaternion = new THREE.Quaternion();\n    return function (buttonName, buttonValue) {\n      var buttonMeshInfo = this.loadedMeshInfo.buttonMeshes[buttonName];\n      if (!buttonMeshInfo) return;\n      var min = buttonMeshInfo.unpressed;\n      var max = buttonMeshInfo.pressed;\n      var target = buttonMeshInfo.value;\n      target.setRotationFromQuaternion(quaternion.copy(min.quaternion).slerp(max.quaternion, buttonValue));\n      target.position.lerpVectors(min.position, max.position, buttonValue);\n    };\n  }(),\n  modelReady: function () {\n    this.el.emit('controllermodelready', {\n      name: 'windows-motion-controls',\n      model: this.data.model,\n      rayOrigin: this.rayOrigin\n    });\n  },\n  onButtonChanged: function (evt) {\n    var buttonName = this.mapping.buttons[evt.detail.id];\n\n    if (buttonName) {\n      // Update the button mesh transform\n      if (this.loadedMeshInfo && this.loadedMeshInfo.buttonMeshes) {\n        this.lerpButtonTransform(buttonName, evt.detail.state.value);\n      } // Only emit events for buttons that we know how to map from index to name\n\n\n      this.el.emit(buttonName + 'changed', evt.detail.state);\n    }\n  },\n  onAxisMoved: function (evt) {\n    var numAxes = this.mapping.axisMeshNames.length; // Only attempt to update meshes if we have valid data.\n\n    if (this.loadedMeshInfo && this.loadedMeshInfo.axisMeshes) {\n      for (var axis = 0; axis < numAxes; axis++) {\n        // Update the button mesh transform\n        this.lerpAxisTransform(axis, evt.detail.axis[axis] || 0.0);\n      }\n    }\n\n    emitIfAxesChanged(this, this.mapping.axes, evt);\n  },\n  setModelVisibility: function (visible) {\n    var model = this.el.getObject3D('mesh');\n    visible = visible !== undefined ? visible : this.modelVisible;\n    this.modelVisible = visible;\n\n    if (!model) {\n      return;\n    }\n\n    model.visible = visible;\n  }\n});","map":{"version":3,"sources":["C:/Users/Hannuri/Desktop/RoyalCyber/my-first-app/node_modules/aframe/src/components/windows-motion-controls.js"],"names":["registerComponent","require","bind","trackedControlsUtils","checkControllerPresentAndSetup","emitIfAxesChanged","onButtonEvent","utils","debug","warn","DEFAULT_HANDEDNESS","MODEL_BASE_URL","MODEL_FILENAMES","left","right","default","isWebXRAvailable","device","GAMEPAD_ID_WEBXR","GAMEPAD_ID_WEBVR","GAMEPAD_ID_PATTERN","GAMEPAD_ID_PREFIX","INPUT_MAPPING_WEBVR","axes","buttons","axisMeshNames","buttonMeshNames","pointingPoseMeshName","INPUT_MAPPING_WEBXR","INPUT_MAPPING","module","exports","Component","schema","hand","pair","model","hideDisconnected","mapping","bindMethods","onModelError","onModelLoaded","onControllersUpdate","checkIfControllerPresent","onAxisMoved","init","self","el","onButtonChanged","onButtonDown","evt","detail","id","onButtonUp","onButtonTouchStart","onButtonTouchEnd","onControllerConnected","setModelVisibility","onControllerDisconnected","controllerPresent","lastControllerCheck","previousButtonValues","loadedMeshInfo","buttonMeshes","axisMeshes","rayOrigin","origin","THREE","Vector3","direction","createdFromMesh","addEventListener","addEventListeners","controllerEventsActive","removeEventListeners","removeEventListener","data","index","play","addControllersUpdateListener","pause","removeControllersUpdateListener","updateControllerModel","modelReady","sourceUrl","createControllerModelUrl","loadModel","forceDefault","trackedControlsComponent","components","controller","filename","window","hasNativeWebXRImplementation","match","injectTrackedControls","setAttribute","idPrefix","armModel","sceneEl","defaultUrl","src","url","rootNode","controllerModel","i","meshName","mesh","meshInfo","length","getObjectByName","value","getImmediateChildByName","pressed","unpressed","min","max","calculateRayOriginFromMesh","object3d","l","children","obj","undefined","quaternion","Quaternion","set","parent","updateMatrixWorld","getWorldPosition","getWorldQuaternion","applyQuaternion","lerpAxisTransform","axis","axisValue","axisMeshInfo","target","lerpValue","setRotationFromQuaternion","copy","slerp","position","lerpVectors","lerpButtonTransform","buttonName","buttonValue","buttonMeshInfo","emit","name","state","numAxes","visible","getObject3D","modelVisible"],"mappings":"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","sourcesContent":["/* global THREE */\nvar registerComponent = require('../core/component').registerComponent;\nvar bind = require('../utils/bind');\n\nvar trackedControlsUtils = require('../utils/tracked-controls');\nvar checkControllerPresentAndSetup = trackedControlsUtils.checkControllerPresentAndSetup;\nvar emitIfAxesChanged = trackedControlsUtils.emitIfAxesChanged;\nvar onButtonEvent = trackedControlsUtils.onButtonEvent;\n\nvar utils = require('../utils/');\n\nvar debug = utils.debug('components:windows-motion-controls:debug');\nvar warn = utils.debug('components:windows-motion-controls:warn');\n\nvar DEFAULT_HANDEDNESS = require('../constants').DEFAULT_HANDEDNESS;\n\nvar MODEL_BASE_URL = 'https://cdn.aframe.io/controllers/microsoft/';\nvar MODEL_FILENAMES = { left: 'left.glb', right: 'right.glb', default: 'universal.glb' };\n\nvar isWebXRAvailable = require('../utils/').device.isWebXRAvailable;\n\nvar GAMEPAD_ID_WEBXR = 'windows-mixed-reality';\nvar GAMEPAD_ID_WEBVR = 'Spatial Controller (Spatial Interaction Source) ';\nvar GAMEPAD_ID_PATTERN = /([0-9a-zA-Z]+-[0-9a-zA-Z]+)$/;\n\nvar GAMEPAD_ID_PREFIX = isWebXRAvailable ? GAMEPAD_ID_WEBXR : GAMEPAD_ID_WEBVR;\n\nvar INPUT_MAPPING_WEBVR = {\n  // A-Frame specific semantic axis names\n  axes: {'thumbstick': [0, 1], 'trackpad': [2, 3]},\n  // A-Frame specific semantic button names\n  buttons: ['thumbstick', 'trigger', 'grip', 'menu', 'trackpad'],\n  // A mapping of the semantic name to node name in the glTF model file,\n  // that should be transformed by axis value.\n  // This array mirrors the browser Gamepad.axes array, such that\n  // the mesh corresponding to axis 0 is in this array index 0.\n  axisMeshNames: [\n    'THUMBSTICK_X',\n    'THUMBSTICK_Y',\n    'TOUCHPAD_TOUCH_X',\n    'TOUCHPAD_TOUCH_Y'\n  ],\n  // A mapping of the semantic name to button node name in the glTF model file,\n  // that should be transformed by button value.\n  buttonMeshNames: {\n    'trigger': 'SELECT',\n    'menu': 'MENU',\n    'grip': 'GRASP',\n    'thumbstick': 'THUMBSTICK_PRESS',\n    'trackpad': 'TOUCHPAD_PRESS'\n  },\n  pointingPoseMeshName: 'POINTING_POSE'\n};\n\nvar INPUT_MAPPING_WEBXR = {\n  // A-Frame specific semantic axis names\n  axes: {'touchpad': [0, 1], 'thumbstick': [2, 3]},\n  // A-Frame specific semantic button names\n  buttons: ['trigger', 'squeeze', 'touchpad', 'thumbstick', 'menu'],\n  // A mapping of the semantic name to node name in the glTF model file,\n  // that should be transformed by axis value.\n  // This array mirrors the browser Gamepad.axes array, such that\n  // the mesh corresponding to axis 0 is in this array index 0.\n  axisMeshNames: [\n    'TOUCHPAD_TOUCH_X',\n    'TOUCHPAD_TOUCH_X',\n    'THUMBSTICK_X',\n    'THUMBSTICK_Y'\n  ],\n  // A mapping of the semantic name to button node name in the glTF model file,\n  // that should be transformed by button value.\n  buttonMeshNames: {\n    'trigger': 'SELECT',\n    'menu': 'MENU',\n    'squeeze': 'GRASP',\n    'thumbstick': 'THUMBSTICK_PRESS',\n    'touchpad': 'TOUCHPAD_PRESS'\n  },\n  pointingPoseMeshName: 'POINTING_POSE'\n};\n\nvar INPUT_MAPPING = isWebXRAvailable ? INPUT_MAPPING_WEBXR : INPUT_MAPPING_WEBVR;\n\n/**\n * Windows Motion Controller controls.\n * Interface with Windows Motion Controller controllers and map Gamepad events to\n * controller buttons: trackpad, trigger, grip, menu, thumbstick\n * Load a controller model and transform the pressed buttons.\n */\nmodule.exports.Component = registerComponent('windows-motion-controls', {\n  schema: {\n    hand: {default: DEFAULT_HANDEDNESS},\n    // It is possible to have multiple pairs of controllers attached (a pair has both left and right).\n    // Set this to 1 to use a controller from the second pair, 2 from the third pair, etc.\n    pair: {default: 0},\n    // If true, loads the controller glTF asset.\n    model: {default: true},\n    // If true, will hide the model from the scene if no matching gamepad (based on ID & hand) is connected.\n    hideDisconnected: {default: true}\n  },\n\n  mapping: INPUT_MAPPING,\n\n  bindMethods: function () {\n    this.onModelError = bind(this.onModelError, this);\n    this.onModelLoaded = bind(this.onModelLoaded, this);\n    this.onControllersUpdate = bind(this.onControllersUpdate, this);\n    this.checkIfControllerPresent = bind(this.checkIfControllerPresent, this);\n    this.onAxisMoved = bind(this.onAxisMoved, this);\n  },\n\n  init: function () {\n    var self = this;\n    var el = this.el;\n    this.onButtonChanged = bind(this.onButtonChanged, this);\n    this.onButtonDown = function (evt) { onButtonEvent(evt.detail.id, 'down', self); };\n    this.onButtonUp = function (evt) { onButtonEvent(evt.detail.id, 'up', self); };\n    this.onButtonTouchStart = function (evt) { onButtonEvent(evt.detail.id, 'touchstart', self); };\n    this.onButtonTouchEnd = function (evt) { onButtonEvent(evt.detail.id, 'touchend', self); };\n    this.onControllerConnected = function () { self.setModelVisibility(true); };\n    this.onControllerDisconnected = function () { self.setModelVisibility(false); };\n    this.controllerPresent = false;\n    this.lastControllerCheck = 0;\n    this.previousButtonValues = {};\n    this.bindMethods();\n\n    // Cache for submeshes that we have looked up by name.\n    this.loadedMeshInfo = {\n      buttonMeshes: null,\n      axisMeshes: null\n    };\n\n    // Pointing poses\n    this.rayOrigin = {\n      origin: new THREE.Vector3(),\n      direction: new THREE.Vector3(0, 0, -1),\n      createdFromMesh: false\n    };\n\n    el.addEventListener('controllerconnected', this.onControllerConnected);\n    el.addEventListener('controllerdisconnected', this.onControllerDisconnected);\n  },\n\n  addEventListeners: function () {\n    var el = this.el;\n    el.addEventListener('buttonchanged', this.onButtonChanged);\n    el.addEventListener('buttondown', this.onButtonDown);\n    el.addEventListener('buttonup', this.onButtonUp);\n    el.addEventListener('touchstart', this.onButtonTouchStart);\n    el.addEventListener('touchend', this.onButtonTouchEnd);\n    el.addEventListener('axismove', this.onAxisMoved);\n    el.addEventListener('model-error', this.onModelError);\n    el.addEventListener('model-loaded', this.onModelLoaded);\n    this.controllerEventsActive = true;\n  },\n\n  removeEventListeners: function () {\n    var el = this.el;\n    el.removeEventListener('buttonchanged', this.onButtonChanged);\n    el.removeEventListener('buttondown', this.onButtonDown);\n    el.removeEventListener('buttonup', this.onButtonUp);\n    el.removeEventListener('touchstart', this.onButtonTouchStart);\n    el.removeEventListener('touchend', this.onButtonTouchEnd);\n    el.removeEventListener('axismove', this.onAxisMoved);\n    el.removeEventListener('model-error', this.onModelError);\n    el.removeEventListener('model-loaded', this.onModelLoaded);\n    this.controllerEventsActive = false;\n  },\n\n  checkIfControllerPresent: function () {\n    checkControllerPresentAndSetup(this, GAMEPAD_ID_PREFIX, {\n      hand: this.data.hand,\n      index: this.data.pair\n    });\n  },\n\n  play: function () {\n    this.checkIfControllerPresent();\n    this.addControllersUpdateListener();\n  },\n\n  pause: function () {\n    this.removeEventListeners();\n    this.removeControllersUpdateListener();\n  },\n\n  updateControllerModel: function () {\n    // If we do not want to load a model, or, have already loaded the model, emit the controllermodelready event.\n    if (!this.data.model || this.rayOrigin.createdFromMesh) {\n      this.modelReady();\n      return;\n    }\n\n    var sourceUrl = this.createControllerModelUrl();\n    this.loadModel(sourceUrl);\n  },\n\n  /**\n   * Helper function that constructs a URL from the controller ID suffix, for future proofed\n   * art assets.\n   */\n  createControllerModelUrl: function (forceDefault) {\n    // Determine the device specific folder based on the ID suffix\n    var trackedControlsComponent = this.el.components['tracked-controls'];\n    var controller = trackedControlsComponent ? trackedControlsComponent.controller : null;\n    var device = 'default';\n    var hand = this.data.hand;\n    var filename;\n\n    if (controller && !window.hasNativeWebXRImplementation) {\n      // Read hand directly from the controller, rather than this.data, as in the case that the controller\n      // is unhanded this.data will still have 'left' or 'right' (depending on what the user inserted in to the scene).\n      // In this case, we want to load the universal model, so need to get the '' from the controller.\n      hand = controller.hand;\n\n      if (!forceDefault) {\n        var match = controller.id.match(GAMEPAD_ID_PATTERN);\n        device = ((match && match[0]) || device);\n      }\n    }\n\n    // Hand\n    filename = MODEL_FILENAMES[hand] || MODEL_FILENAMES.default;\n\n    // Final url\n    return MODEL_BASE_URL + device + '/' + filename;\n  },\n\n  injectTrackedControls: function () {\n    var data = this.data;\n    this.el.setAttribute('tracked-controls', {\n      idPrefix: GAMEPAD_ID_PREFIX,\n      controller: data.pair,\n      hand: data.hand,\n      armModel: false\n    });\n\n    this.updateControllerModel();\n  },\n\n  addControllersUpdateListener: function () {\n    this.el.sceneEl.addEventListener('controllersupdated', this.onControllersUpdate, false);\n  },\n\n  removeControllersUpdateListener: function () {\n    this.el.sceneEl.removeEventListener('controllersupdated', this.onControllersUpdate, false);\n  },\n\n  onControllersUpdate: function () {\n    this.checkIfControllerPresent();\n  },\n\n  onModelError: function (evt) {\n    var defaultUrl = this.createControllerModelUrl(true);\n    if (evt.detail.src !== defaultUrl) {\n      warn('Failed to load controller model for device, attempting to load default.');\n      this.loadModel(defaultUrl);\n    } else {\n      warn('Failed to load default controller model.');\n    }\n  },\n\n  loadModel: function (url) {\n    // The model is loaded by the gltf-model compoent when this attribute is initially set,\n    // removed and re-loaded if the given url changes.\n    this.el.setAttribute('gltf-model', 'url(' + url + ')');\n  },\n\n  onModelLoaded: function (evt) {\n    var rootNode = this.controllerModel = evt.detail.model;\n    var loadedMeshInfo = this.loadedMeshInfo;\n    var i;\n    var meshName;\n    var mesh;\n    var meshInfo;\n\n    debug('Processing model');\n\n    // Reset the caches\n    loadedMeshInfo.buttonMeshes = {};\n    loadedMeshInfo.axisMeshes = {};\n\n    // Cache our meshes so we aren't traversing the hierarchy per frame\n    if (rootNode) {\n      // Button Meshes\n      for (i = 0; i < this.mapping.buttons.length; i++) {\n        meshName = this.mapping.buttonMeshNames[this.mapping.buttons[i]];\n        if (!meshName) {\n          debug('Skipping unknown button at index: ' + i + ' with mapped name: ' + this.mapping.buttons[i]);\n          continue;\n        }\n\n        mesh = rootNode.getObjectByName(meshName);\n        if (!mesh) {\n          warn('Missing button mesh with name: ' + meshName);\n          continue;\n        }\n\n        meshInfo = {\n          index: i,\n          value: getImmediateChildByName(mesh, 'VALUE'),\n          pressed: getImmediateChildByName(mesh, 'PRESSED'),\n          unpressed: getImmediateChildByName(mesh, 'UNPRESSED')\n        };\n        if (meshInfo.value && meshInfo.pressed && meshInfo.unpressed) {\n          loadedMeshInfo.buttonMeshes[this.mapping.buttons[i]] = meshInfo;\n        } else {\n          // If we didn't find the mesh, it simply means this button won't have transforms applied as mapped button value changes.\n          warn('Missing button submesh under mesh with name: ' + meshName +\n            '(VALUE: ' + !!meshInfo.value +\n            ', PRESSED: ' + !!meshInfo.pressed +\n            ', UNPRESSED:' + !!meshInfo.unpressed +\n            ')');\n        }\n      }\n\n      // Axis Meshes\n      for (i = 0; i < this.mapping.axisMeshNames.length; i++) {\n        meshName = this.mapping.axisMeshNames[i];\n        if (!meshName) {\n          debug('Skipping unknown axis at index: ' + i);\n          continue;\n        }\n\n        mesh = rootNode.getObjectByName(meshName);\n        if (!mesh) {\n          warn('Missing axis mesh with name: ' + meshName);\n          continue;\n        }\n\n        meshInfo = {\n          index: i,\n          value: getImmediateChildByName(mesh, 'VALUE'),\n          min: getImmediateChildByName(mesh, 'MIN'),\n          max: getImmediateChildByName(mesh, 'MAX')\n        };\n        if (meshInfo.value && meshInfo.min && meshInfo.max) {\n          loadedMeshInfo.axisMeshes[i] = meshInfo;\n        } else {\n          // If we didn't find the mesh, it simply means this axis won't have transforms applied as mapped axis values change.\n          warn('Missing axis submesh under mesh with name: ' + meshName +\n            '(VALUE: ' + !!meshInfo.value +\n            ', MIN: ' + !!meshInfo.min +\n            ', MAX:' + !!meshInfo.max +\n            ')');\n        }\n      }\n\n      this.calculateRayOriginFromMesh(rootNode);\n      // Determine if the model has to be visible or not.\n      this.setModelVisibility();\n    }\n\n    debug('Model load complete.');\n\n    // Look through only immediate children. This will return null if no mesh exists with the given name.\n    function getImmediateChildByName (object3d, value) {\n      for (var i = 0, l = object3d.children.length; i < l; i++) {\n        var obj = object3d.children[i];\n        if (obj && obj['name'] === value) {\n          return obj;\n        }\n      }\n      return undefined;\n    }\n  },\n\n  calculateRayOriginFromMesh: (function () {\n    var quaternion = new THREE.Quaternion();\n    return function (rootNode) {\n      var mesh;\n\n      // Calculate the pointer pose (used for rays), by applying the world transform of th POINTER_POSE node\n      // in the glTF (assumes that root node is at world origin)\n      this.rayOrigin.origin.set(0, 0, 0);\n      this.rayOrigin.direction.set(0, 0, -1);\n      this.rayOrigin.createdFromMesh = true;\n\n      // Try to read Pointing pose from the source model\n      mesh = rootNode.getObjectByName(this.mapping.pointingPoseMeshName);\n      if (mesh) {\n        var parent = rootNode.parent;\n\n        // We need to read pose transforms accumulated from the root of the glTF, not the scene.\n        if (parent) {\n          rootNode.parent = null;\n          rootNode.updateMatrixWorld(true);\n          rootNode.parent = parent;\n        }\n\n        mesh.getWorldPosition(this.rayOrigin.origin);\n        mesh.getWorldQuaternion(quaternion);\n        this.rayOrigin.direction.applyQuaternion(quaternion);\n\n        // Recalculate the world matrices now that the rootNode is re-attached to the parent.\n        if (parent) {\n          rootNode.updateMatrixWorld(true);\n        }\n      } else {\n        debug('Mesh does not contain pointing origin data, defaulting to none.');\n      }\n\n      // Emit event stating that our pointing ray is now accurate.\n      this.modelReady();\n    };\n  })(),\n\n  lerpAxisTransform: (function () {\n    var quaternion = new THREE.Quaternion();\n    return function (axis, axisValue) {\n      var axisMeshInfo = this.loadedMeshInfo.axisMeshes[axis];\n      if (!axisMeshInfo) return;\n\n      var min = axisMeshInfo.min;\n      var max = axisMeshInfo.max;\n      var target = axisMeshInfo.value;\n\n      // Convert from gamepad value range (-1 to +1) to lerp range (0 to 1)\n      var lerpValue = axisValue * 0.5 + 0.5;\n      target.setRotationFromQuaternion(quaternion.copy(min.quaternion).slerp(max.quaternion, lerpValue));\n      target.position.lerpVectors(min.position, max.position, lerpValue);\n    };\n  })(),\n\n  lerpButtonTransform: (function () {\n    var quaternion = new THREE.Quaternion();\n    return function (buttonName, buttonValue) {\n      var buttonMeshInfo = this.loadedMeshInfo.buttonMeshes[buttonName];\n      if (!buttonMeshInfo) return;\n\n      var min = buttonMeshInfo.unpressed;\n      var max = buttonMeshInfo.pressed;\n      var target = buttonMeshInfo.value;\n\n      target.setRotationFromQuaternion(quaternion.copy(min.quaternion).slerp(max.quaternion, buttonValue));\n      target.position.lerpVectors(min.position, max.position, buttonValue);\n    };\n  })(),\n\n  modelReady: function () {\n    this.el.emit('controllermodelready', {\n      name: 'windows-motion-controls',\n      model: this.data.model,\n      rayOrigin: this.rayOrigin\n    });\n  },\n\n  onButtonChanged: function (evt) {\n    var buttonName = this.mapping.buttons[evt.detail.id];\n\n    if (buttonName) {\n      // Update the button mesh transform\n      if (this.loadedMeshInfo && this.loadedMeshInfo.buttonMeshes) {\n        this.lerpButtonTransform(buttonName, evt.detail.state.value);\n      }\n\n      // Only emit events for buttons that we know how to map from index to name\n      this.el.emit(buttonName + 'changed', evt.detail.state);\n    }\n  },\n\n  onAxisMoved: function (evt) {\n    var numAxes = this.mapping.axisMeshNames.length;\n\n    // Only attempt to update meshes if we have valid data.\n    if (this.loadedMeshInfo && this.loadedMeshInfo.axisMeshes) {\n      for (var axis = 0; axis < numAxes; axis++) {\n        // Update the button mesh transform\n        this.lerpAxisTransform(axis, evt.detail.axis[axis] || 0.0);\n      }\n    }\n\n    emitIfAxesChanged(this, this.mapping.axes, evt);\n  },\n\n  setModelVisibility: function (visible) {\n    var model = this.el.getObject3D('mesh');\n    visible = visible !== undefined ? visible : this.modelVisible;\n    this.modelVisible = visible;\n    if (!model) { return; }\n    model.visible = visible;\n  }\n});\n"]},"metadata":{},"sourceType":"script"}