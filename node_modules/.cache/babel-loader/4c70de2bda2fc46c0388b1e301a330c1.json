{"ast":null,"code":"/* global MutationObserver */\nvar registerComponent = require('../core/component').registerComponent;\n\nvar THREE = require('../lib/three');\n\nvar utils = require('../utils/');\n\nvar warn = utils.debug('components:raycaster:warn'); // Defines selectors that should be 'safe' for the MutationObserver used to\n// refresh the whitelist. Matches classnames, IDs, and presence of attributes.\n// Selectors for the value of an attribute, like [position=0 2 0], cannot be\n// reliably detected and are therefore disallowed.\n\nvar OBSERVER_SELECTOR_RE = /^[\\w\\s-.,[\\]#]*$/; // Configuration for the MutationObserver used to refresh the whitelist.\n// Listens for addition/removal of elements and attributes within the scene.\n\nvar OBSERVER_CONFIG = {\n  childList: true,\n  attributes: true,\n  subtree: true\n};\nvar EVENTS = {\n  INTERSECT: 'raycaster-intersected',\n  INTERSECTION: 'raycaster-intersection',\n  INTERSECT_CLEAR: 'raycaster-intersected-cleared',\n  INTERSECTION_CLEAR: 'raycaster-intersection-cleared'\n};\n/**\n * Raycaster component.\n *\n * Pass options to three.js Raycaster including which objects to test.\n * Poll for intersections.\n * Emit event on origin entity and on target entity on intersect.\n *\n * @member {array} intersectedEls - List of currently intersected entities.\n * @member {array} objects - Cached list of meshes to intersect.\n * @member {number} prevCheckTime - Previous time intersection was checked. To help interval.\n * @member {object} raycaster - three.js Raycaster.\n */\n\nmodule.exports.Component = registerComponent('raycaster', {\n  schema: {\n    autoRefresh: {\n      default: true\n    },\n    direction: {\n      type: 'vec3',\n      default: {\n        x: 0,\n        y: 0,\n        z: -1\n      }\n    },\n    enabled: {\n      default: true\n    },\n    far: {\n      default: 1000\n    },\n    interval: {\n      default: 0\n    },\n    near: {\n      default: 0\n    },\n    objects: {\n      default: ''\n    },\n    origin: {\n      type: 'vec3'\n    },\n    showLine: {\n      default: false\n    },\n    useWorldCoordinates: {\n      default: false\n    }\n  },\n  multiple: true,\n  init: function () {\n    this.clearedIntersectedEls = [];\n    this.unitLineEndVec3 = new THREE.Vector3();\n    this.intersectedEls = [];\n    this.intersections = [];\n    this.newIntersectedEls = [];\n    this.newIntersections = [];\n    this.objects = [];\n    this.prevCheckTime = undefined;\n    this.prevIntersectedEls = [];\n    this.rawIntersections = [];\n    this.raycaster = new THREE.Raycaster();\n    this.updateOriginDirection();\n    this.setDirty = this.setDirty.bind(this);\n    this.updateLine = this.updateLine.bind(this);\n    this.observer = new MutationObserver(this.setDirty);\n    this.dirty = true;\n    this.lineEndVec3 = new THREE.Vector3();\n    this.otherLineEndVec3 = new THREE.Vector3();\n    this.lineData = {\n      end: this.lineEndVec3\n    };\n    this.getIntersection = this.getIntersection.bind(this);\n    this.intersectedDetail = {\n      el: this.el,\n      getIntersection: this.getIntersection\n    };\n    this.intersectedClearedDetail = {\n      el: this.el\n    };\n    this.intersectionClearedDetail = {\n      clearedEls: this.clearedIntersectedEls\n    };\n    this.intersectionDetail = {};\n  },\n\n  /**\n   * Create or update raycaster object.\n   */\n  update: function (oldData) {\n    var data = this.data;\n    var el = this.el;\n    var raycaster = this.raycaster; // Set raycaster properties.\n\n    raycaster.far = data.far;\n    raycaster.near = data.near; // Draw line.\n\n    if (data.showLine && (data.far !== oldData.far || data.origin !== oldData.origin || data.direction !== oldData.direction || !oldData.showLine)) {\n      // Calculate unit vector for line direction. Can be multiplied via scalar to performantly\n      // adjust line length.\n      this.unitLineEndVec3.copy(data.origin).add(data.direction).normalize();\n      this.drawLine();\n    }\n\n    if (!data.showLine && oldData.showLine) {\n      el.removeAttribute('line');\n    }\n\n    if (data.objects !== oldData.objects && !OBSERVER_SELECTOR_RE.test(data.objects)) {\n      warn('[raycaster] Selector \"' + data.objects + '\" may not update automatically with DOM changes.');\n    }\n\n    if (!data.objects) {\n      warn('[raycaster] For performance, please define raycaster.objects when using ' + 'raycaster or cursor components to whitelist which entities to intersect with. ' + 'e.g., raycaster=\"objects: [data-raycastable]\".');\n    }\n\n    if (data.autoRefresh !== oldData.autoRefresh && el.isPlaying) {\n      data.autoRefresh ? this.addEventListeners() : this.removeEventListeners();\n    }\n\n    if (oldData.enabled && !data.enabled) {\n      this.clearAllIntersections();\n    }\n\n    this.setDirty();\n  },\n  play: function () {\n    this.addEventListeners();\n  },\n  pause: function () {\n    this.removeEventListeners();\n  },\n  remove: function () {\n    if (this.data.showLine) {\n      this.el.removeAttribute('line');\n    }\n\n    this.clearAllIntersections();\n  },\n  addEventListeners: function () {\n    if (!this.data.autoRefresh) {\n      return;\n    }\n\n    this.observer.observe(this.el.sceneEl, OBSERVER_CONFIG);\n    this.el.sceneEl.addEventListener('object3dset', this.setDirty);\n    this.el.sceneEl.addEventListener('object3dremove', this.setDirty);\n  },\n  removeEventListeners: function () {\n    this.observer.disconnect();\n    this.el.sceneEl.removeEventListener('object3dset', this.setDirty);\n    this.el.sceneEl.removeEventListener('object3dremove', this.setDirty);\n  },\n\n  /**\n   * Mark the object list as dirty, to be refreshed before next raycast.\n   */\n  setDirty: function () {\n    this.dirty = true;\n  },\n\n  /**\n   * Update list of objects to test for intersection.\n   */\n  refreshObjects: function () {\n    var data = this.data;\n    var els; // If objects not defined, intersect with everything.\n\n    els = data.objects ? this.el.sceneEl.querySelectorAll(data.objects) : this.el.sceneEl.querySelectorAll('*');\n    this.objects = this.flattenObject3DMaps(els);\n    this.dirty = false;\n  },\n\n  /**\n   * Check for intersections and cleared intersections on an interval.\n   */\n  tick: function (time) {\n    var data = this.data;\n    var prevCheckTime = this.prevCheckTime;\n\n    if (!data.enabled) {\n      return;\n    } // Only check for intersection if interval time has passed.\n\n\n    if (prevCheckTime && time - prevCheckTime < data.interval) {\n      return;\n    } // Update check time.\n\n\n    this.prevCheckTime = time;\n    this.checkIntersections();\n  },\n\n  /**\n   * Raycast for intersections and emit events for current and cleared inersections.\n   */\n  checkIntersections: function () {\n    var clearedIntersectedEls = this.clearedIntersectedEls;\n    var el = this.el;\n    var data = this.data;\n    var i;\n    var intersectedEls = this.intersectedEls;\n    var intersection;\n    var intersections = this.intersections;\n    var newIntersectedEls = this.newIntersectedEls;\n    var newIntersections = this.newIntersections;\n    var prevIntersectedEls = this.prevIntersectedEls;\n    var rawIntersections = this.rawIntersections; // Refresh the object whitelist if needed.\n\n    if (this.dirty) {\n      this.refreshObjects();\n    } // Store old previously intersected entities.\n\n\n    copyArray(this.prevIntersectedEls, this.intersectedEls); // Raycast.\n\n    this.updateOriginDirection();\n    rawIntersections.length = 0;\n    this.raycaster.intersectObjects(this.objects, true, rawIntersections); // Only keep intersections against objects that have a reference to an entity.\n\n    intersections.length = 0;\n    intersectedEls.length = 0;\n\n    for (i = 0; i < rawIntersections.length; i++) {\n      intersection = rawIntersections[i]; // Don't intersect with own line.\n\n      if (data.showLine && intersection.object === el.getObject3D('line')) {\n        continue;\n      }\n\n      if (intersection.object.el) {\n        intersections.push(intersection);\n        intersectedEls.push(intersection.object.el);\n      }\n    } // Get newly intersected entities.\n\n\n    newIntersections.length = 0;\n    newIntersectedEls.length = 0;\n\n    for (i = 0; i < intersections.length; i++) {\n      if (prevIntersectedEls.indexOf(intersections[i].object.el) === -1) {\n        newIntersections.push(intersections[i]);\n        newIntersectedEls.push(intersections[i].object.el);\n      }\n    } // Emit intersection cleared on both entities per formerly intersected entity.\n\n\n    clearedIntersectedEls.length = 0;\n\n    for (i = 0; i < prevIntersectedEls.length; i++) {\n      if (intersectedEls.indexOf(prevIntersectedEls[i]) !== -1) {\n        continue;\n      }\n\n      prevIntersectedEls[i].emit(EVENTS.INTERSECT_CLEAR, this.intersectedClearedDetail);\n      clearedIntersectedEls.push(prevIntersectedEls[i]);\n    }\n\n    if (clearedIntersectedEls.length) {\n      el.emit(EVENTS.INTERSECTION_CLEAR, this.intersectionClearedDetail);\n    } // Emit intersected on intersected entity per intersected entity.\n\n\n    for (i = 0; i < newIntersectedEls.length; i++) {\n      newIntersectedEls[i].emit(EVENTS.INTERSECT, this.intersectedDetail);\n    } // Emit all intersections at once on raycasting entity.\n\n\n    if (newIntersections.length) {\n      this.intersectionDetail.els = newIntersectedEls;\n      this.intersectionDetail.intersections = newIntersections;\n      el.emit(EVENTS.INTERSECTION, this.intersectionDetail);\n    } // Update line length.\n\n\n    if (data.showLine) {\n      setTimeout(this.updateLine);\n    }\n  },\n  updateLine: function () {\n    var el = this.el;\n    var intersections = this.intersections;\n    var lineLength;\n\n    if (intersections.length) {\n      if (intersections[0].object.el === el && intersections[1]) {\n        lineLength = intersections[1].distance;\n      } else {\n        lineLength = intersections[0].distance;\n      }\n    }\n\n    this.drawLine(lineLength);\n  },\n\n  /**\n   * Return the most recent intersection details for a given entity, if any.\n   * @param {AEntity} el\n   * @return {Object}\n   */\n  getIntersection: function (el) {\n    var i;\n    var intersection;\n\n    for (i = 0; i < this.intersections.length; i++) {\n      intersection = this.intersections[i];\n\n      if (intersection.object.el === el) {\n        return intersection;\n      }\n    }\n\n    return null;\n  },\n\n  /**\n   * Update origin and direction of raycaster using entity transforms and supplied origin or\n   * direction offsets.\n   */\n  updateOriginDirection: function () {\n    var direction = new THREE.Vector3();\n    var originVec3 = new THREE.Vector3(); // Closure to make quaternion/vector3 objects private.\n\n    return function updateOriginDirection() {\n      var el = this.el;\n      var data = this.data;\n\n      if (data.useWorldCoordinates) {\n        this.raycaster.set(data.origin, data.direction);\n        return;\n      } // Grab the position and rotation. (As a side effect, this updates el.object3D.matrixWorld.)\n\n\n      el.object3D.getWorldPosition(originVec3); // If non-zero origin, translate the origin into world space.\n\n      if (data.origin.x !== 0 || data.origin.y !== 0 || data.origin.z !== 0) {\n        originVec3 = el.object3D.localToWorld(originVec3.copy(data.origin));\n      } // three.js raycaster direction is relative to 0, 0, 0 NOT the origin / offset we\n      // provide. Apply the offset to the direction, then rotation from the object,\n      // and normalize.\n\n\n      direction.copy(data.direction).transformDirection(el.object3D.matrixWorld).normalize(); // Apply offset and direction, in world coordinates.\n\n      this.raycaster.set(originVec3, direction);\n    };\n  }(),\n\n  /**\n   * Create or update line to give raycaster visual representation.\n   * Customize the line through through line component.\n   * We draw the line in the raycaster component to customize the line to the\n   * raycaster's origin, direction, and far.\n   *\n   * Unlike the raycaster, we create the line as a child of the object. The line will\n   * be affected by the transforms of the objects, so we don't have to calculate transforms\n   * like we do with the raycaster.\n   *\n   * @param {number} length - Length of line. Pass in to shorten the line to the intersection\n   *   point. If not provided, length will default to the max length, `raycaster.far`.\n   */\n  drawLine: function (length) {\n    var data = this.data;\n    var el = this.el;\n    var endVec3; // Switch each time vector so line update triggered and to avoid unnecessary vector clone.\n\n    endVec3 = this.lineData.end === this.lineEndVec3 ? this.otherLineEndVec3 : this.lineEndVec3; // Treat Infinity as 1000m for the line.\n\n    if (length === undefined) {\n      length = data.far === Infinity ? 1000 : data.far;\n    } // Update the length of the line if given. `unitLineEndVec3` is the direction\n    // given by data.direction, then we apply a scalar to give it a length.\n\n\n    this.lineData.start = data.origin;\n    this.lineData.end = endVec3.copy(this.unitLineEndVec3).multiplyScalar(length);\n    el.setAttribute('line', this.lineData);\n  },\n\n  /**\n   * Return A-Frame attachments of each element's object3D group (e.g., mesh).\n   * Children are flattened by one level, removing the THREE.Group wrapper,\n   * so that non-recursive raycasting remains useful.\n   *\n   * Only push children defined as component attachemnts (e.g., setObject3D),\n   * NOT actual children in the scene graph hierarchy.\n   *\n   * @param  {Array<Element>} els\n   * @return {Array<THREE.Object3D>}\n   */\n  flattenObject3DMaps: function (els) {\n    var key;\n    var i;\n    var objects = this.objects; // Push meshes and other attachments onto list of objects to intersect.\n\n    objects.length = 0;\n\n    for (i = 0; i < els.length; i++) {\n      if (els[i].isEntity && els[i].object3D) {\n        for (key in els[i].object3DMap) {\n          objects.push(els[i].getObject3D(key));\n        }\n      }\n    }\n\n    return objects;\n  },\n  clearAllIntersections: function () {\n    var i;\n\n    for (i = 0; i < this.intersectedEls.length; i++) {\n      this.intersectedEls[i].emit(EVENTS.INTERSECT_CLEAR, this.intersectedClearedDetail);\n    }\n\n    copyArray(this.clearedIntersectedEls, this.intersectedEls);\n    this.intersectedEls.length = 0;\n    this.intersections.length = 0;\n    this.el.emit(EVENTS.INTERSECTION_CLEAR, this.intersectionClearedDetail);\n  }\n});\n/**\n * Copy contents of one array to another without allocating new array.\n */\n\nfunction copyArray(a, b) {\n  var i;\n  a.length = b.length;\n\n  for (i = 0; i < b.length; i++) {\n    a[i] = b[i];\n  }\n}","map":{"version":3,"sources":["C:/Users/Hannuri/Desktop/RoyalCyber/my-first-app/node_modules/aframe/src/components/raycaster.js"],"names":["registerComponent","require","THREE","utils","warn","debug","OBSERVER_SELECTOR_RE","OBSERVER_CONFIG","childList","attributes","subtree","EVENTS","INTERSECT","INTERSECTION","INTERSECT_CLEAR","INTERSECTION_CLEAR","module","exports","Component","schema","autoRefresh","default","direction","type","x","y","z","enabled","far","interval","near","objects","origin","showLine","useWorldCoordinates","multiple","init","clearedIntersectedEls","unitLineEndVec3","Vector3","intersectedEls","intersections","newIntersectedEls","newIntersections","prevCheckTime","undefined","prevIntersectedEls","rawIntersections","raycaster","Raycaster","updateOriginDirection","setDirty","bind","updateLine","observer","MutationObserver","dirty","lineEndVec3","otherLineEndVec3","lineData","end","getIntersection","intersectedDetail","el","intersectedClearedDetail","intersectionClearedDetail","clearedEls","intersectionDetail","update","oldData","data","copy","add","normalize","drawLine","removeAttribute","test","isPlaying","addEventListeners","removeEventListeners","clearAllIntersections","play","pause","remove","observe","sceneEl","addEventListener","disconnect","removeEventListener","refreshObjects","els","querySelectorAll","flattenObject3DMaps","tick","time","checkIntersections","i","intersection","copyArray","length","intersectObjects","object","getObject3D","push","indexOf","emit","setTimeout","lineLength","distance","originVec3","set","object3D","getWorldPosition","localToWorld","transformDirection","matrixWorld","endVec3","Infinity","start","multiplyScalar","setAttribute","key","isEntity","object3DMap","a","b"],"mappings":"AAAA;AAEA,IAAIA,iBAAiB,GAAGC,OAAO,CAAC,mBAAD,CAAP,CAA6BD,iBAArD;;AACA,IAAIE,KAAK,GAAGD,OAAO,CAAC,cAAD,CAAnB;;AACA,IAAIE,KAAK,GAAGF,OAAO,CAAC,WAAD,CAAnB;;AAEA,IAAIG,IAAI,GAAGD,KAAK,CAACE,KAAN,CAAY,2BAAZ,CAAX,C,CAEA;AACA;AACA;AACA;;AACA,IAAIC,oBAAoB,GAAG,kBAA3B,C,CAEA;AACA;;AACA,IAAIC,eAAe,GAAG;AACpBC,EAAAA,SAAS,EAAE,IADS;AAEpBC,EAAAA,UAAU,EAAE,IAFQ;AAGpBC,EAAAA,OAAO,EAAE;AAHW,CAAtB;AAMA,IAAIC,MAAM,GAAG;AACXC,EAAAA,SAAS,EAAE,uBADA;AAEXC,EAAAA,YAAY,EAAE,wBAFH;AAGXC,EAAAA,eAAe,EAAE,+BAHN;AAIXC,EAAAA,kBAAkB,EAAE;AAJT,CAAb;AAOA;;;;;;;;;;;;;AAYAC,MAAM,CAACC,OAAP,CAAeC,SAAf,GAA2BlB,iBAAiB,CAAC,WAAD,EAAc;AACxDmB,EAAAA,MAAM,EAAE;AACNC,IAAAA,WAAW,EAAE;AAACC,MAAAA,OAAO,EAAE;AAAV,KADP;AAENC,IAAAA,SAAS,EAAE;AAACC,MAAAA,IAAI,EAAE,MAAP;AAAeF,MAAAA,OAAO,EAAE;AAACG,QAAAA,CAAC,EAAE,CAAJ;AAAOC,QAAAA,CAAC,EAAE,CAAV;AAAaC,QAAAA,CAAC,EAAE,CAAC;AAAjB;AAAxB,KAFL;AAGNC,IAAAA,OAAO,EAAE;AAACN,MAAAA,OAAO,EAAE;AAAV,KAHH;AAINO,IAAAA,GAAG,EAAE;AAACP,MAAAA,OAAO,EAAE;AAAV,KAJC;AAKNQ,IAAAA,QAAQ,EAAE;AAACR,MAAAA,OAAO,EAAE;AAAV,KALJ;AAMNS,IAAAA,IAAI,EAAE;AAACT,MAAAA,OAAO,EAAE;AAAV,KANA;AAONU,IAAAA,OAAO,EAAE;AAACV,MAAAA,OAAO,EAAE;AAAV,KAPH;AAQNW,IAAAA,MAAM,EAAE;AAACT,MAAAA,IAAI,EAAE;AAAP,KARF;AASNU,IAAAA,QAAQ,EAAE;AAACZ,MAAAA,OAAO,EAAE;AAAV,KATJ;AAUNa,IAAAA,mBAAmB,EAAE;AAACb,MAAAA,OAAO,EAAE;AAAV;AAVf,GADgD;AAcxDc,EAAAA,QAAQ,EAAE,IAd8C;AAgBxDC,EAAAA,IAAI,EAAE,YAAY;AAChB,SAAKC,qBAAL,GAA6B,EAA7B;AACA,SAAKC,eAAL,GAAuB,IAAIpC,KAAK,CAACqC,OAAV,EAAvB;AACA,SAAKC,cAAL,GAAsB,EAAtB;AACA,SAAKC,aAAL,GAAqB,EAArB;AACA,SAAKC,iBAAL,GAAyB,EAAzB;AACA,SAAKC,gBAAL,GAAwB,EAAxB;AACA,SAAKZ,OAAL,GAAe,EAAf;AACA,SAAKa,aAAL,GAAqBC,SAArB;AACA,SAAKC,kBAAL,GAA0B,EAA1B;AACA,SAAKC,gBAAL,GAAwB,EAAxB;AACA,SAAKC,SAAL,GAAiB,IAAI9C,KAAK,CAAC+C,SAAV,EAAjB;AACA,SAAKC,qBAAL;AACA,SAAKC,QAAL,GAAgB,KAAKA,QAAL,CAAcC,IAAd,CAAmB,IAAnB,CAAhB;AACA,SAAKC,UAAL,GAAkB,KAAKA,UAAL,CAAgBD,IAAhB,CAAqB,IAArB,CAAlB;AACA,SAAKE,QAAL,GAAgB,IAAIC,gBAAJ,CAAqB,KAAKJ,QAA1B,CAAhB;AACA,SAAKK,KAAL,GAAa,IAAb;AACA,SAAKC,WAAL,GAAmB,IAAIvD,KAAK,CAACqC,OAAV,EAAnB;AACA,SAAKmB,gBAAL,GAAwB,IAAIxD,KAAK,CAACqC,OAAV,EAAxB;AACA,SAAKoB,QAAL,GAAgB;AAACC,MAAAA,GAAG,EAAE,KAAKH;AAAX,KAAhB;AAEA,SAAKI,eAAL,GAAuB,KAAKA,eAAL,CAAqBT,IAArB,CAA0B,IAA1B,CAAvB;AACA,SAAKU,iBAAL,GAAyB;AAACC,MAAAA,EAAE,EAAE,KAAKA,EAAV;AAAcF,MAAAA,eAAe,EAAE,KAAKA;AAApC,KAAzB;AACA,SAAKG,wBAAL,GAAgC;AAACD,MAAAA,EAAE,EAAE,KAAKA;AAAV,KAAhC;AACA,SAAKE,yBAAL,GAAiC;AAACC,MAAAA,UAAU,EAAE,KAAK7B;AAAlB,KAAjC;AACA,SAAK8B,kBAAL,GAA0B,EAA1B;AACD,GA1CuD;;AA4CxD;;;AAGAC,EAAAA,MAAM,EAAE,UAAUC,OAAV,EAAmB;AACzB,QAAIC,IAAI,GAAG,KAAKA,IAAhB;AACA,QAAIP,EAAE,GAAG,KAAKA,EAAd;AACA,QAAIf,SAAS,GAAG,KAAKA,SAArB,CAHyB,CAKzB;;AACAA,IAAAA,SAAS,CAACpB,GAAV,GAAgB0C,IAAI,CAAC1C,GAArB;AACAoB,IAAAA,SAAS,CAAClB,IAAV,GAAiBwC,IAAI,CAACxC,IAAtB,CAPyB,CASzB;;AACA,QAAIwC,IAAI,CAACrC,QAAL,KACCqC,IAAI,CAAC1C,GAAL,KAAayC,OAAO,CAACzC,GAArB,IAA4B0C,IAAI,CAACtC,MAAL,KAAgBqC,OAAO,CAACrC,MAApD,IACAsC,IAAI,CAAChD,SAAL,KAAmB+C,OAAO,CAAC/C,SAD3B,IACwC,CAAC+C,OAAO,CAACpC,QAFlD,CAAJ,EAEiE;AAC/D;AACA;AACA,WAAKK,eAAL,CAAqBiC,IAArB,CAA0BD,IAAI,CAACtC,MAA/B,EAAuCwC,GAAvC,CAA2CF,IAAI,CAAChD,SAAhD,EAA2DmD,SAA3D;AACA,WAAKC,QAAL;AACD;;AAED,QAAI,CAACJ,IAAI,CAACrC,QAAN,IAAkBoC,OAAO,CAACpC,QAA9B,EAAwC;AACtC8B,MAAAA,EAAE,CAACY,eAAH,CAAmB,MAAnB;AACD;;AAED,QAAIL,IAAI,CAACvC,OAAL,KAAiBsC,OAAO,CAACtC,OAAzB,IAAoC,CAACzB,oBAAoB,CAACsE,IAArB,CAA0BN,IAAI,CAACvC,OAA/B,CAAzC,EAAkF;AAChF3B,MAAAA,IAAI,CAAC,2BAA2BkE,IAAI,CAACvC,OAAhC,GACA,kDADD,CAAJ;AAED;;AAED,QAAI,CAACuC,IAAI,CAACvC,OAAV,EAAmB;AACjB3B,MAAAA,IAAI,CAAC,6EACA,gFADA,GAEA,gDAFD,CAAJ;AAGD;;AAED,QAAIkE,IAAI,CAAClD,WAAL,KAAqBiD,OAAO,CAACjD,WAA7B,IAA4C2C,EAAE,CAACc,SAAnD,EAA8D;AAC5DP,MAAAA,IAAI,CAAClD,WAAL,GACI,KAAK0D,iBAAL,EADJ,GAEI,KAAKC,oBAAL,EAFJ;AAGD;;AAED,QAAIV,OAAO,CAAC1C,OAAR,IAAmB,CAAC2C,IAAI,CAAC3C,OAA7B,EAAsC;AAAE,WAAKqD,qBAAL;AAA+B;;AAEvE,SAAK7B,QAAL;AACD,GA1FuD;AA4FxD8B,EAAAA,IAAI,EAAE,YAAY;AAChB,SAAKH,iBAAL;AACD,GA9FuD;AAgGxDI,EAAAA,KAAK,EAAE,YAAY;AACjB,SAAKH,oBAAL;AACD,GAlGuD;AAoGxDI,EAAAA,MAAM,EAAE,YAAY;AAClB,QAAI,KAAKb,IAAL,CAAUrC,QAAd,EAAwB;AACtB,WAAK8B,EAAL,CAAQY,eAAR,CAAwB,MAAxB;AACD;;AACD,SAAKK,qBAAL;AACD,GAzGuD;AA2GxDF,EAAAA,iBAAiB,EAAE,YAAY;AAC7B,QAAI,CAAC,KAAKR,IAAL,CAAUlD,WAAf,EAA4B;AAAE;AAAS;;AACvC,SAAKkC,QAAL,CAAc8B,OAAd,CAAsB,KAAKrB,EAAL,CAAQsB,OAA9B,EAAuC9E,eAAvC;AACA,SAAKwD,EAAL,CAAQsB,OAAR,CAAgBC,gBAAhB,CAAiC,aAAjC,EAAgD,KAAKnC,QAArD;AACA,SAAKY,EAAL,CAAQsB,OAAR,CAAgBC,gBAAhB,CAAiC,gBAAjC,EAAmD,KAAKnC,QAAxD;AACD,GAhHuD;AAkHxD4B,EAAAA,oBAAoB,EAAE,YAAY;AAChC,SAAKzB,QAAL,CAAciC,UAAd;AACA,SAAKxB,EAAL,CAAQsB,OAAR,CAAgBG,mBAAhB,CAAoC,aAApC,EAAmD,KAAKrC,QAAxD;AACA,SAAKY,EAAL,CAAQsB,OAAR,CAAgBG,mBAAhB,CAAoC,gBAApC,EAAsD,KAAKrC,QAA3D;AACD,GAtHuD;;AAwHxD;;;AAGAA,EAAAA,QAAQ,EAAE,YAAY;AACpB,SAAKK,KAAL,GAAa,IAAb;AACD,GA7HuD;;AA+HxD;;;AAGAiC,EAAAA,cAAc,EAAE,YAAY;AAC1B,QAAInB,IAAI,GAAG,KAAKA,IAAhB;AACA,QAAIoB,GAAJ,CAF0B,CAI1B;;AACAA,IAAAA,GAAG,GAAGpB,IAAI,CAACvC,OAAL,GACF,KAAKgC,EAAL,CAAQsB,OAAR,CAAgBM,gBAAhB,CAAiCrB,IAAI,CAACvC,OAAtC,CADE,GAEF,KAAKgC,EAAL,CAAQsB,OAAR,CAAgBM,gBAAhB,CAAiC,GAAjC,CAFJ;AAGA,SAAK5D,OAAL,GAAe,KAAK6D,mBAAL,CAAyBF,GAAzB,CAAf;AACA,SAAKlC,KAAL,GAAa,KAAb;AACD,GA5IuD;;AA8IxD;;;AAGAqC,EAAAA,IAAI,EAAE,UAAUC,IAAV,EAAgB;AACpB,QAAIxB,IAAI,GAAG,KAAKA,IAAhB;AACA,QAAI1B,aAAa,GAAG,KAAKA,aAAzB;;AAEA,QAAI,CAAC0B,IAAI,CAAC3C,OAAV,EAAmB;AAAE;AAAS,KAJV,CAMpB;;;AACA,QAAIiB,aAAa,IAAKkD,IAAI,GAAGlD,aAAP,GAAuB0B,IAAI,CAACzC,QAAlD,EAA6D;AAAE;AAAS,KAPpD,CASpB;;;AACA,SAAKe,aAAL,GAAqBkD,IAArB;AACA,SAAKC,kBAAL;AACD,GA7JuD;;AA+JxD;;;AAGAA,EAAAA,kBAAkB,EAAE,YAAY;AAC9B,QAAI1D,qBAAqB,GAAG,KAAKA,qBAAjC;AACA,QAAI0B,EAAE,GAAG,KAAKA,EAAd;AACA,QAAIO,IAAI,GAAG,KAAKA,IAAhB;AACA,QAAI0B,CAAJ;AACA,QAAIxD,cAAc,GAAG,KAAKA,cAA1B;AACA,QAAIyD,YAAJ;AACA,QAAIxD,aAAa,GAAG,KAAKA,aAAzB;AACA,QAAIC,iBAAiB,GAAG,KAAKA,iBAA7B;AACA,QAAIC,gBAAgB,GAAG,KAAKA,gBAA5B;AACA,QAAIG,kBAAkB,GAAG,KAAKA,kBAA9B;AACA,QAAIC,gBAAgB,GAAG,KAAKA,gBAA5B,CAX8B,CAa9B;;AACA,QAAI,KAAKS,KAAT,EAAgB;AAAE,WAAKiC,cAAL;AAAwB,KAdZ,CAgB9B;;;AACAS,IAAAA,SAAS,CAAC,KAAKpD,kBAAN,EAA0B,KAAKN,cAA/B,CAAT,CAjB8B,CAmB9B;;AACA,SAAKU,qBAAL;AACAH,IAAAA,gBAAgB,CAACoD,MAAjB,GAA0B,CAA1B;AACA,SAAKnD,SAAL,CAAeoD,gBAAf,CAAgC,KAAKrE,OAArC,EAA8C,IAA9C,EAAoDgB,gBAApD,EAtB8B,CAwB9B;;AACAN,IAAAA,aAAa,CAAC0D,MAAd,GAAuB,CAAvB;AACA3D,IAAAA,cAAc,CAAC2D,MAAf,GAAwB,CAAxB;;AACA,SAAKH,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGjD,gBAAgB,CAACoD,MAAjC,EAAyCH,CAAC,EAA1C,EAA8C;AAC5CC,MAAAA,YAAY,GAAGlD,gBAAgB,CAACiD,CAAD,CAA/B,CAD4C,CAE5C;;AACA,UAAI1B,IAAI,CAACrC,QAAL,IAAiBgE,YAAY,CAACI,MAAb,KAAwBtC,EAAE,CAACuC,WAAH,CAAe,MAAf,CAA7C,EAAqE;AACnE;AACD;;AACD,UAAIL,YAAY,CAACI,MAAb,CAAoBtC,EAAxB,EAA4B;AAC1BtB,QAAAA,aAAa,CAAC8D,IAAd,CAAmBN,YAAnB;AACAzD,QAAAA,cAAc,CAAC+D,IAAf,CAAoBN,YAAY,CAACI,MAAb,CAAoBtC,EAAxC;AACD;AACF,KArC6B,CAuC9B;;;AACApB,IAAAA,gBAAgB,CAACwD,MAAjB,GAA0B,CAA1B;AACAzD,IAAAA,iBAAiB,CAACyD,MAAlB,GAA2B,CAA3B;;AACA,SAAKH,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGvD,aAAa,CAAC0D,MAA9B,EAAsCH,CAAC,EAAvC,EAA2C;AACzC,UAAIlD,kBAAkB,CAAC0D,OAAnB,CAA2B/D,aAAa,CAACuD,CAAD,CAAb,CAAiBK,MAAjB,CAAwBtC,EAAnD,MAA2D,CAAC,CAAhE,EAAmE;AACjEpB,QAAAA,gBAAgB,CAAC4D,IAAjB,CAAsB9D,aAAa,CAACuD,CAAD,CAAnC;AACAtD,QAAAA,iBAAiB,CAAC6D,IAAlB,CAAuB9D,aAAa,CAACuD,CAAD,CAAb,CAAiBK,MAAjB,CAAwBtC,EAA/C;AACD;AACF,KA/C6B,CAiD9B;;;AACA1B,IAAAA,qBAAqB,CAAC8D,MAAtB,GAA+B,CAA/B;;AACA,SAAKH,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGlD,kBAAkB,CAACqD,MAAnC,EAA2CH,CAAC,EAA5C,EAAgD;AAC9C,UAAIxD,cAAc,CAACgE,OAAf,CAAuB1D,kBAAkB,CAACkD,CAAD,CAAzC,MAAkD,CAAC,CAAvD,EAA0D;AAAE;AAAW;;AACvElD,MAAAA,kBAAkB,CAACkD,CAAD,CAAlB,CAAsBS,IAAtB,CAA2B9F,MAAM,CAACG,eAAlC,EAC2B,KAAKkD,wBADhC;AAEA3B,MAAAA,qBAAqB,CAACkE,IAAtB,CAA2BzD,kBAAkB,CAACkD,CAAD,CAA7C;AACD;;AACD,QAAI3D,qBAAqB,CAAC8D,MAA1B,EAAkC;AAChCpC,MAAAA,EAAE,CAAC0C,IAAH,CAAQ9F,MAAM,CAACI,kBAAf,EAAmC,KAAKkD,yBAAxC;AACD,KA3D6B,CA6D9B;;;AACA,SAAK+B,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGtD,iBAAiB,CAACyD,MAAlC,EAA0CH,CAAC,EAA3C,EAA+C;AAC7CtD,MAAAA,iBAAiB,CAACsD,CAAD,CAAjB,CAAqBS,IAArB,CAA0B9F,MAAM,CAACC,SAAjC,EAA4C,KAAKkD,iBAAjD;AACD,KAhE6B,CAkE9B;;;AACA,QAAInB,gBAAgB,CAACwD,MAArB,EAA6B;AAC3B,WAAKhC,kBAAL,CAAwBuB,GAAxB,GAA8BhD,iBAA9B;AACA,WAAKyB,kBAAL,CAAwB1B,aAAxB,GAAwCE,gBAAxC;AACAoB,MAAAA,EAAE,CAAC0C,IAAH,CAAQ9F,MAAM,CAACE,YAAf,EAA6B,KAAKsD,kBAAlC;AACD,KAvE6B,CAyE9B;;;AACA,QAAIG,IAAI,CAACrC,QAAT,EAAmB;AAAEyE,MAAAA,UAAU,CAAC,KAAKrD,UAAN,CAAV;AAA8B;AACpD,GA7OuD;AA+OxDA,EAAAA,UAAU,EAAE,YAAY;AACtB,QAAIU,EAAE,GAAG,KAAKA,EAAd;AACA,QAAItB,aAAa,GAAG,KAAKA,aAAzB;AACA,QAAIkE,UAAJ;;AAEA,QAAIlE,aAAa,CAAC0D,MAAlB,EAA0B;AACxB,UAAI1D,aAAa,CAAC,CAAD,CAAb,CAAiB4D,MAAjB,CAAwBtC,EAAxB,KAA+BA,EAA/B,IAAqCtB,aAAa,CAAC,CAAD,CAAtD,EAA2D;AACzDkE,QAAAA,UAAU,GAAGlE,aAAa,CAAC,CAAD,CAAb,CAAiBmE,QAA9B;AACD,OAFD,MAEO;AACLD,QAAAA,UAAU,GAAGlE,aAAa,CAAC,CAAD,CAAb,CAAiBmE,QAA9B;AACD;AACF;;AACD,SAAKlC,QAAL,CAAciC,UAAd;AACD,GA5PuD;;AA8PxD;;;;;AAKA9C,EAAAA,eAAe,EAAE,UAAUE,EAAV,EAAc;AAC7B,QAAIiC,CAAJ;AACA,QAAIC,YAAJ;;AACA,SAAKD,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG,KAAKvD,aAAL,CAAmB0D,MAAnC,EAA2CH,CAAC,EAA5C,EAAgD;AAC9CC,MAAAA,YAAY,GAAG,KAAKxD,aAAL,CAAmBuD,CAAnB,CAAf;;AACA,UAAIC,YAAY,CAACI,MAAb,CAAoBtC,EAApB,KAA2BA,EAA/B,EAAmC;AAAE,eAAOkC,YAAP;AAAsB;AAC5D;;AACD,WAAO,IAAP;AACD,GA3QuD;;AA6QxD;;;;AAIA/C,EAAAA,qBAAqB,EAAG,YAAY;AAClC,QAAI5B,SAAS,GAAG,IAAIpB,KAAK,CAACqC,OAAV,EAAhB;AACA,QAAIsE,UAAU,GAAG,IAAI3G,KAAK,CAACqC,OAAV,EAAjB,CAFkC,CAIlC;;AACA,WAAO,SAASW,qBAAT,GAAkC;AACvC,UAAIa,EAAE,GAAG,KAAKA,EAAd;AACA,UAAIO,IAAI,GAAG,KAAKA,IAAhB;;AAEA,UAAIA,IAAI,CAACpC,mBAAT,EAA8B;AAC5B,aAAKc,SAAL,CAAe8D,GAAf,CAAmBxC,IAAI,CAACtC,MAAxB,EAAgCsC,IAAI,CAAChD,SAArC;AACA;AACD,OAPsC,CASvC;;;AACAyC,MAAAA,EAAE,CAACgD,QAAH,CAAYC,gBAAZ,CAA6BH,UAA7B,EAVuC,CAYvC;;AACA,UAAIvC,IAAI,CAACtC,MAAL,CAAYR,CAAZ,KAAkB,CAAlB,IAAuB8C,IAAI,CAACtC,MAAL,CAAYP,CAAZ,KAAkB,CAAzC,IAA8C6C,IAAI,CAACtC,MAAL,CAAYN,CAAZ,KAAkB,CAApE,EAAuE;AACrEmF,QAAAA,UAAU,GAAG9C,EAAE,CAACgD,QAAH,CAAYE,YAAZ,CAAyBJ,UAAU,CAACtC,IAAX,CAAgBD,IAAI,CAACtC,MAArB,CAAzB,CAAb;AACD,OAfsC,CAiBvC;AACA;AACA;;;AACAV,MAAAA,SAAS,CAACiD,IAAV,CAAeD,IAAI,CAAChD,SAApB,EAA+B4F,kBAA/B,CAAkDnD,EAAE,CAACgD,QAAH,CAAYI,WAA9D,EAA2E1C,SAA3E,GApBuC,CAsBvC;;AACA,WAAKzB,SAAL,CAAe8D,GAAf,CAAmBD,UAAnB,EAA+BvF,SAA/B;AACD,KAxBD;AAyBD,GA9BsB,EAjRiC;;AAiTxD;;;;;;;;;;;;;AAaAoD,EAAAA,QAAQ,EAAE,UAAUyB,MAAV,EAAkB;AAC1B,QAAI7B,IAAI,GAAG,KAAKA,IAAhB;AACA,QAAIP,EAAE,GAAG,KAAKA,EAAd;AACA,QAAIqD,OAAJ,CAH0B,CAK1B;;AACAA,IAAAA,OAAO,GAAG,KAAKzD,QAAL,CAAcC,GAAd,KAAsB,KAAKH,WAA3B,GACN,KAAKC,gBADC,GAEN,KAAKD,WAFT,CAN0B,CAU1B;;AACA,QAAI0C,MAAM,KAAKtD,SAAf,EAA0B;AACxBsD,MAAAA,MAAM,GAAG7B,IAAI,CAAC1C,GAAL,KAAayF,QAAb,GAAwB,IAAxB,GAA+B/C,IAAI,CAAC1C,GAA7C;AACD,KAbyB,CAe1B;AACA;;;AACA,SAAK+B,QAAL,CAAc2D,KAAd,GAAsBhD,IAAI,CAACtC,MAA3B;AACA,SAAK2B,QAAL,CAAcC,GAAd,GAAoBwD,OAAO,CAAC7C,IAAR,CAAa,KAAKjC,eAAlB,EAAmCiF,cAAnC,CAAkDpB,MAAlD,CAApB;AACApC,IAAAA,EAAE,CAACyD,YAAH,CAAgB,MAAhB,EAAwB,KAAK7D,QAA7B;AACD,GAlVuD;;AAoVxD;;;;;;;;;;;AAWAiC,EAAAA,mBAAmB,EAAE,UAAUF,GAAV,EAAe;AAClC,QAAI+B,GAAJ;AACA,QAAIzB,CAAJ;AACA,QAAIjE,OAAO,GAAG,KAAKA,OAAnB,CAHkC,CAKlC;;AACAA,IAAAA,OAAO,CAACoE,MAAR,GAAiB,CAAjB;;AACA,SAAKH,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGN,GAAG,CAACS,MAApB,EAA4BH,CAAC,EAA7B,EAAiC;AAC/B,UAAIN,GAAG,CAACM,CAAD,CAAH,CAAO0B,QAAP,IAAmBhC,GAAG,CAACM,CAAD,CAAH,CAAOe,QAA9B,EAAwC;AACtC,aAAKU,GAAL,IAAY/B,GAAG,CAACM,CAAD,CAAH,CAAO2B,WAAnB,EAAgC;AAC9B5F,UAAAA,OAAO,CAACwE,IAAR,CAAab,GAAG,CAACM,CAAD,CAAH,CAAOM,WAAP,CAAmBmB,GAAnB,CAAb;AACD;AACF;AACF;;AAED,WAAO1F,OAAP;AACD,GA/WuD;AAiXxDiD,EAAAA,qBAAqB,EAAE,YAAY;AACjC,QAAIgB,CAAJ;;AACA,SAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG,KAAKxD,cAAL,CAAoB2D,MAApC,EAA4CH,CAAC,EAA7C,EAAiD;AAC/C,WAAKxD,cAAL,CAAoBwD,CAApB,EAAuBS,IAAvB,CAA4B9F,MAAM,CAACG,eAAnC,EAC4B,KAAKkD,wBADjC;AAED;;AACDkC,IAAAA,SAAS,CAAC,KAAK7D,qBAAN,EAA6B,KAAKG,cAAlC,CAAT;AACA,SAAKA,cAAL,CAAoB2D,MAApB,GAA6B,CAA7B;AACA,SAAK1D,aAAL,CAAmB0D,MAAnB,GAA4B,CAA5B;AACA,SAAKpC,EAAL,CAAQ0C,IAAR,CAAa9F,MAAM,CAACI,kBAApB,EAAwC,KAAKkD,yBAA7C;AACD;AA3XuD,CAAd,CAA5C;AA8XA;;;;AAGA,SAASiC,SAAT,CAAoB0B,CAApB,EAAuBC,CAAvB,EAA0B;AACxB,MAAI7B,CAAJ;AACA4B,EAAAA,CAAC,CAACzB,MAAF,GAAW0B,CAAC,CAAC1B,MAAb;;AACA,OAAKH,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG6B,CAAC,CAAC1B,MAAlB,EAA0BH,CAAC,EAA3B,EAA+B;AAC7B4B,IAAAA,CAAC,CAAC5B,CAAD,CAAD,GAAO6B,CAAC,CAAC7B,CAAD,CAAR;AACD;AACF","sourcesContent":["/* global MutationObserver */\n\nvar registerComponent = require('../core/component').registerComponent;\nvar THREE = require('../lib/three');\nvar utils = require('../utils/');\n\nvar warn = utils.debug('components:raycaster:warn');\n\n// Defines selectors that should be 'safe' for the MutationObserver used to\n// refresh the whitelist. Matches classnames, IDs, and presence of attributes.\n// Selectors for the value of an attribute, like [position=0 2 0], cannot be\n// reliably detected and are therefore disallowed.\nvar OBSERVER_SELECTOR_RE = /^[\\w\\s-.,[\\]#]*$/;\n\n// Configuration for the MutationObserver used to refresh the whitelist.\n// Listens for addition/removal of elements and attributes within the scene.\nvar OBSERVER_CONFIG = {\n  childList: true,\n  attributes: true,\n  subtree: true\n};\n\nvar EVENTS = {\n  INTERSECT: 'raycaster-intersected',\n  INTERSECTION: 'raycaster-intersection',\n  INTERSECT_CLEAR: 'raycaster-intersected-cleared',\n  INTERSECTION_CLEAR: 'raycaster-intersection-cleared'\n};\n\n/**\n * Raycaster component.\n *\n * Pass options to three.js Raycaster including which objects to test.\n * Poll for intersections.\n * Emit event on origin entity and on target entity on intersect.\n *\n * @member {array} intersectedEls - List of currently intersected entities.\n * @member {array} objects - Cached list of meshes to intersect.\n * @member {number} prevCheckTime - Previous time intersection was checked. To help interval.\n * @member {object} raycaster - three.js Raycaster.\n */\nmodule.exports.Component = registerComponent('raycaster', {\n  schema: {\n    autoRefresh: {default: true},\n    direction: {type: 'vec3', default: {x: 0, y: 0, z: -1}},\n    enabled: {default: true},\n    far: {default: 1000},\n    interval: {default: 0},\n    near: {default: 0},\n    objects: {default: ''},\n    origin: {type: 'vec3'},\n    showLine: {default: false},\n    useWorldCoordinates: {default: false}\n  },\n\n  multiple: true,\n\n  init: function () {\n    this.clearedIntersectedEls = [];\n    this.unitLineEndVec3 = new THREE.Vector3();\n    this.intersectedEls = [];\n    this.intersections = [];\n    this.newIntersectedEls = [];\n    this.newIntersections = [];\n    this.objects = [];\n    this.prevCheckTime = undefined;\n    this.prevIntersectedEls = [];\n    this.rawIntersections = [];\n    this.raycaster = new THREE.Raycaster();\n    this.updateOriginDirection();\n    this.setDirty = this.setDirty.bind(this);\n    this.updateLine = this.updateLine.bind(this);\n    this.observer = new MutationObserver(this.setDirty);\n    this.dirty = true;\n    this.lineEndVec3 = new THREE.Vector3();\n    this.otherLineEndVec3 = new THREE.Vector3();\n    this.lineData = {end: this.lineEndVec3};\n\n    this.getIntersection = this.getIntersection.bind(this);\n    this.intersectedDetail = {el: this.el, getIntersection: this.getIntersection};\n    this.intersectedClearedDetail = {el: this.el};\n    this.intersectionClearedDetail = {clearedEls: this.clearedIntersectedEls};\n    this.intersectionDetail = {};\n  },\n\n  /**\n   * Create or update raycaster object.\n   */\n  update: function (oldData) {\n    var data = this.data;\n    var el = this.el;\n    var raycaster = this.raycaster;\n\n    // Set raycaster properties.\n    raycaster.far = data.far;\n    raycaster.near = data.near;\n\n    // Draw line.\n    if (data.showLine &&\n        (data.far !== oldData.far || data.origin !== oldData.origin ||\n         data.direction !== oldData.direction || !oldData.showLine)) {\n      // Calculate unit vector for line direction. Can be multiplied via scalar to performantly\n      // adjust line length.\n      this.unitLineEndVec3.copy(data.origin).add(data.direction).normalize();\n      this.drawLine();\n    }\n\n    if (!data.showLine && oldData.showLine) {\n      el.removeAttribute('line');\n    }\n\n    if (data.objects !== oldData.objects && !OBSERVER_SELECTOR_RE.test(data.objects)) {\n      warn('[raycaster] Selector \"' + data.objects +\n           '\" may not update automatically with DOM changes.');\n    }\n\n    if (!data.objects) {\n      warn('[raycaster] For performance, please define raycaster.objects when using ' +\n           'raycaster or cursor components to whitelist which entities to intersect with. ' +\n           'e.g., raycaster=\"objects: [data-raycastable]\".');\n    }\n\n    if (data.autoRefresh !== oldData.autoRefresh && el.isPlaying) {\n      data.autoRefresh\n        ? this.addEventListeners()\n        : this.removeEventListeners();\n    }\n\n    if (oldData.enabled && !data.enabled) { this.clearAllIntersections(); }\n\n    this.setDirty();\n  },\n\n  play: function () {\n    this.addEventListeners();\n  },\n\n  pause: function () {\n    this.removeEventListeners();\n  },\n\n  remove: function () {\n    if (this.data.showLine) {\n      this.el.removeAttribute('line');\n    }\n    this.clearAllIntersections();\n  },\n\n  addEventListeners: function () {\n    if (!this.data.autoRefresh) { return; }\n    this.observer.observe(this.el.sceneEl, OBSERVER_CONFIG);\n    this.el.sceneEl.addEventListener('object3dset', this.setDirty);\n    this.el.sceneEl.addEventListener('object3dremove', this.setDirty);\n  },\n\n  removeEventListeners: function () {\n    this.observer.disconnect();\n    this.el.sceneEl.removeEventListener('object3dset', this.setDirty);\n    this.el.sceneEl.removeEventListener('object3dremove', this.setDirty);\n  },\n\n  /**\n   * Mark the object list as dirty, to be refreshed before next raycast.\n   */\n  setDirty: function () {\n    this.dirty = true;\n  },\n\n  /**\n   * Update list of objects to test for intersection.\n   */\n  refreshObjects: function () {\n    var data = this.data;\n    var els;\n\n    // If objects not defined, intersect with everything.\n    els = data.objects\n      ? this.el.sceneEl.querySelectorAll(data.objects)\n      : this.el.sceneEl.querySelectorAll('*');\n    this.objects = this.flattenObject3DMaps(els);\n    this.dirty = false;\n  },\n\n  /**\n   * Check for intersections and cleared intersections on an interval.\n   */\n  tick: function (time) {\n    var data = this.data;\n    var prevCheckTime = this.prevCheckTime;\n\n    if (!data.enabled) { return; }\n\n    // Only check for intersection if interval time has passed.\n    if (prevCheckTime && (time - prevCheckTime < data.interval)) { return; }\n\n    // Update check time.\n    this.prevCheckTime = time;\n    this.checkIntersections();\n  },\n\n  /**\n   * Raycast for intersections and emit events for current and cleared inersections.\n   */\n  checkIntersections: function () {\n    var clearedIntersectedEls = this.clearedIntersectedEls;\n    var el = this.el;\n    var data = this.data;\n    var i;\n    var intersectedEls = this.intersectedEls;\n    var intersection;\n    var intersections = this.intersections;\n    var newIntersectedEls = this.newIntersectedEls;\n    var newIntersections = this.newIntersections;\n    var prevIntersectedEls = this.prevIntersectedEls;\n    var rawIntersections = this.rawIntersections;\n\n    // Refresh the object whitelist if needed.\n    if (this.dirty) { this.refreshObjects(); }\n\n    // Store old previously intersected entities.\n    copyArray(this.prevIntersectedEls, this.intersectedEls);\n\n    // Raycast.\n    this.updateOriginDirection();\n    rawIntersections.length = 0;\n    this.raycaster.intersectObjects(this.objects, true, rawIntersections);\n\n    // Only keep intersections against objects that have a reference to an entity.\n    intersections.length = 0;\n    intersectedEls.length = 0;\n    for (i = 0; i < rawIntersections.length; i++) {\n      intersection = rawIntersections[i];\n      // Don't intersect with own line.\n      if (data.showLine && intersection.object === el.getObject3D('line')) {\n        continue;\n      }\n      if (intersection.object.el) {\n        intersections.push(intersection);\n        intersectedEls.push(intersection.object.el);\n      }\n    }\n\n    // Get newly intersected entities.\n    newIntersections.length = 0;\n    newIntersectedEls.length = 0;\n    for (i = 0; i < intersections.length; i++) {\n      if (prevIntersectedEls.indexOf(intersections[i].object.el) === -1) {\n        newIntersections.push(intersections[i]);\n        newIntersectedEls.push(intersections[i].object.el);\n      }\n    }\n\n    // Emit intersection cleared on both entities per formerly intersected entity.\n    clearedIntersectedEls.length = 0;\n    for (i = 0; i < prevIntersectedEls.length; i++) {\n      if (intersectedEls.indexOf(prevIntersectedEls[i]) !== -1) { continue; }\n      prevIntersectedEls[i].emit(EVENTS.INTERSECT_CLEAR,\n                                 this.intersectedClearedDetail);\n      clearedIntersectedEls.push(prevIntersectedEls[i]);\n    }\n    if (clearedIntersectedEls.length) {\n      el.emit(EVENTS.INTERSECTION_CLEAR, this.intersectionClearedDetail);\n    }\n\n    // Emit intersected on intersected entity per intersected entity.\n    for (i = 0; i < newIntersectedEls.length; i++) {\n      newIntersectedEls[i].emit(EVENTS.INTERSECT, this.intersectedDetail);\n    }\n\n    // Emit all intersections at once on raycasting entity.\n    if (newIntersections.length) {\n      this.intersectionDetail.els = newIntersectedEls;\n      this.intersectionDetail.intersections = newIntersections;\n      el.emit(EVENTS.INTERSECTION, this.intersectionDetail);\n    }\n\n    // Update line length.\n    if (data.showLine) { setTimeout(this.updateLine); }\n  },\n\n  updateLine: function () {\n    var el = this.el;\n    var intersections = this.intersections;\n    var lineLength;\n\n    if (intersections.length) {\n      if (intersections[0].object.el === el && intersections[1]) {\n        lineLength = intersections[1].distance;\n      } else {\n        lineLength = intersections[0].distance;\n      }\n    }\n    this.drawLine(lineLength);\n  },\n\n  /**\n   * Return the most recent intersection details for a given entity, if any.\n   * @param {AEntity} el\n   * @return {Object}\n   */\n  getIntersection: function (el) {\n    var i;\n    var intersection;\n    for (i = 0; i < this.intersections.length; i++) {\n      intersection = this.intersections[i];\n      if (intersection.object.el === el) { return intersection; }\n    }\n    return null;\n  },\n\n  /**\n   * Update origin and direction of raycaster using entity transforms and supplied origin or\n   * direction offsets.\n   */\n  updateOriginDirection: (function () {\n    var direction = new THREE.Vector3();\n    var originVec3 = new THREE.Vector3();\n\n    // Closure to make quaternion/vector3 objects private.\n    return function updateOriginDirection () {\n      var el = this.el;\n      var data = this.data;\n\n      if (data.useWorldCoordinates) {\n        this.raycaster.set(data.origin, data.direction);\n        return;\n      }\n\n      // Grab the position and rotation. (As a side effect, this updates el.object3D.matrixWorld.)\n      el.object3D.getWorldPosition(originVec3);\n\n      // If non-zero origin, translate the origin into world space.\n      if (data.origin.x !== 0 || data.origin.y !== 0 || data.origin.z !== 0) {\n        originVec3 = el.object3D.localToWorld(originVec3.copy(data.origin));\n      }\n\n      // three.js raycaster direction is relative to 0, 0, 0 NOT the origin / offset we\n      // provide. Apply the offset to the direction, then rotation from the object,\n      // and normalize.\n      direction.copy(data.direction).transformDirection(el.object3D.matrixWorld).normalize();\n\n      // Apply offset and direction, in world coordinates.\n      this.raycaster.set(originVec3, direction);\n    };\n  })(),\n\n  /**\n   * Create or update line to give raycaster visual representation.\n   * Customize the line through through line component.\n   * We draw the line in the raycaster component to customize the line to the\n   * raycaster's origin, direction, and far.\n   *\n   * Unlike the raycaster, we create the line as a child of the object. The line will\n   * be affected by the transforms of the objects, so we don't have to calculate transforms\n   * like we do with the raycaster.\n   *\n   * @param {number} length - Length of line. Pass in to shorten the line to the intersection\n   *   point. If not provided, length will default to the max length, `raycaster.far`.\n   */\n  drawLine: function (length) {\n    var data = this.data;\n    var el = this.el;\n    var endVec3;\n\n    // Switch each time vector so line update triggered and to avoid unnecessary vector clone.\n    endVec3 = this.lineData.end === this.lineEndVec3\n      ? this.otherLineEndVec3\n      : this.lineEndVec3;\n\n    // Treat Infinity as 1000m for the line.\n    if (length === undefined) {\n      length = data.far === Infinity ? 1000 : data.far;\n    }\n\n    // Update the length of the line if given. `unitLineEndVec3` is the direction\n    // given by data.direction, then we apply a scalar to give it a length.\n    this.lineData.start = data.origin;\n    this.lineData.end = endVec3.copy(this.unitLineEndVec3).multiplyScalar(length);\n    el.setAttribute('line', this.lineData);\n  },\n\n  /**\n   * Return A-Frame attachments of each element's object3D group (e.g., mesh).\n   * Children are flattened by one level, removing the THREE.Group wrapper,\n   * so that non-recursive raycasting remains useful.\n   *\n   * Only push children defined as component attachemnts (e.g., setObject3D),\n   * NOT actual children in the scene graph hierarchy.\n   *\n   * @param  {Array<Element>} els\n   * @return {Array<THREE.Object3D>}\n   */\n  flattenObject3DMaps: function (els) {\n    var key;\n    var i;\n    var objects = this.objects;\n\n    // Push meshes and other attachments onto list of objects to intersect.\n    objects.length = 0;\n    for (i = 0; i < els.length; i++) {\n      if (els[i].isEntity && els[i].object3D) {\n        for (key in els[i].object3DMap) {\n          objects.push(els[i].getObject3D(key));\n        }\n      }\n    }\n\n    return objects;\n  },\n\n  clearAllIntersections: function () {\n    var i;\n    for (i = 0; i < this.intersectedEls.length; i++) {\n      this.intersectedEls[i].emit(EVENTS.INTERSECT_CLEAR,\n                                  this.intersectedClearedDetail);\n    }\n    copyArray(this.clearedIntersectedEls, this.intersectedEls);\n    this.intersectedEls.length = 0;\n    this.intersections.length = 0;\n    this.el.emit(EVENTS.INTERSECTION_CLEAR, this.intersectionClearedDetail);\n  }\n});\n\n/**\n * Copy contents of one array to another without allocating new array.\n */\nfunction copyArray (a, b) {\n  var i;\n  a.length = b.length;\n  for (i = 0; i < b.length; i++) {\n    a[i] = b[i];\n  }\n}\n"]},"metadata":{},"sourceType":"script"}