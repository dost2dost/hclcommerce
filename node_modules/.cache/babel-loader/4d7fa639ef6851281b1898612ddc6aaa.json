{"ast":null,"code":"import _slicedToArray from \"F:\\\\_HCLCommece\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b;\n\nimport { Cache, EventDispatcher, GammaEncoding, NearestFilter, PMREMGenerator, RGBEEncoding, TextureLoader } from 'three';\nimport { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader.js';\nimport EnvironmentScene from './EnvironmentScene.js';\nconst GENERATED_SIGMA = 0.04; // Enable three's loader cache so we don't create redundant\n// Image objects to decode images fetched over the network.\n\nCache.enabled = true;\nconst HDR_FILE_RE = /\\.hdr$/;\nconst ldrLoader = new TextureLoader();\nconst hdrLoader = new RGBELoader();\nconst $environmentMapCache = Symbol('environmentMapCache');\nconst $generatedEnvironmentMap = Symbol('generatedEnvironmentMap');\nconst $PMREMGenerator = Symbol('PMREMGenerator');\nconst $addMetadata = Symbol('addMetadata');\nconst $loadEnvironmentMapFromUrl = Symbol('loadEnvironmentMapFromUrl');\nconst $loadGeneratedEnvironmentMap = Symbol('loadGeneratedEnvironmentMap'); // Attach a `userData` object for arbitrary data on textures that\n// originate from TextureUtils, similar to Object3D's userData,\n// for help debugging, providing metadata for tests, and semantically\n// describe the type of texture within the context of this application.\n\nconst userData = {\n  url: null,\n  // 'Equirectangular', 'CubeUV', 'PMREM'\n  mapping: null\n};\nexport default class TextureUtils extends EventDispatcher {\n  constructor(threeRenderer) {\n    super();\n    this[_a] = null;\n    this[_b] = new Map();\n    this[$PMREMGenerator] = new PMREMGenerator(threeRenderer);\n  }\n\n  get pmremGenerator() {\n    return this[$PMREMGenerator];\n  }\n\n  async load(url, progressCallback = () => {}) {\n    try {\n      this[$PMREMGenerator].compileEquirectangularShader();\n      const isHDR = HDR_FILE_RE.test(url);\n      const loader = isHDR ? hdrLoader : ldrLoader;\n      const texture = await new Promise((resolve, reject) => loader.load(url, resolve, event => {\n        progressCallback(event.loaded / event.total * 0.9);\n      }, reject));\n      progressCallback(1.0);\n      this[$addMetadata](texture, url, 'Equirectangular');\n\n      if (isHDR) {\n        texture.encoding = RGBEEncoding;\n        texture.minFilter = NearestFilter;\n        texture.magFilter = NearestFilter;\n        texture.flipY = true;\n      } else {\n        texture.encoding = GammaEncoding;\n      }\n\n      return texture;\n    } finally {\n      if (progressCallback) {\n        progressCallback(1);\n      }\n    }\n  }\n\n  async loadEquirectAsCubeUV(url, progressCallback = () => {}) {\n    let equirect = null;\n\n    try {\n      equirect = await this.load(url, progressCallback);\n      const cubeUV = this[$PMREMGenerator].fromEquirectangular(equirect);\n      this[$addMetadata](cubeUV.texture, url, 'CubeUV');\n      return cubeUV;\n    } finally {\n      if (equirect != null) {\n        equirect.dispose();\n      }\n    }\n  }\n  /**\n   * Returns a { skybox, environmentMap } object with the targets/textures\n   * accordingly. `skybox` is a WebGLRenderCubeTarget, and `environmentMap`\n   * is a Texture from a WebGLRenderCubeTarget.\n   */\n\n\n  async generateEnvironmentMapAndSkybox(skyboxUrl = null, environmentMapUrl = null, options = {}) {\n    const progressTracker = options.progressTracker;\n    const updateGenerationProgress = progressTracker != null ? progressTracker.beginActivity() : () => {};\n\n    try {\n      let skyboxLoads = Promise.resolve(null);\n      let environmentMapLoads; // If we have a skybox URL, attempt to load it as a cubemap\n\n      if (!!skyboxUrl) {\n        skyboxLoads = this[$loadEnvironmentMapFromUrl](skyboxUrl, progressTracker);\n      }\n\n      if (!!environmentMapUrl) {\n        // We have an available environment map URL\n        environmentMapLoads = this[$loadEnvironmentMapFromUrl](environmentMapUrl, progressTracker);\n      } else if (!!skyboxUrl) {\n        // Fallback to deriving the environment map from an available skybox\n        environmentMapLoads = skyboxLoads;\n      } else {\n        // Fallback to generating the environment map\n        environmentMapLoads = this[$loadGeneratedEnvironmentMap]();\n      }\n\n      let _ref = await Promise.all([environmentMapLoads, skyboxLoads]),\n          _ref2 = _slicedToArray(_ref, 2),\n          environmentMap = _ref2[0],\n          skybox = _ref2[1];\n\n      if (environmentMap == null) {\n        throw new Error('Failed to load environment map.');\n      }\n\n      environmentMap = environmentMap;\n      this[$addMetadata](environmentMap.texture, environmentMapUrl, 'PMREM');\n\n      if (skybox != null) {\n        this[$addMetadata](skybox.texture, skyboxUrl, 'PMREM');\n      }\n\n      return {\n        environmentMap,\n        skybox\n      };\n    } finally {\n      updateGenerationProgress(1.0);\n    }\n  }\n\n  [(_a = $generatedEnvironmentMap, _b = $environmentMapCache, $addMetadata)](texture, url, mapping) {\n    if (texture == null) {\n      return;\n    }\n\n    texture.userData = Object.assign(Object.assign({}, userData), {\n      url: url,\n      mapping: mapping\n    });\n  }\n  /**\n   * Loads a WebGLRenderTarget from a given URL. The render target in this\n   * case will be assumed to be used as an environment map.\n   */\n\n\n  [$loadEnvironmentMapFromUrl](url, progressTracker) {\n    if (!this[$environmentMapCache].has(url)) {\n      const progressCallback = progressTracker ? progressTracker.beginActivity() : () => {};\n      const environmentMapLoads = this.loadEquirectAsCubeUV(url, progressCallback);\n      this[$environmentMapCache].set(url, environmentMapLoads);\n    }\n\n    return this[$environmentMapCache].get(url);\n  }\n  /**\n   * Loads a dynamically generated environment map.\n   */\n\n\n  [$loadGeneratedEnvironmentMap]() {\n    if (this[$generatedEnvironmentMap] == null) {\n      const defaultScene = new EnvironmentScene();\n      this[$generatedEnvironmentMap] = this[$PMREMGenerator].fromScene(defaultScene, GENERATED_SIGMA);\n      defaultScene.dispose();\n    }\n\n    return Promise.resolve(this[$generatedEnvironmentMap]);\n  }\n\n  async dispose() {\n    const allTargetsLoad = []; // NOTE(cdata): We would use for-of iteration on the maps here, but\n    // IE11 doesn't have the necessary iterator-returning methods. So,\n    // disposal of these render targets is kind of convoluted as a result.\n\n    this[$environmentMapCache].forEach(targetLoads => {\n      allTargetsLoad.push(targetLoads);\n    });\n    this[$environmentMapCache].clear();\n\n    for (const targetLoads of allTargetsLoad) {\n      try {\n        const target = await targetLoads;\n        target.dispose();\n      } catch (e) {// Suppress errors, so that all render targets will be disposed\n      }\n    }\n\n    if (this[$generatedEnvironmentMap] != null) {\n      this[$generatedEnvironmentMap].dispose();\n      this[$generatedEnvironmentMap] = null;\n    }\n  }\n\n}","map":{"version":3,"sources":["../../src/three-components/TextureUtils.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Cache, DataTextureLoader, EventDispatcher, GammaEncoding, NearestFilter, PMREMGenerator, RGBEEncoding, Texture, TextureLoader, WebGLRenderer, WebGLRenderTarget} from 'three';\nimport {RGBELoader} from 'three/examples/jsm/loaders/RGBELoader.js';\n\nimport {ProgressTracker} from '../utilities/progress-tracker.js';\nimport EnvironmentScene from './EnvironmentScene.js';\n\nexport interface EnvironmentMapAndSkybox {\n  environmentMap: WebGLRenderTarget;\n  skybox: WebGLRenderTarget|null;\n}\n\nexport interface EnvironmentGenerationConfig {\n  progressTracker?: ProgressTracker;\n}\n\nconst GENERATED_SIGMA = 0.04;\n\n// Enable three's loader cache so we don't create redundant\n// Image objects to decode images fetched over the network.\nCache.enabled = true;\n\nconst HDR_FILE_RE = /\\.hdr$/;\nconst ldrLoader = new TextureLoader();\nconst hdrLoader = new RGBELoader();\n\nconst $environmentMapCache = Symbol('environmentMapCache');\nconst $generatedEnvironmentMap = Symbol('generatedEnvironmentMap');\nconst $PMREMGenerator = Symbol('PMREMGenerator');\n\nconst $addMetadata = Symbol('addMetadata');\nconst $loadEnvironmentMapFromUrl = Symbol('loadEnvironmentMapFromUrl');\nconst $loadGeneratedEnvironmentMap = Symbol('loadGeneratedEnvironmentMap');\n\n// Attach a `userData` object for arbitrary data on textures that\n// originate from TextureUtils, similar to Object3D's userData,\n// for help debugging, providing metadata for tests, and semantically\n// describe the type of texture within the context of this application.\nconst userData = {\n  url: null,\n  // 'Equirectangular', 'CubeUV', 'PMREM'\n  mapping: null,\n};\n\nexport default class TextureUtils extends EventDispatcher {\n  get pmremGenerator() {\n    return this[$PMREMGenerator];\n  }\n\n  private[$generatedEnvironmentMap]: WebGLRenderTarget|null = null;\n  private[$PMREMGenerator]: PMREMGenerator;\n\n  private[$environmentMapCache] = new Map<string, Promise<WebGLRenderTarget>>();\n\n  constructor(threeRenderer: WebGLRenderer) {\n    super();\n    this[$PMREMGenerator] = new PMREMGenerator(threeRenderer);\n  }\n\n  async load(\n      url: string, progressCallback: (progress: number) => void = () => {}):\n      Promise<Texture> {\n    try {\n      this[$PMREMGenerator].compileEquirectangularShader();\n      const isHDR: boolean = HDR_FILE_RE.test(url);\n      const loader: DataTextureLoader = isHDR ? hdrLoader : ldrLoader;\n      const texture: Texture = await new Promise<Texture>(\n          (resolve, reject) => loader.load(\n              url, resolve, (event: {loaded: number, total: number}) => {\n                progressCallback(event.loaded / event.total * 0.9);\n              }, reject));\n\n      progressCallback(1.0);\n\n      this[$addMetadata](texture, url, 'Equirectangular');\n\n      if (isHDR) {\n        texture.encoding = RGBEEncoding;\n        texture.minFilter = NearestFilter;\n        texture.magFilter = NearestFilter;\n        texture.flipY = true;\n      } else {\n        texture.encoding = GammaEncoding;\n      }\n\n      return texture;\n\n    } finally {\n      if (progressCallback) {\n        progressCallback(1);\n      }\n    }\n  }\n\n  async loadEquirectAsCubeUV(\n      url: string, progressCallback: (progress: number) => void = () => {}):\n      Promise<WebGLRenderTarget> {\n    let equirect = null;\n\n    try {\n      equirect = await this.load(url, progressCallback);\n      const cubeUV = this[$PMREMGenerator].fromEquirectangular(equirect);\n      this[$addMetadata](cubeUV.texture, url, 'CubeUV');\n      return cubeUV;\n    } finally {\n      if (equirect != null) {\n        (equirect as any).dispose();\n      }\n    }\n  }\n\n  /**\n   * Returns a { skybox, environmentMap } object with the targets/textures\n   * accordingly. `skybox` is a WebGLRenderCubeTarget, and `environmentMap`\n   * is a Texture from a WebGLRenderCubeTarget.\n   */\n  async generateEnvironmentMapAndSkybox(\n      skyboxUrl: string|null = null, environmentMapUrl: string|null = null,\n      options: EnvironmentGenerationConfig = {}):\n      Promise<EnvironmentMapAndSkybox> {\n    const {progressTracker} = options;\n    const updateGenerationProgress =\n        progressTracker != null ? progressTracker.beginActivity() : () => {};\n\n    try {\n      let skyboxLoads: Promise<WebGLRenderTarget|null> = Promise.resolve(null);\n      let environmentMapLoads: Promise<WebGLRenderTarget>;\n\n      // If we have a skybox URL, attempt to load it as a cubemap\n      if (!!skyboxUrl) {\n        skyboxLoads =\n            this[$loadEnvironmentMapFromUrl](skyboxUrl, progressTracker);\n      }\n\n      if (!!environmentMapUrl) {\n        // We have an available environment map URL\n        environmentMapLoads = this[$loadEnvironmentMapFromUrl](\n            environmentMapUrl, progressTracker);\n      } else if (!!skyboxUrl) {\n        // Fallback to deriving the environment map from an available skybox\n        environmentMapLoads = skyboxLoads as Promise<WebGLRenderTarget>;\n      } else {\n        // Fallback to generating the environment map\n        environmentMapLoads = this[$loadGeneratedEnvironmentMap]();\n      }\n\n      let [environmentMap, skybox] =\n          await Promise.all([environmentMapLoads, skyboxLoads]);\n\n      if (environmentMap == null) {\n        throw new Error('Failed to load environment map.');\n      }\n\n      environmentMap = environmentMap!;\n\n      this[$addMetadata](environmentMap.texture, environmentMapUrl, 'PMREM');\n      if (skybox != null) {\n        this[$addMetadata](skybox.texture, skyboxUrl, 'PMREM');\n      }\n\n\n      return {environmentMap, skybox};\n    } finally {\n      updateGenerationProgress(1.0);\n    }\n  }\n\n  private[$addMetadata](\n      texture: Texture|null, url: string|null, mapping: string) {\n    if (texture == null) {\n      return;\n    }\n    (texture as any).userData = {\n      ...userData,\n      ...({\n        url: url,\n        mapping: mapping,\n      })\n    };\n  }\n\n  /**\n   * Loads a WebGLRenderTarget from a given URL. The render target in this\n   * case will be assumed to be used as an environment map.\n   */\n  private[$loadEnvironmentMapFromUrl](\n      url: string,\n      progressTracker?: ProgressTracker): Promise<WebGLRenderTarget> {\n    if (!this[$environmentMapCache].has(url)) {\n      const progressCallback =\n          progressTracker ? progressTracker.beginActivity() : () => {};\n      const environmentMapLoads =\n          this.loadEquirectAsCubeUV(url, progressCallback);\n\n      this[$environmentMapCache].set(url, environmentMapLoads);\n    }\n\n    return this[$environmentMapCache].get(url)!;\n  }\n\n  /**\n   * Loads a dynamically generated environment map.\n   */\n  private[$loadGeneratedEnvironmentMap](): Promise<WebGLRenderTarget> {\n    if (this[$generatedEnvironmentMap] == null) {\n      const defaultScene = new EnvironmentScene;\n      this[$generatedEnvironmentMap] =\n          this[$PMREMGenerator].fromScene(defaultScene, GENERATED_SIGMA);\n      defaultScene.dispose();\n    }\n\n    return Promise.resolve(this[$generatedEnvironmentMap]!);\n  }\n\n  async dispose() {\n    const allTargetsLoad: Array<Promise<WebGLRenderTarget>> = [];\n\n    // NOTE(cdata): We would use for-of iteration on the maps here, but\n    // IE11 doesn't have the necessary iterator-returning methods. So,\n    // disposal of these render targets is kind of convoluted as a result.\n\n    this[$environmentMapCache].forEach((targetLoads) => {\n      allTargetsLoad.push(targetLoads);\n    });\n\n    this[$environmentMapCache].clear();\n\n    for (const targetLoads of allTargetsLoad) {\n      try {\n        const target = await targetLoads;\n        target.dispose();\n      } catch (e) {\n        // Suppress errors, so that all render targets will be disposed\n      }\n    }\n\n    if (this[$generatedEnvironmentMap] != null) {\n      this[$generatedEnvironmentMap]!.dispose();\n      this[$generatedEnvironmentMap] = null;\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}