{"ast":null,"code":"var ANode = require('./a-node');\n\nvar COMPONENTS = require('./component').components;\n\nvar registerElement = require('./a-register-element').registerElement;\n\nvar THREE = require('../lib/three');\n\nvar utils = require('../utils/');\n\nvar AEntity;\nvar debug = utils.debug('core:a-entity:debug');\nvar warn = utils.debug('core:a-entity:warn');\nvar MULTIPLE_COMPONENT_DELIMITER = '__';\nvar OBJECT3D_COMPONENTS = ['position', 'rotation', 'scale', 'visible'];\nvar ONCE = {\n  once: true\n};\n/**\n * Entity is a container object that components are plugged into to comprise everything in\n * the scene. In A-Frame, they inherently have position, rotation, and scale.\n *\n * To be able to take components, the scene element inherits from the entity definition.\n *\n * @member {object} components - entity's currently initialized components.\n * @member {object} object3D - three.js object.\n * @member {array} states\n * @member {boolean} isPlaying - false if dynamic behavior of the entity is paused.\n */\n\nvar proto = Object.create(ANode.prototype, {\n  createdCallback: {\n    value: function () {\n      this.components = {}; // To avoid double initializations and infinite loops.\n\n      this.initializingComponents = {};\n      this.componentsToUpdate = {};\n      this.isEntity = true;\n      this.isPlaying = false;\n      this.object3D = new THREE.Group();\n      this.object3D.el = this;\n      this.object3DMap = {};\n      this.parentEl = null;\n      this.rotationObj = {};\n      this.states = [];\n    }\n  },\n\n  /**\n   * Handle changes coming from the browser DOM inspector.\n   */\n  attributeChangedCallback: {\n    value: function (attr, oldVal, newVal) {\n      var component = this.components[attr]; // If the empty string is passed by the component initialization\n      // logic we ignore the component update.\n\n      if (component && component.justInitialized && newVal === '') {\n        delete component.justInitialized;\n        return;\n      } // When a component is removed after calling el.removeAttribute('material')\n\n\n      if (!component && newVal === null) {\n        return;\n      }\n\n      this.setEntityAttribute(attr, oldVal, newVal);\n    }\n  },\n\n  /**\n   * Add to parent, load, play.\n   */\n  attachedCallback: {\n    value: function () {\n      var assetsEl; // Asset management system element.\n\n      var sceneEl = this.sceneEl;\n      var self = this; // Component.\n\n      this.addToParent(); // Don't .load() scene on attachedCallback.\n\n      if (this.isScene) {\n        return;\n      } // Gracefully not error when outside of <a-scene> (e.g., tests).\n\n\n      if (!sceneEl) {\n        this.load();\n        return;\n      } // Wait for asset management system to finish before loading.\n\n\n      assetsEl = sceneEl.querySelector('a-assets');\n\n      if (assetsEl && !assetsEl.hasLoaded) {\n        assetsEl.addEventListener('loaded', function () {\n          self.load();\n        });\n        return;\n      }\n\n      this.load();\n    }\n  },\n\n  /**\n   * Tell parent to remove this element's object3D from its object3D.\n   * Do not call on scene element because that will cause a call to document.body.remove().\n   */\n  detachedCallback: {\n    value: function () {\n      var componentName;\n\n      if (!this.parentEl) {\n        return;\n      } // Remove components.\n\n\n      for (componentName in this.components) {\n        this.removeComponent(componentName, false);\n      }\n\n      if (this.isScene) {\n        return;\n      }\n\n      this.removeFromParent();\n      ANode.prototype.detachedCallback.call(this); // Remove cyclic reference.\n\n      this.object3D.el = null;\n    }\n  },\n  getObject3D: {\n    value: function (type) {\n      return this.object3DMap[type];\n    }\n  },\n\n  /**\n   * Set a THREE.Object3D into the map.\n   *\n   * @param {string} type - Developer-set name of the type of object, will be unique per type.\n   * @param {object} obj - A THREE.Object3D.\n   */\n  setObject3D: {\n    value: function (type, obj) {\n      var oldObj;\n      var self = this;\n\n      if (!(obj instanceof THREE.Object3D)) {\n        throw new Error('`Entity.setObject3D` was called with an object that was not an instance of ' + 'THREE.Object3D.');\n      } // Remove existing object of the type.\n\n\n      oldObj = this.getObject3D(type);\n\n      if (oldObj) {\n        this.object3D.remove(oldObj);\n      } // Set references to A-Frame entity.\n\n\n      obj.el = this;\n\n      if (obj.children.length) {\n        obj.traverse(function bindEl(child) {\n          child.el = self;\n        });\n      } // Add.\n\n\n      this.object3D.add(obj);\n      this.object3DMap[type] = obj;\n      this.emit('object3dset', {\n        object: obj,\n        type: type\n      });\n    }\n  },\n\n  /**\n   * Remove object from scene and entity object3D map.\n   */\n  removeObject3D: {\n    value: function (type) {\n      var obj = this.getObject3D(type);\n\n      if (!obj) {\n        warn('Tried to remove `Object3D` of type:', type, 'which was not defined.');\n        return;\n      }\n\n      this.object3D.remove(obj);\n      delete this.object3DMap[type];\n      this.emit('object3dremove', {\n        type: type\n      });\n    }\n  },\n\n  /**\n   * Gets or creates an object3D of a given type.\n   *\n   * @param {string} type - Type of the object3D.\n   * @param {string} Constructor - Constructor to use to create the object3D if needed.\n   * @returns {object}\n   */\n  getOrCreateObject3D: {\n    value: function (type, Constructor) {\n      var object3D = this.getObject3D(type);\n\n      if (!object3D && Constructor) {\n        object3D = new Constructor();\n        this.setObject3D(type, object3D);\n      }\n\n      warn('`getOrCreateObject3D` has been deprecated. Use `setObject3D()` ' + 'and `object3dset` event instead.');\n      return object3D;\n    }\n  },\n\n  /**\n   * Add child entity.\n   *\n   * @param {Element} el - Child entity.\n   */\n  add: {\n    value: function (el) {\n      if (!el.object3D) {\n        throw new Error(\"Trying to add an element that doesn't have an `object3D`\");\n      }\n\n      this.object3D.add(el.object3D);\n      this.emit('child-attached', {\n        el: el\n      });\n    }\n  },\n\n  /**\n   * Tell parentNode to add this entity to itself.\n   */\n  addToParent: {\n    value: function () {\n      var parentNode = this.parentEl = this.parentNode; // `!parentNode` check primarily for unit tests.\n\n      if (!parentNode || !parentNode.add || this.attachedToParent) {\n        return;\n      }\n\n      parentNode.add(this);\n      this.attachedToParent = true; // To prevent multiple attachments to same parent.\n    }\n  },\n\n  /**\n   * Tell parentNode to remove this entity from itself.\n   */\n  removeFromParent: {\n    value: function () {\n      var parentEl = this.parentEl;\n      this.parentEl.remove(this);\n      this.attachedToParent = false;\n      this.parentEl = null;\n      parentEl.emit('child-detached', {\n        el: this\n      });\n    }\n  },\n  load: {\n    value: function () {\n      var self = this;\n\n      if (this.hasLoaded || !this.parentEl) {\n        return;\n      }\n\n      ANode.prototype.load.call(this, function entityLoadCallback() {\n        // Check if entity was detached while it was waiting to load.\n        if (!self.parentEl) {\n          return;\n        }\n\n        self.updateComponents();\n\n        if (self.isScene || self.parentEl.isPlaying) {\n          self.play();\n        }\n      });\n    },\n    writable: window.debug\n  },\n\n  /**\n   * Remove child entity.\n   *\n   * @param {Element} el - Child entity.\n   */\n  remove: {\n    value: function (el) {\n      if (el) {\n        this.object3D.remove(el.object3D);\n      } else {\n        this.parentNode.removeChild(this);\n      }\n    }\n  },\n\n  /**\n   * @returns {array} Direct children that are entities.\n   */\n  getChildEntities: {\n    value: function () {\n      var children = this.children;\n      var childEntities = [];\n\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n\n        if (child instanceof AEntity) {\n          childEntities.push(child);\n        }\n      }\n\n      return childEntities;\n    }\n  },\n\n  /**\n   * Initialize component.\n   *\n   * @param {string} attrName - Attribute name asociated to the component.\n   * @param {object} data - Component data\n   * @param {boolean} isDependency - True if the component is a dependency.\n   */\n  initComponent: {\n    value: function (attrName, data, isDependency) {\n      var component;\n      var componentId;\n      var componentInfo;\n      var componentName;\n      var isComponentDefined;\n      componentInfo = utils.split(attrName, MULTIPLE_COMPONENT_DELIMITER);\n      componentName = componentInfo[0];\n      componentId = componentInfo.length > 2 ? componentInfo.slice(1).join('__') : componentInfo[1]; // Not a registered component.\n\n      if (!COMPONENTS[componentName]) {\n        return;\n      } // Component is not a dependency and is undefined.\n      // If a component is a dependency, then it is okay to have no data.\n\n\n      isComponentDefined = checkComponentDefined(this, attrName) || data !== undefined;\n\n      if (!isComponentDefined && !isDependency) {\n        return;\n      } // Component already initialized.\n\n\n      if (attrName in this.components) {\n        return;\n      } // Initialize dependencies first\n\n\n      this.initComponentDependencies(componentName); // If component name has an id we check component type multiplic\n\n      if (componentId && !COMPONENTS[componentName].multiple) {\n        throw new Error('Trying to initialize multiple ' + 'components of type `' + componentName + '`. There can only be one component of this type per entity.');\n      }\n\n      component = new COMPONENTS[componentName].Component(this, data, componentId);\n\n      if (this.isPlaying) {\n        component.play();\n      } // Components are reflected in the DOM as attributes but the state is not shown\n      // hence we set the attribute to empty string.\n      // The flag justInitialized is for attributeChangedCallback to not overwrite\n      // the component with the empty string.\n\n\n      if (!this.hasAttribute(attrName)) {\n        component.justInitialized = true;\n        window.HTMLElement.prototype.setAttribute.call(this, attrName, '');\n      }\n\n      debug('Component initialized: %s', attrName);\n    },\n    writable: window.debug\n  },\n\n  /**\n   * Initialize dependencies of a component.\n   *\n   * @param {string} name - Root component name.\n   */\n  initComponentDependencies: {\n    value: function (name) {\n      var self = this;\n      var component = COMPONENTS[name];\n      var dependencies;\n      var i; // Not a component.\n\n      if (!component) {\n        return;\n      } // No dependencies.\n\n\n      dependencies = COMPONENTS[name].dependencies;\n\n      if (!dependencies) {\n        return;\n      } // Initialize dependencies.\n\n\n      for (i = 0; i < dependencies.length; i++) {\n        // Call getAttribute to initialize the data from the DOM.\n        self.initComponent(dependencies[i], window.HTMLElement.prototype.getAttribute.call(self, dependencies[i]) || undefined, true);\n      }\n    }\n  },\n  removeComponent: {\n    value: function (name, destroy) {\n      var component;\n      component = this.components[name];\n\n      if (!component) {\n        return;\n      } // Wait for component to initialize.\n\n\n      if (!component.initialized) {\n        this.addEventListener('componentinitialized', function tryRemoveLater(evt) {\n          if (evt.detail.name !== name) {\n            return;\n          }\n\n          this.removeComponent(name, destroy);\n          this.removeEventListener('componentinitialized', tryRemoveLater);\n        });\n        return;\n      }\n\n      component.pause();\n      component.remove(); // Keep component attached to entity in case of just full entity detach.\n\n      if (destroy) {\n        component.destroy();\n        delete this.components[name];\n      }\n\n      this.emit('componentremoved', component.evtDetail, false);\n    },\n    writable: window.debug\n  },\n\n  /**\n   * Initialize or update all components.\n   * Build data using initial components, defined attributes, mixins, and defaults.\n   * Update default components before the rest.\n   *\n   * @member {function} getExtraComponents - Can be implemented to include component data\n   *   from other sources (e.g., implemented by primitives).\n   */\n  updateComponents: {\n    value: function () {\n      var data;\n      var extraComponents;\n      var i;\n      var name;\n      var componentsToUpdate = this.componentsToUpdate;\n\n      if (!this.hasLoaded) {\n        return;\n      } // Gather mixin-defined components.\n\n\n      for (i = 0; i < this.mixinEls.length; i++) {\n        for (name in this.mixinEls[i].componentCache) {\n          if (isComponent(name)) {\n            componentsToUpdate[name] = true;\n          }\n        }\n      } // Gather from extra initial component data if defined (e.g., primitives).\n\n\n      if (this.getExtraComponents) {\n        extraComponents = this.getExtraComponents();\n\n        for (name in extraComponents) {\n          if (isComponent(name)) {\n            componentsToUpdate[name] = true;\n          }\n        }\n      } // Gather entity-defined components.\n\n\n      for (i = 0; i < this.attributes.length; ++i) {\n        name = this.attributes[i].name;\n\n        if (OBJECT3D_COMPONENTS.indexOf(name) !== -1) {\n          continue;\n        }\n\n        if (isComponent(name)) {\n          componentsToUpdate[name] = true;\n        }\n      } // object3D components first (position, rotation, scale, visible).\n\n\n      for (i = 0; i < OBJECT3D_COMPONENTS.length; i++) {\n        name = OBJECT3D_COMPONENTS[i];\n\n        if (!this.hasAttribute(name)) {\n          continue;\n        }\n\n        this.updateComponent(name, this.getDOMAttribute(name));\n      } // Initialize or update rest of components.\n\n\n      for (name in componentsToUpdate) {\n        data = mergeComponentData(this.getDOMAttribute(name), extraComponents && extraComponents[name]);\n        this.updateComponent(name, data);\n        delete componentsToUpdate[name];\n      }\n    },\n    writable: window.debug\n  },\n\n  /**\n   * Initialize, update, or remove a single component.\n   *\n   * When initializing, we set the component on `this.components`.\n   *\n   * @param {string} attr - Component name.\n   * @param {object} attrValue - Value of the DOM attribute.\n   * @param {boolean} clobber - If new attrValue completely replaces previous properties.\n   */\n  updateComponent: {\n    value: function (attr, attrValue, clobber) {\n      var component = this.components[attr];\n\n      if (component) {\n        // Remove component.\n        if (attrValue === null && !checkComponentDefined(this, attr)) {\n          this.removeComponent(attr, true);\n          return;\n        } // Component already initialized. Update component.\n\n\n        component.updateProperties(attrValue, clobber);\n        return;\n      } // Component not yet initialized. Initialize component.\n\n\n      this.initComponent(attr, attrValue, false);\n    }\n  },\n\n  /**\n   * If `attr` is a component name, detach the component from the entity.\n   *\n   * If `propertyName` is given, reset the component property value to its default.\n   *\n   * @param {string} attr - Attribute name, which could also be a component name.\n   * @param {string} propertyName - Component prop name, if resetting an individual prop.\n   */\n  removeAttribute: {\n    value: function (attr, propertyName) {\n      var component = this.components[attr]; // Remove component.\n\n      if (component && propertyName === undefined) {\n        this.removeComponent(attr, true);\n      } // Reset component property value.\n\n\n      if (component && propertyName !== undefined) {\n        component.resetProperty(propertyName);\n        return;\n      } // Remove mixins.\n\n\n      if (attr === 'mixin') {\n        this.mixinUpdate('');\n      }\n\n      window.HTMLElement.prototype.removeAttribute.call(this, attr);\n    }\n  },\n\n  /**\n   * Start dynamic behavior associated with entity such as dynamic components and animations.\n   * Tell all children entities to also play.\n   */\n  play: {\n    value: function () {\n      var entities;\n      var i;\n      var key; // Already playing.\n\n      if (this.isPlaying || !this.hasLoaded) {\n        return;\n      }\n\n      this.isPlaying = true; // Wake up all components.\n\n      for (key in this.components) {\n        this.components[key].play();\n      } // Tell all child entities to play.\n\n\n      entities = this.getChildEntities();\n\n      for (i = 0; i < entities.length; i++) {\n        entities[i].play();\n      }\n\n      this.emit('play');\n    },\n    writable: true\n  },\n\n  /**\n   * Pause dynamic behavior associated with entity such as dynamic components and animations.\n   * Tell all children entities to also pause.\n   */\n  pause: {\n    value: function () {\n      var entities;\n      var i;\n      var key;\n\n      if (!this.isPlaying) {\n        return;\n      }\n\n      this.isPlaying = false; // Sleep all components.\n\n      for (key in this.components) {\n        this.components[key].pause();\n      } // Tell all child entities to pause.\n\n\n      entities = this.getChildEntities();\n\n      for (i = 0; i < entities.length; i++) {\n        entities[i].pause();\n      }\n\n      this.emit('pause');\n    },\n    writable: true\n  },\n\n  /**\n   * Deals with updates on entity-specific attributes (i.e., components and mixins).\n   *\n   * @param {string} attr\n   * @param {string} oldVal\n   * @param {string|object} newVal\n   */\n  setEntityAttribute: {\n    value: function (attr, oldVal, newVal) {\n      if (COMPONENTS[attr] || this.components[attr]) {\n        this.updateComponent(attr, newVal);\n        return;\n      }\n\n      if (attr === 'mixin') {\n        // Ignore if `<a-node>` code is just updating computed mixin in the DOM.\n        if (newVal === this.computedMixinStr) {\n          return;\n        }\n\n        this.mixinUpdate(newVal, oldVal);\n      }\n    }\n  },\n\n  /**\n   * When mixins updated, trigger init or optimized-update of relevant components.\n   */\n  mixinUpdate: {\n    value: function () {\n      var componentsUpdated = [];\n      return function (newMixins, oldMixins) {\n        var component;\n        var mixinEl;\n        var mixinIds;\n        var i;\n        var self = this;\n\n        if (!this.hasLoaded) {\n          this.addEventListener('loaded', function () {\n            self.mixinUpdate(newMixins, oldMixins);\n          }, ONCE);\n          return;\n        }\n\n        oldMixins = oldMixins || this.getAttribute('mixin');\n        mixinIds = this.updateMixins(newMixins, oldMixins); // Loop over current mixins.\n\n        componentsUpdated.length = 0;\n\n        for (i = 0; i < this.mixinEls.length; i++) {\n          for (component in this.mixinEls[i].componentCache) {\n            if (componentsUpdated.indexOf(component) === -1) {\n              if (this.components[component]) {\n                // Update. Just rebuild data.\n                this.components[component].handleMixinUpdate();\n              } else {\n                // Init. buildData will gather mixin values.\n                this.initComponent(component, null);\n              }\n\n              componentsUpdated.push(component);\n            }\n          }\n        } // Loop over old mixins to call for data rebuild.\n\n\n        for (i = 0; i < mixinIds.oldMixinIds.length; i++) {\n          mixinEl = document.getElementById(mixinIds.oldMixinIds[i]);\n\n          if (!mixinEl) {\n            continue;\n          }\n\n          for (component in mixinEl.componentCache) {\n            if (componentsUpdated.indexOf(component) === -1) {\n              if (this.components[component]) {\n                if (this.getDOMAttribute(component)) {\n                  // Update component if explicitly defined.\n                  this.components[component].handleMixinUpdate();\n                } else {\n                  // Remove component if not explicitly defined.\n                  this.removeComponent(component, true);\n                }\n              }\n            }\n          }\n        }\n      };\n    }()\n  },\n\n  /**\n   * setAttribute can:\n   *\n   * 1. Set a single property of a multi-property component.\n   * 2. Set multiple properties of a multi-property component.\n   * 3. Replace properties of a multi-property component.\n   * 4. Set a value for a single-property component, mixin, or normal HTML attribute.\n   *\n   * @param {string} attrName - Component or attribute name.\n   * @param {*} arg1 - Can be a value, property name, CSS-style property string, or\n   *   object of properties.\n   * @param {*|bool} arg2 - If arg1 is a property name, this should be a value. Otherwise,\n   *   it is a boolean indicating whether to clobber previous values (defaults to false).\n   */\n  setAttribute: {\n    value: function () {\n      var singlePropUpdate = {};\n      return function (attrName, arg1, arg2) {\n        var newAttrValue;\n        var clobber;\n        var componentName;\n        var delimiterIndex;\n        var isDebugMode;\n        var key;\n        delimiterIndex = attrName.indexOf(MULTIPLE_COMPONENT_DELIMITER);\n        componentName = delimiterIndex > 0 ? attrName.substring(0, delimiterIndex) : attrName; // Not a component. Normal set attribute.\n\n        if (!COMPONENTS[componentName]) {\n          if (attrName === 'mixin') {\n            this.mixinUpdate(arg1);\n          }\n\n          ANode.prototype.setAttribute.call(this, attrName, arg1);\n          return;\n        } // Initialize component first if not yet initialized.\n\n\n        if (!this.components[attrName] && this.hasAttribute(attrName)) {\n          this.updateComponent(attrName, window.HTMLElement.prototype.getAttribute.call(this, attrName));\n        } // Determine new attributes from the arguments\n\n\n        if (typeof arg2 !== 'undefined' && typeof arg1 === 'string' && arg1.length > 0 && typeof utils.styleParser.parse(arg1) === 'string') {\n          // Update a single property of a multi-property component\n          for (key in singlePropUpdate) {\n            delete singlePropUpdate[key];\n          }\n\n          newAttrValue = singlePropUpdate;\n          newAttrValue[arg1] = arg2;\n          clobber = false;\n        } else {\n          // Update with a value, object, or CSS-style property string, with the possiblity\n          // of clobbering previous values.\n          newAttrValue = arg1;\n          clobber = arg2 === true;\n        } // Update component\n\n\n        this.updateComponent(attrName, newAttrValue, clobber); // In debug mode, write component data up to the DOM.\n\n        isDebugMode = this.sceneEl && this.sceneEl.getAttribute('debug');\n\n        if (isDebugMode) {\n          this.components[attrName].flushToDOM();\n        }\n      };\n    }(),\n    writable: window.debug\n  },\n\n  /**\n   * Reflect component data in the DOM (as seen from the browser DOM Inspector).\n   *\n   * @param {bool} recursive - Also flushToDOM on the children.\n   **/\n  flushToDOM: {\n    value: function (recursive) {\n      var components = this.components;\n      var child;\n      var children = this.children;\n      var i;\n      var key; // Flush entity's components to DOM.\n\n      for (key in components) {\n        components[key].flushToDOM();\n      } // Recurse.\n\n\n      if (!recursive) {\n        return;\n      }\n\n      for (i = 0; i < children.length; ++i) {\n        child = children[i];\n\n        if (!child.flushToDOM) {\n          continue;\n        }\n\n        child.flushToDOM(recursive);\n      }\n    }\n  },\n\n  /**\n   * If `attr` is a component, returns ALL component data including applied mixins and\n   * defaults.\n   *\n   * If `attr` is not a component, fall back to HTML getAttribute.\n   *\n   * @param {string} attr\n   * @returns {object|string} Object if component, else string.\n   */\n  getAttribute: {\n    value: function (attr) {\n      // If component, return component data.\n      var component;\n\n      if (attr === 'position') {\n        return this.object3D.position;\n      }\n\n      if (attr === 'rotation') {\n        return getRotation(this);\n      }\n\n      if (attr === 'scale') {\n        return this.object3D.scale;\n      }\n\n      if (attr === 'visible') {\n        return this.object3D.visible;\n      }\n\n      component = this.components[attr];\n\n      if (component) {\n        return component.data;\n      }\n\n      return window.HTMLElement.prototype.getAttribute.call(this, attr);\n    },\n    writable: window.debug\n  },\n\n  /**\n   * If `attr` is a component, returns JUST the component data defined on the entity.\n   * Like a partial version of `getComputedAttribute` as returned component data\n   * does not include applied mixins or defaults.\n   *\n   * If `attr` is not a component, fall back to HTML getAttribute.\n   *\n   * @param {string} attr\n   * @returns {object|string} Object if component, else string.\n   */\n  getDOMAttribute: {\n    value: function (attr) {\n      // If cached value exists, return partial component data.\n      var component = this.components[attr];\n\n      if (component) {\n        return component.attrValue;\n      }\n\n      return window.HTMLElement.prototype.getAttribute.call(this, attr);\n    },\n    writable: window.debug\n  },\n  addState: {\n    value: function (state) {\n      if (this.is(state)) {\n        return;\n      }\n\n      this.states.push(state);\n      this.emit('stateadded', state);\n    }\n  },\n  removeState: {\n    value: function (state) {\n      var stateIndex = this.states.indexOf(state);\n\n      if (stateIndex === -1) {\n        return;\n      }\n\n      this.states.splice(stateIndex, 1);\n      this.emit('stateremoved', state);\n    }\n  },\n\n  /**\n   * Checks if the element is in a given state. e.g. el.is('alive');\n   * @type {string} state - Name of the state we want to check\n   */\n  is: {\n    value: function (state) {\n      return this.states.indexOf(state) !== -1;\n    }\n  },\n\n  /**\n   * Open Inspector to this entity.\n   */\n  inspect: {\n    value: function () {\n      this.sceneEl.components.inspector.openInspector(this);\n    }\n  },\n\n  /**\n   * Clean up memory and return memory to object pools.\n   */\n  destroy: {\n    value: function () {\n      var key;\n\n      if (this.parentNode) {\n        warn('Entity can only be destroyed if detached from scenegraph.');\n        return;\n      }\n\n      for (key in this.components) {\n        this.components[key].destroy();\n      }\n    }\n  }\n});\n/**\n * Check if a component is *defined* for an entity, including defaults and mixins.\n * Does not check whether the component has been *initialized* for an entity.\n *\n * @param {string} el - Entity.\n * @param {string} name - Component name.\n * @returns {boolean}\n */\n\nfunction checkComponentDefined(el, name) {\n  // Check if element contains the component.\n  if (el.components[name] && el.components[name].attrValue) {\n    return true;\n  }\n\n  return isComponentMixedIn(name, el.mixinEls);\n}\n/**\n * Check if any mixins contains a component.\n *\n * @param {string} name - Component name.\n * @param {array} mixinEls - Array of <a-mixin>s.\n */\n\n\nfunction isComponentMixedIn(name, mixinEls) {\n  var i;\n  var inMixin = false;\n\n  for (i = 0; i < mixinEls.length; ++i) {\n    inMixin = mixinEls[i].hasAttribute(name);\n\n    if (inMixin) {\n      break;\n    }\n  }\n\n  return inMixin;\n}\n/**\n * Given entity defined value, merge in extra data if necessary.\n * Handle both single and multi-property components.\n *\n * @param {string} attrValue - Entity data.\n * @param extraData - Entity data from another source to merge in.\n */\n\n\nfunction mergeComponentData(attrValue, extraData) {\n  // Extra data not defined, just return attrValue.\n  if (!extraData) {\n    return attrValue;\n  } // Merge multi-property data.\n\n\n  if (extraData.constructor === Object) {\n    return utils.extend(extraData, utils.styleParser.parse(attrValue || {}));\n  } // Return data, precendence to the defined value.\n\n\n  return attrValue || extraData;\n}\n\nfunction isComponent(componentName) {\n  if (componentName.indexOf(MULTIPLE_COMPONENT_DELIMITER) !== -1) {\n    componentName = utils.split(componentName, MULTIPLE_COMPONENT_DELIMITER)[0];\n  }\n\n  if (!COMPONENTS[componentName]) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction getRotation(entityEl) {\n  var radToDeg = THREE.Math.radToDeg;\n  var rotation = entityEl.object3D.rotation;\n  var rotationObj = entityEl.rotationObj;\n  rotationObj.x = radToDeg(rotation.x);\n  rotationObj.y = radToDeg(rotation.y);\n  rotationObj.z = radToDeg(rotation.z);\n  return rotationObj;\n}\n\nAEntity = registerElement('a-entity', {\n  prototype: proto\n});\nmodule.exports = AEntity;","map":{"version":3,"sources":["C:/Users/Hannuri/Desktop/RoyalCyber/my-first-app/node_modules/aframe/src/core/a-entity.js"],"names":["ANode","require","COMPONENTS","components","registerElement","THREE","utils","AEntity","debug","warn","MULTIPLE_COMPONENT_DELIMITER","OBJECT3D_COMPONENTS","ONCE","once","proto","Object","create","prototype","createdCallback","value","initializingComponents","componentsToUpdate","isEntity","isPlaying","object3D","Group","el","object3DMap","parentEl","rotationObj","states","attributeChangedCallback","attr","oldVal","newVal","component","justInitialized","setEntityAttribute","attachedCallback","assetsEl","sceneEl","self","addToParent","isScene","load","querySelector","hasLoaded","addEventListener","detachedCallback","componentName","removeComponent","removeFromParent","call","getObject3D","type","setObject3D","obj","oldObj","Object3D","Error","remove","children","length","traverse","bindEl","child","add","emit","object","removeObject3D","getOrCreateObject3D","Constructor","parentNode","attachedToParent","entityLoadCallback","updateComponents","play","writable","window","removeChild","getChildEntities","childEntities","i","push","initComponent","attrName","data","isDependency","componentId","componentInfo","isComponentDefined","split","slice","join","checkComponentDefined","undefined","initComponentDependencies","multiple","Component","hasAttribute","HTMLElement","setAttribute","name","dependencies","getAttribute","destroy","initialized","tryRemoveLater","evt","detail","removeEventListener","pause","evtDetail","extraComponents","mixinEls","componentCache","isComponent","getExtraComponents","attributes","indexOf","updateComponent","getDOMAttribute","mergeComponentData","attrValue","clobber","updateProperties","removeAttribute","propertyName","resetProperty","mixinUpdate","entities","key","computedMixinStr","componentsUpdated","newMixins","oldMixins","mixinEl","mixinIds","updateMixins","handleMixinUpdate","oldMixinIds","document","getElementById","singlePropUpdate","arg1","arg2","newAttrValue","delimiterIndex","isDebugMode","substring","styleParser","parse","flushToDOM","recursive","position","getRotation","scale","visible","addState","state","is","removeState","stateIndex","splice","inspect","inspector","openInspector","isComponentMixedIn","inMixin","extraData","constructor","extend","entityEl","radToDeg","Math","rotation","x","y","z","module","exports"],"mappings":"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","sourcesContent":["var ANode = require('./a-node');\nvar COMPONENTS = require('./component').components;\nvar registerElement = require('./a-register-element').registerElement;\nvar THREE = require('../lib/three');\nvar utils = require('../utils/');\n\nvar AEntity;\nvar debug = utils.debug('core:a-entity:debug');\nvar warn = utils.debug('core:a-entity:warn');\n\nvar MULTIPLE_COMPONENT_DELIMITER = '__';\nvar OBJECT3D_COMPONENTS = ['position', 'rotation', 'scale', 'visible'];\nvar ONCE = {once: true};\n\n/**\n * Entity is a container object that components are plugged into to comprise everything in\n * the scene. In A-Frame, they inherently have position, rotation, and scale.\n *\n * To be able to take components, the scene element inherits from the entity definition.\n *\n * @member {object} components - entity's currently initialized components.\n * @member {object} object3D - three.js object.\n * @member {array} states\n * @member {boolean} isPlaying - false if dynamic behavior of the entity is paused.\n */\nvar proto = Object.create(ANode.prototype, {\n  createdCallback: {\n    value: function () {\n      this.components = {};\n      // To avoid double initializations and infinite loops.\n      this.initializingComponents = {};\n      this.componentsToUpdate = {};\n      this.isEntity = true;\n      this.isPlaying = false;\n      this.object3D = new THREE.Group();\n      this.object3D.el = this;\n      this.object3DMap = {};\n      this.parentEl = null;\n      this.rotationObj = {};\n      this.states = [];\n    }\n  },\n\n  /**\n   * Handle changes coming from the browser DOM inspector.\n   */\n  attributeChangedCallback: {\n    value: function (attr, oldVal, newVal) {\n      var component = this.components[attr];\n      // If the empty string is passed by the component initialization\n      // logic we ignore the component update.\n      if (component && component.justInitialized && newVal === '') {\n        delete component.justInitialized;\n        return;\n      }\n      // When a component is removed after calling el.removeAttribute('material')\n      if (!component && newVal === null) { return; }\n      this.setEntityAttribute(attr, oldVal, newVal);\n    }\n  },\n\n  /**\n   * Add to parent, load, play.\n   */\n  attachedCallback: {\n    value: function () {\n      var assetsEl;  // Asset management system element.\n      var sceneEl = this.sceneEl;\n      var self = this;  // Component.\n\n      this.addToParent();\n\n      // Don't .load() scene on attachedCallback.\n      if (this.isScene) { return; }\n\n      // Gracefully not error when outside of <a-scene> (e.g., tests).\n      if (!sceneEl) {\n        this.load();\n        return;\n      }\n\n      // Wait for asset management system to finish before loading.\n      assetsEl = sceneEl.querySelector('a-assets');\n      if (assetsEl && !assetsEl.hasLoaded) {\n        assetsEl.addEventListener('loaded', function () { self.load(); });\n        return;\n      }\n      this.load();\n    }\n  },\n\n  /**\n   * Tell parent to remove this element's object3D from its object3D.\n   * Do not call on scene element because that will cause a call to document.body.remove().\n   */\n  detachedCallback: {\n    value: function () {\n      var componentName;\n\n      if (!this.parentEl) { return; }\n\n      // Remove components.\n      for (componentName in this.components) {\n        this.removeComponent(componentName, false);\n      }\n\n      if (this.isScene) { return; }\n\n      this.removeFromParent();\n      ANode.prototype.detachedCallback.call(this);\n\n      // Remove cyclic reference.\n      this.object3D.el = null;\n    }\n  },\n\n  getObject3D: {\n    value: function (type) {\n      return this.object3DMap[type];\n    }\n  },\n\n  /**\n   * Set a THREE.Object3D into the map.\n   *\n   * @param {string} type - Developer-set name of the type of object, will be unique per type.\n   * @param {object} obj - A THREE.Object3D.\n   */\n  setObject3D: {\n    value: function (type, obj) {\n      var oldObj;\n      var self = this;\n\n      if (!(obj instanceof THREE.Object3D)) {\n        throw new Error(\n          '`Entity.setObject3D` was called with an object that was not an instance of ' +\n          'THREE.Object3D.'\n        );\n      }\n\n      // Remove existing object of the type.\n      oldObj = this.getObject3D(type);\n      if (oldObj) { this.object3D.remove(oldObj); }\n\n      // Set references to A-Frame entity.\n      obj.el = this;\n      if (obj.children.length) {\n        obj.traverse(function bindEl (child) {\n          child.el = self;\n        });\n      }\n\n      // Add.\n      this.object3D.add(obj);\n      this.object3DMap[type] = obj;\n      this.emit('object3dset', {object: obj, type: type});\n    }\n  },\n\n  /**\n   * Remove object from scene and entity object3D map.\n   */\n  removeObject3D: {\n    value: function (type) {\n      var obj = this.getObject3D(type);\n      if (!obj) {\n        warn('Tried to remove `Object3D` of type:', type, 'which was not defined.');\n        return;\n      }\n      this.object3D.remove(obj);\n      delete this.object3DMap[type];\n      this.emit('object3dremove', {type: type});\n    }\n  },\n\n  /**\n   * Gets or creates an object3D of a given type.\n   *\n   * @param {string} type - Type of the object3D.\n   * @param {string} Constructor - Constructor to use to create the object3D if needed.\n   * @returns {object}\n   */\n  getOrCreateObject3D: {\n    value: function (type, Constructor) {\n      var object3D = this.getObject3D(type);\n      if (!object3D && Constructor) {\n        object3D = new Constructor();\n        this.setObject3D(type, object3D);\n      }\n      warn('`getOrCreateObject3D` has been deprecated. Use `setObject3D()` ' +\n           'and `object3dset` event instead.');\n      return object3D;\n    }\n  },\n\n  /**\n   * Add child entity.\n   *\n   * @param {Element} el - Child entity.\n   */\n  add: {\n    value: function (el) {\n      if (!el.object3D) {\n        throw new Error(\"Trying to add an element that doesn't have an `object3D`\");\n      }\n      this.object3D.add(el.object3D);\n      this.emit('child-attached', {el: el});\n    }\n  },\n\n  /**\n   * Tell parentNode to add this entity to itself.\n   */\n  addToParent: {\n    value: function () {\n      var parentNode = this.parentEl = this.parentNode;\n\n      // `!parentNode` check primarily for unit tests.\n      if (!parentNode || !parentNode.add || this.attachedToParent) { return; }\n\n      parentNode.add(this);\n      this.attachedToParent = true;  // To prevent multiple attachments to same parent.\n    }\n  },\n\n  /**\n   * Tell parentNode to remove this entity from itself.\n   */\n  removeFromParent: {\n    value: function () {\n      var parentEl = this.parentEl;\n      this.parentEl.remove(this);\n      this.attachedToParent = false;\n      this.parentEl = null;\n      parentEl.emit('child-detached', {el: this});\n    }\n  },\n\n  load: {\n    value: function () {\n      var self = this;\n\n      if (this.hasLoaded || !this.parentEl) { return; }\n\n      ANode.prototype.load.call(this, function entityLoadCallback () {\n        // Check if entity was detached while it was waiting to load.\n        if (!self.parentEl) { return; }\n\n        self.updateComponents();\n        if (self.isScene || self.parentEl.isPlaying) { self.play(); }\n      });\n    },\n    writable: window.debug\n  },\n\n  /**\n   * Remove child entity.\n   *\n   * @param {Element} el - Child entity.\n   */\n  remove: {\n    value: function (el) {\n      if (el) {\n        this.object3D.remove(el.object3D);\n      } else {\n        this.parentNode.removeChild(this);\n      }\n    }\n  },\n\n  /**\n   * @returns {array} Direct children that are entities.\n   */\n  getChildEntities: {\n    value: function () {\n      var children = this.children;\n      var childEntities = [];\n\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i];\n        if (child instanceof AEntity) {\n          childEntities.push(child);\n        }\n      }\n\n      return childEntities;\n    }\n  },\n\n  /**\n   * Initialize component.\n   *\n   * @param {string} attrName - Attribute name asociated to the component.\n   * @param {object} data - Component data\n   * @param {boolean} isDependency - True if the component is a dependency.\n   */\n  initComponent: {\n    value: function (attrName, data, isDependency) {\n      var component;\n      var componentId;\n      var componentInfo;\n      var componentName;\n      var isComponentDefined;\n\n      componentInfo = utils.split(attrName, MULTIPLE_COMPONENT_DELIMITER);\n      componentName = componentInfo[0];\n      componentId = componentInfo.length > 2\n        ? componentInfo.slice(1).join('__')\n        : componentInfo[1];\n\n      // Not a registered component.\n      if (!COMPONENTS[componentName]) { return; }\n\n      // Component is not a dependency and is undefined.\n      // If a component is a dependency, then it is okay to have no data.\n      isComponentDefined = checkComponentDefined(this, attrName) ||\n                           data !== undefined;\n      if (!isComponentDefined && !isDependency) { return; }\n\n      // Component already initialized.\n      if (attrName in this.components) { return; }\n\n      // Initialize dependencies first\n      this.initComponentDependencies(componentName);\n\n      // If component name has an id we check component type multiplic\n      if (componentId && !COMPONENTS[componentName].multiple) {\n        throw new Error('Trying to initialize multiple ' +\n                        'components of type `' + componentName +\n                        '`. There can only be one component of this type per entity.');\n      }\n      component = new COMPONENTS[componentName].Component(this, data, componentId);\n      if (this.isPlaying) { component.play(); }\n\n      // Components are reflected in the DOM as attributes but the state is not shown\n      // hence we set the attribute to empty string.\n      // The flag justInitialized is for attributeChangedCallback to not overwrite\n      // the component with the empty string.\n      if (!this.hasAttribute(attrName)) {\n        component.justInitialized = true;\n        window.HTMLElement.prototype.setAttribute.call(this, attrName, '');\n      }\n\n      debug('Component initialized: %s', attrName);\n    },\n    writable: window.debug\n  },\n\n  /**\n   * Initialize dependencies of a component.\n   *\n   * @param {string} name - Root component name.\n   */\n  initComponentDependencies: {\n    value: function (name) {\n      var self = this;\n      var component = COMPONENTS[name];\n      var dependencies;\n      var i;\n\n      // Not a component.\n      if (!component) { return; }\n\n      // No dependencies.\n      dependencies = COMPONENTS[name].dependencies;\n\n      if (!dependencies) { return; }\n\n      // Initialize dependencies.\n      for (i = 0; i < dependencies.length; i++) {\n        // Call getAttribute to initialize the data from the DOM.\n        self.initComponent(\n          dependencies[i],\n          window.HTMLElement.prototype.getAttribute.call(self, dependencies[i]) || undefined,\n          true\n        );\n      }\n    }\n  },\n\n  removeComponent: {\n    value: function (name, destroy) {\n      var component;\n\n      component = this.components[name];\n      if (!component) { return; }\n\n      // Wait for component to initialize.\n      if (!component.initialized) {\n        this.addEventListener('componentinitialized', function tryRemoveLater (evt) {\n          if (evt.detail.name !== name) { return; }\n          this.removeComponent(name, destroy);\n          this.removeEventListener('componentinitialized', tryRemoveLater);\n        });\n        return;\n      }\n\n      component.pause();\n      component.remove();\n\n      // Keep component attached to entity in case of just full entity detach.\n      if (destroy) {\n        component.destroy();\n        delete this.components[name];\n      }\n\n      this.emit('componentremoved', component.evtDetail, false);\n    },\n    writable: window.debug\n  },\n\n  /**\n   * Initialize or update all components.\n   * Build data using initial components, defined attributes, mixins, and defaults.\n   * Update default components before the rest.\n   *\n   * @member {function} getExtraComponents - Can be implemented to include component data\n   *   from other sources (e.g., implemented by primitives).\n   */\n  updateComponents: {\n    value: function () {\n      var data;\n      var extraComponents;\n      var i;\n      var name;\n      var componentsToUpdate = this.componentsToUpdate;\n\n      if (!this.hasLoaded) { return; }\n\n      // Gather mixin-defined components.\n      for (i = 0; i < this.mixinEls.length; i++) {\n        for (name in this.mixinEls[i].componentCache) {\n          if (isComponent(name)) { componentsToUpdate[name] = true; }\n        }\n      }\n\n      // Gather from extra initial component data if defined (e.g., primitives).\n      if (this.getExtraComponents) {\n        extraComponents = this.getExtraComponents();\n        for (name in extraComponents) {\n          if (isComponent(name)) { componentsToUpdate[name] = true; }\n        }\n      }\n\n      // Gather entity-defined components.\n      for (i = 0; i < this.attributes.length; ++i) {\n        name = this.attributes[i].name;\n        if (OBJECT3D_COMPONENTS.indexOf(name) !== -1) { continue; }\n        if (isComponent(name)) { componentsToUpdate[name] = true; }\n      }\n\n      // object3D components first (position, rotation, scale, visible).\n      for (i = 0; i < OBJECT3D_COMPONENTS.length; i++) {\n        name = OBJECT3D_COMPONENTS[i];\n        if (!this.hasAttribute(name)) { continue; }\n        this.updateComponent(name, this.getDOMAttribute(name));\n      }\n\n      // Initialize or update rest of components.\n      for (name in componentsToUpdate) {\n        data = mergeComponentData(this.getDOMAttribute(name),\n                                  extraComponents && extraComponents[name]);\n        this.updateComponent(name, data);\n        delete componentsToUpdate[name];\n      }\n    },\n    writable: window.debug\n  },\n\n  /**\n   * Initialize, update, or remove a single component.\n   *\n   * When initializing, we set the component on `this.components`.\n   *\n   * @param {string} attr - Component name.\n   * @param {object} attrValue - Value of the DOM attribute.\n   * @param {boolean} clobber - If new attrValue completely replaces previous properties.\n   */\n  updateComponent: {\n    value: function (attr, attrValue, clobber) {\n      var component = this.components[attr];\n\n      if (component) {\n        // Remove component.\n        if (attrValue === null && !checkComponentDefined(this, attr)) {\n          this.removeComponent(attr, true);\n          return;\n        }\n        // Component already initialized. Update component.\n        component.updateProperties(attrValue, clobber);\n        return;\n      }\n\n      // Component not yet initialized. Initialize component.\n      this.initComponent(attr, attrValue, false);\n    }\n  },\n\n  /**\n   * If `attr` is a component name, detach the component from the entity.\n   *\n   * If `propertyName` is given, reset the component property value to its default.\n   *\n   * @param {string} attr - Attribute name, which could also be a component name.\n   * @param {string} propertyName - Component prop name, if resetting an individual prop.\n   */\n  removeAttribute: {\n    value: function (attr, propertyName) {\n      var component = this.components[attr];\n\n      // Remove component.\n      if (component && propertyName === undefined) {\n        this.removeComponent(attr, true);\n      }\n\n      // Reset component property value.\n      if (component && propertyName !== undefined) {\n        component.resetProperty(propertyName);\n        return;\n      }\n\n      // Remove mixins.\n      if (attr === 'mixin') {\n        this.mixinUpdate('');\n      }\n\n      window.HTMLElement.prototype.removeAttribute.call(this, attr);\n    }\n  },\n\n  /**\n   * Start dynamic behavior associated with entity such as dynamic components and animations.\n   * Tell all children entities to also play.\n   */\n  play: {\n    value: function () {\n      var entities;\n      var i;\n      var key;\n\n      // Already playing.\n      if (this.isPlaying || !this.hasLoaded) { return; }\n      this.isPlaying = true;\n\n      // Wake up all components.\n      for (key in this.components) { this.components[key].play(); }\n\n      // Tell all child entities to play.\n      entities = this.getChildEntities();\n      for (i = 0; i < entities.length; i++) { entities[i].play(); }\n\n      this.emit('play');\n    },\n    writable: true\n  },\n\n  /**\n   * Pause dynamic behavior associated with entity such as dynamic components and animations.\n   * Tell all children entities to also pause.\n   */\n  pause: {\n    value: function () {\n      var entities;\n      var i;\n      var key;\n\n      if (!this.isPlaying) { return; }\n      this.isPlaying = false;\n\n      // Sleep all components.\n      for (key in this.components) { this.components[key].pause(); }\n\n      // Tell all child entities to pause.\n      entities = this.getChildEntities();\n      for (i = 0; i < entities.length; i++) { entities[i].pause(); }\n\n      this.emit('pause');\n    },\n    writable: true\n  },\n\n  /**\n   * Deals with updates on entity-specific attributes (i.e., components and mixins).\n   *\n   * @param {string} attr\n   * @param {string} oldVal\n   * @param {string|object} newVal\n   */\n  setEntityAttribute: {\n    value: function (attr, oldVal, newVal) {\n      if (COMPONENTS[attr] || this.components[attr]) {\n        this.updateComponent(attr, newVal);\n        return;\n      }\n      if (attr === 'mixin') {\n        // Ignore if `<a-node>` code is just updating computed mixin in the DOM.\n        if (newVal === this.computedMixinStr) { return; }\n        this.mixinUpdate(newVal, oldVal);\n      }\n    }\n  },\n\n  /**\n   * When mixins updated, trigger init or optimized-update of relevant components.\n   */\n  mixinUpdate: {\n    value: (function () {\n      var componentsUpdated = [];\n\n      return function (newMixins, oldMixins) {\n        var component;\n        var mixinEl;\n        var mixinIds;\n        var i;\n        var self = this;\n\n        if (!this.hasLoaded) {\n          this.addEventListener('loaded', function () {\n            self.mixinUpdate(newMixins, oldMixins);\n          }, ONCE);\n          return;\n        }\n\n        oldMixins = oldMixins || this.getAttribute('mixin');\n        mixinIds = this.updateMixins(newMixins, oldMixins);\n\n        // Loop over current mixins.\n        componentsUpdated.length = 0;\n        for (i = 0; i < this.mixinEls.length; i++) {\n          for (component in this.mixinEls[i].componentCache) {\n            if (componentsUpdated.indexOf(component) === -1) {\n              if (this.components[component]) {\n                // Update. Just rebuild data.\n                this.components[component].handleMixinUpdate();\n              } else {\n                // Init. buildData will gather mixin values.\n                this.initComponent(component, null);\n              }\n              componentsUpdated.push(component);\n            }\n          }\n        }\n\n        // Loop over old mixins to call for data rebuild.\n        for (i = 0; i < mixinIds.oldMixinIds.length; i++) {\n          mixinEl = document.getElementById(mixinIds.oldMixinIds[i]);\n          if (!mixinEl) { continue; }\n          for (component in mixinEl.componentCache) {\n            if (componentsUpdated.indexOf(component) === -1) {\n              if (this.components[component]) {\n                if (this.getDOMAttribute(component)) {\n                  // Update component if explicitly defined.\n                  this.components[component].handleMixinUpdate();\n                } else {\n                  // Remove component if not explicitly defined.\n                  this.removeComponent(component, true);\n                }\n              }\n            }\n          }\n        }\n      };\n    })()\n  },\n\n  /**\n   * setAttribute can:\n   *\n   * 1. Set a single property of a multi-property component.\n   * 2. Set multiple properties of a multi-property component.\n   * 3. Replace properties of a multi-property component.\n   * 4. Set a value for a single-property component, mixin, or normal HTML attribute.\n   *\n   * @param {string} attrName - Component or attribute name.\n   * @param {*} arg1 - Can be a value, property name, CSS-style property string, or\n   *   object of properties.\n   * @param {*|bool} arg2 - If arg1 is a property name, this should be a value. Otherwise,\n   *   it is a boolean indicating whether to clobber previous values (defaults to false).\n   */\n  setAttribute: {\n    value: (function () {\n      var singlePropUpdate = {};\n\n      return function (attrName, arg1, arg2) {\n        var newAttrValue;\n        var clobber;\n        var componentName;\n        var delimiterIndex;\n        var isDebugMode;\n        var key;\n\n        delimiterIndex = attrName.indexOf(MULTIPLE_COMPONENT_DELIMITER);\n        componentName = delimiterIndex > 0 ? attrName.substring(0, delimiterIndex) : attrName;\n\n        // Not a component. Normal set attribute.\n        if (!COMPONENTS[componentName]) {\n          if (attrName === 'mixin') { this.mixinUpdate(arg1); }\n          ANode.prototype.setAttribute.call(this, attrName, arg1);\n          return;\n        }\n\n        // Initialize component first if not yet initialized.\n        if (!this.components[attrName] && this.hasAttribute(attrName)) {\n          this.updateComponent(\n            attrName,\n            window.HTMLElement.prototype.getAttribute.call(this, attrName));\n        }\n\n        // Determine new attributes from the arguments\n        if (typeof arg2 !== 'undefined' &&\n            typeof arg1 === 'string' &&\n            arg1.length > 0 &&\n            typeof utils.styleParser.parse(arg1) === 'string') {\n          // Update a single property of a multi-property component\n          for (key in singlePropUpdate) { delete singlePropUpdate[key]; }\n          newAttrValue = singlePropUpdate;\n          newAttrValue[arg1] = arg2;\n          clobber = false;\n        } else {\n          // Update with a value, object, or CSS-style property string, with the possiblity\n          // of clobbering previous values.\n          newAttrValue = arg1;\n          clobber = (arg2 === true);\n        }\n\n        // Update component\n        this.updateComponent(attrName, newAttrValue, clobber);\n\n        // In debug mode, write component data up to the DOM.\n        isDebugMode = this.sceneEl && this.sceneEl.getAttribute('debug');\n        if (isDebugMode) { this.components[attrName].flushToDOM(); }\n      };\n    })(),\n    writable: window.debug\n  },\n\n  /**\n   * Reflect component data in the DOM (as seen from the browser DOM Inspector).\n   *\n   * @param {bool} recursive - Also flushToDOM on the children.\n   **/\n  flushToDOM: {\n    value: function (recursive) {\n      var components = this.components;\n      var child;\n      var children = this.children;\n      var i;\n      var key;\n\n      // Flush entity's components to DOM.\n      for (key in components) {\n        components[key].flushToDOM();\n      }\n\n      // Recurse.\n      if (!recursive) { return; }\n      for (i = 0; i < children.length; ++i) {\n        child = children[i];\n        if (!child.flushToDOM) { continue; }\n        child.flushToDOM(recursive);\n      }\n    }\n  },\n\n  /**\n   * If `attr` is a component, returns ALL component data including applied mixins and\n   * defaults.\n   *\n   * If `attr` is not a component, fall back to HTML getAttribute.\n   *\n   * @param {string} attr\n   * @returns {object|string} Object if component, else string.\n   */\n  getAttribute: {\n    value: function (attr) {\n      // If component, return component data.\n      var component;\n      if (attr === 'position') { return this.object3D.position; }\n      if (attr === 'rotation') { return getRotation(this); }\n      if (attr === 'scale') { return this.object3D.scale; }\n      if (attr === 'visible') { return this.object3D.visible; }\n      component = this.components[attr];\n      if (component) { return component.data; }\n      return window.HTMLElement.prototype.getAttribute.call(this, attr);\n    },\n    writable: window.debug\n  },\n\n  /**\n   * If `attr` is a component, returns JUST the component data defined on the entity.\n   * Like a partial version of `getComputedAttribute` as returned component data\n   * does not include applied mixins or defaults.\n   *\n   * If `attr` is not a component, fall back to HTML getAttribute.\n   *\n   * @param {string} attr\n   * @returns {object|string} Object if component, else string.\n   */\n  getDOMAttribute: {\n    value: function (attr) {\n      // If cached value exists, return partial component data.\n      var component = this.components[attr];\n      if (component) { return component.attrValue; }\n      return window.HTMLElement.prototype.getAttribute.call(this, attr);\n    },\n    writable: window.debug\n  },\n\n  addState: {\n    value: function (state) {\n      if (this.is(state)) { return; }\n      this.states.push(state);\n      this.emit('stateadded', state);\n    }\n  },\n\n  removeState: {\n    value: function (state) {\n      var stateIndex = this.states.indexOf(state);\n      if (stateIndex === -1) { return; }\n      this.states.splice(stateIndex, 1);\n      this.emit('stateremoved', state);\n    }\n  },\n\n  /**\n   * Checks if the element is in a given state. e.g. el.is('alive');\n   * @type {string} state - Name of the state we want to check\n   */\n  is: {\n    value: function (state) {\n      return this.states.indexOf(state) !== -1;\n    }\n  },\n\n  /**\n   * Open Inspector to this entity.\n   */\n  inspect: {\n    value: function () {\n      this.sceneEl.components.inspector.openInspector(this);\n    }\n  },\n\n  /**\n   * Clean up memory and return memory to object pools.\n   */\n  destroy: {\n    value: function () {\n      var key;\n      if (this.parentNode) {\n        warn('Entity can only be destroyed if detached from scenegraph.');\n        return;\n      }\n      for (key in this.components) {\n        this.components[key].destroy();\n      }\n    }\n  }\n});\n\n/**\n * Check if a component is *defined* for an entity, including defaults and mixins.\n * Does not check whether the component has been *initialized* for an entity.\n *\n * @param {string} el - Entity.\n * @param {string} name - Component name.\n * @returns {boolean}\n */\nfunction checkComponentDefined (el, name) {\n  // Check if element contains the component.\n  if (el.components[name] && el.components[name].attrValue) { return true; }\n\n  return isComponentMixedIn(name, el.mixinEls);\n}\n\n/**\n * Check if any mixins contains a component.\n *\n * @param {string} name - Component name.\n * @param {array} mixinEls - Array of <a-mixin>s.\n */\nfunction isComponentMixedIn (name, mixinEls) {\n  var i;\n  var inMixin = false;\n  for (i = 0; i < mixinEls.length; ++i) {\n    inMixin = mixinEls[i].hasAttribute(name);\n    if (inMixin) { break; }\n  }\n  return inMixin;\n}\n\n/**\n * Given entity defined value, merge in extra data if necessary.\n * Handle both single and multi-property components.\n *\n * @param {string} attrValue - Entity data.\n * @param extraData - Entity data from another source to merge in.\n */\nfunction mergeComponentData (attrValue, extraData) {\n  // Extra data not defined, just return attrValue.\n  if (!extraData) { return attrValue; }\n\n  // Merge multi-property data.\n  if (extraData.constructor === Object) {\n    return utils.extend(extraData, utils.styleParser.parse(attrValue || {}));\n  }\n\n  // Return data, precendence to the defined value.\n  return attrValue || extraData;\n}\n\nfunction isComponent (componentName) {\n  if (componentName.indexOf(MULTIPLE_COMPONENT_DELIMITER) !== -1) {\n    componentName = utils.split(componentName, MULTIPLE_COMPONENT_DELIMITER)[0];\n  }\n  if (!COMPONENTS[componentName]) { return false; }\n  return true;\n}\n\nfunction getRotation (entityEl) {\n  var radToDeg = THREE.Math.radToDeg;\n  var rotation = entityEl.object3D.rotation;\n  var rotationObj = entityEl.rotationObj;\n  rotationObj.x = radToDeg(rotation.x);\n  rotationObj.y = radToDeg(rotation.y);\n  rotationObj.z = radToDeg(rotation.z);\n  return rotationObj;\n}\n\nAEntity = registerElement('a-entity', {prototype: proto});\nmodule.exports = AEntity;\n"]},"metadata":{},"sourceType":"script"}