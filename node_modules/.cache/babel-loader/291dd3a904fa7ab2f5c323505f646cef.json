{"ast":null,"code":"/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { BufferGeometry, DoubleSide, Float32BufferAttribute, Mesh, PlaneBufferGeometry, Vector2 } from 'three';\nimport { Damper } from './Damper.js';\nconst RADIUS = 0.2;\nconst LINE_WIDTH = 0.03;\nconst MAX_OPACITY = 0.75;\nconst SEGMENTS = 12;\nconst DELTA_PHI = Math.PI / (2 * SEGMENTS);\nconst vector2 = new Vector2();\n/**\n * Adds a quarter-annulus of vertices to the array, centered on cornerX,\n * cornerY.\n */\n\nconst addCorner = (vertices, cornerX, cornerY) => {\n  let phi = cornerX > 0 ? cornerY > 0 ? 0 : -Math.PI / 2 : cornerY > 0 ? Math.PI / 2 : Math.PI;\n\n  for (let i = 0; i <= SEGMENTS; ++i) {\n    vertices.push(cornerX + (RADIUS - LINE_WIDTH) * Math.cos(phi), cornerY + (RADIUS - LINE_WIDTH) * Math.sin(phi), 0, cornerX + RADIUS * Math.cos(phi), cornerY + RADIUS * Math.sin(phi), 0);\n    phi += DELTA_PHI;\n  }\n};\n/**\n * This class is a set of two coincident planes. The first is just a cute box\n * outline with rounded corners and damped opacity to indicate the floor extents\n * of a model. It is purposely larger than the model's bounding box by RADIUS on\n * all sides so that small models are still visible / selectable. Its center is\n * actually carved out by vertices to ensure its fragment shader doesn't add\n * much time.\n *\n * The child plane is a simple plane with the same extents for use in hit\n * testing (translation is triggered when the touch hits the plane, rotation\n * otherwise).\n */\n\n\nexport class PlacementBox extends Mesh {\n  constructor(model) {\n    const geometry = new BufferGeometry();\n    const triangles = [];\n    const vertices = [];\n    const size = model.size,\n          boundingBox = model.boundingBox;\n    const x = size.x / 2;\n    const y = size.z / 2;\n    addCorner(vertices, x, y);\n    addCorner(vertices, -x, y);\n    addCorner(vertices, -x, -y);\n    addCorner(vertices, x, -y);\n    const numVertices = vertices.length / 3;\n\n    for (let i = 0; i < numVertices - 2; i += 2) {\n      triangles.push(i, i + 1, i + 3, i, i + 3, i + 2);\n    }\n\n    const i = numVertices - 2;\n    triangles.push(i, i + 1, 1, i, 1, 0);\n    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    geometry.setIndex(triangles);\n    super(geometry);\n    const material = this.material;\n    material.side = DoubleSide;\n    material.transparent = true;\n    material.opacity = 0;\n    this.goalOpacity = 0;\n    this.opacityDamper = new Damper();\n    this.hitPlane = new Mesh(new PlaneBufferGeometry(size.x + 2 * RADIUS, size.z + 2 * RADIUS));\n    this.hitPlane.visible = false;\n    this.add(this.hitPlane);\n    this.rotateX(-Math.PI / 2);\n    boundingBox.getCenter(this.position);\n    this.shadowHeight = boundingBox.min.y;\n    this.position.y = this.shadowHeight;\n    model.add(this);\n  }\n  /**\n   * Get the world hit position if the touch coordinates hit the box, and null\n   * otherwise. Pass the scene in to get access to its raycaster.\n   */\n\n\n  getHit(scene, screenX, screenY) {\n    vector2.set(screenX, -screenY);\n    this.hitPlane.visible = true;\n    const hitResult = scene.positionAndNormalFromPoint(vector2, this.hitPlane);\n    this.hitPlane.visible = false;\n    return hitResult == null ? null : hitResult.position;\n  }\n  /**\n   * Offset the height of the box relative to the bottom of the model. Positive\n   * is up, so generally only negative values are used.\n   */\n\n\n  set offsetHeight(offset) {\n    this.position.y = this.shadowHeight + offset;\n  }\n\n  get offsetHeight() {\n    return this.position.y - this.shadowHeight;\n  }\n  /**\n   * Set the box's visibility; it will fade in and out.\n   */\n\n\n  set show(visible) {\n    this.goalOpacity = visible ? MAX_OPACITY : 0;\n  }\n  /**\n   * Call on each frame with the frame delta to fade the box.\n   */\n\n\n  updateOpacity(delta) {\n    const material = this.material;\n    material.opacity = this.opacityDamper.update(material.opacity, this.goalOpacity, delta, 1);\n    this.visible = material.opacity > 0;\n  }\n  /**\n   * Call this to clean up Three's cache when you remove the box.\n   */\n\n\n  dispose() {\n    const _this$hitPlane = this.hitPlane,\n          geometry = _this$hitPlane.geometry,\n          material = _this$hitPlane.material;\n    geometry.dispose();\n    material.dispose();\n    this.geometry.dispose();\n    this.material.dispose();\n  }\n\n}","map":{"version":3,"sources":["../../src/three-components/PlacementBox.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {BufferGeometry, DoubleSide, Float32BufferAttribute, Material, Mesh, MeshBasicMaterial, PlaneBufferGeometry, Vector2, Vector3} from 'three';\n\nimport {Damper} from './Damper.js';\nimport Model from './Model.js';\nimport {ModelScene} from './ModelScene.js';\n\nconst RADIUS = 0.2;\nconst LINE_WIDTH = 0.03;\nconst MAX_OPACITY = 0.75;\nconst SEGMENTS = 12;\nconst DELTA_PHI = Math.PI / (2 * SEGMENTS);\n\nconst vector2 = new Vector2();\n\n/**\n * Adds a quarter-annulus of vertices to the array, centered on cornerX,\n * cornerY.\n */\nconst addCorner =\n    (vertices: Array<number>, cornerX: number, cornerY: number) => {\n      let phi = cornerX > 0 ? (cornerY > 0 ? 0 : -Math.PI / 2) :\n                              (cornerY > 0 ? Math.PI / 2 : Math.PI);\n      for (let i = 0; i <= SEGMENTS; ++i) {\n        vertices.push(\n            cornerX + (RADIUS - LINE_WIDTH) * Math.cos(phi),\n            cornerY + (RADIUS - LINE_WIDTH) * Math.sin(phi),\n            0,\n            cornerX + RADIUS * Math.cos(phi),\n            cornerY + RADIUS * Math.sin(phi),\n            0);\n        phi += DELTA_PHI;\n      }\n    };\n\n/**\n * This class is a set of two coincident planes. The first is just a cute box\n * outline with rounded corners and damped opacity to indicate the floor extents\n * of a model. It is purposely larger than the model's bounding box by RADIUS on\n * all sides so that small models are still visible / selectable. Its center is\n * actually carved out by vertices to ensure its fragment shader doesn't add\n * much time.\n *\n * The child plane is a simple plane with the same extents for use in hit\n * testing (translation is triggered when the touch hits the plane, rotation\n * otherwise).\n */\nexport class PlacementBox extends Mesh {\n  private hitPlane: Mesh;\n  private shadowHeight: number;\n  private goalOpacity: number;\n  private opacityDamper: Damper;\n\n  constructor(model: Model) {\n    const geometry = new BufferGeometry();\n    const triangles: Array<number> = [];\n    const vertices: Array<number> = [];\n    const {size, boundingBox} = model;\n\n    const x = size.x / 2;\n    const y = size.z / 2;\n    addCorner(vertices, x, y);\n    addCorner(vertices, -x, y);\n    addCorner(vertices, -x, -y);\n    addCorner(vertices, x, -y);\n\n    const numVertices = vertices.length / 3;\n    for (let i = 0; i < numVertices - 2; i += 2) {\n      triangles.push(i, i + 1, i + 3, i, i + 3, i + 2);\n    }\n    const i = numVertices - 2;\n    triangles.push(i, i + 1, 1, i, 1, 0);\n\n    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    geometry.setIndex(triangles);\n\n    super(geometry);\n\n    const material = this.material as MeshBasicMaterial;\n    material.side = DoubleSide;\n    material.transparent = true;\n    material.opacity = 0;\n    this.goalOpacity = 0;\n    this.opacityDamper = new Damper();\n\n    this.hitPlane = new Mesh(\n        new PlaneBufferGeometry(size.x + 2 * RADIUS, size.z + 2 * RADIUS));\n    this.hitPlane.visible = false;\n    this.add(this.hitPlane);\n\n    this.rotateX(-Math.PI / 2);\n    boundingBox.getCenter(this.position);\n    this.shadowHeight = boundingBox.min.y;\n    this.position.y = this.shadowHeight;\n\n    model.add(this);\n  }\n\n  /**\n   * Get the world hit position if the touch coordinates hit the box, and null\n   * otherwise. Pass the scene in to get access to its raycaster.\n   */\n  getHit(scene: ModelScene, screenX: number, screenY: number): Vector3|null {\n    vector2.set(screenX, -screenY);\n    this.hitPlane.visible = true;\n    const hitResult = scene.positionAndNormalFromPoint(vector2, this.hitPlane);\n    this.hitPlane.visible = false;\n    return hitResult == null ? null : hitResult.position;\n  }\n\n  /**\n   * Offset the height of the box relative to the bottom of the model. Positive\n   * is up, so generally only negative values are used.\n   */\n  set offsetHeight(offset: number) {\n    this.position.y = this.shadowHeight + offset;\n  }\n\n  get offsetHeight(): number {\n    return this.position.y - this.shadowHeight;\n  }\n\n  /**\n   * Set the box's visibility; it will fade in and out.\n   */\n  set show(visible: boolean) {\n    this.goalOpacity = visible ? MAX_OPACITY : 0;\n  }\n\n  /**\n   * Call on each frame with the frame delta to fade the box.\n   */\n  updateOpacity(delta: number) {\n    const material = this.material as MeshBasicMaterial;\n    material.opacity =\n        this.opacityDamper.update(material.opacity, this.goalOpacity, delta, 1);\n    this.visible = material.opacity > 0;\n  }\n\n  /**\n   * Call this to clean up Three's cache when you remove the box.\n   */\n  dispose() {\n    const {geometry, material} = this.hitPlane;\n    geometry.dispose();\n    (material as Material).dispose();\n    this.geometry.dispose();\n    (this.material as Material).dispose();\n  }\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}