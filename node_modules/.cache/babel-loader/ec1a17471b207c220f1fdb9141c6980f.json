{"ast":null,"code":"var DEFAULT_HANDEDNESS = require('../constants').DEFAULT_HANDEDNESS;\n\nvar AXIS_LABELS = ['x', 'y', 'z', 'w'];\nvar NUM_HANDS = 2; // Number of hands in a pair. Should always be 2.\n\n/**\n * Called on controller component `.play` handlers.\n * Check if controller matches parameters and inject tracked-controls component.\n * Handle event listeners.\n * Generate controllerconnected or controllerdisconnected events.\n *\n * @param {object} component - Tracked controls component.\n * @param {object} idPrefix - Prefix to match in gamepad id if any.\n * @param {object} queryObject - Map of values to match.\n */\n\nmodule.exports.checkControllerPresentAndSetup = function (component, idPrefix, queryObject) {\n  var el = component.el;\n  var controller;\n  var hasWebXR = el.sceneEl.hasWebXR;\n  var isControllerPresent = hasWebXR ? isControllerPresentWebXR : isControllerPresentWebVR;\n  var isPresent;\n  controller = isControllerPresent(component, idPrefix, queryObject);\n  isPresent = !!controller; // If component was previously paused and now playing, re-add event listeners.\n  // Handle the event listeners here since this helper method is control of calling\n  // `.addEventListeners` and `.removeEventListeners`.\n\n  if (component.controllerPresent && !component.controllerEventsActive && !hasWebXR) {\n    component.addEventListeners();\n  } // Nothing changed, no need to do anything.\n\n\n  if (isPresent === component.controllerPresent) {\n    return isPresent;\n  }\n\n  component.controllerPresent = isPresent; // Update controller presence.\n\n  if (isPresent) {\n    component.injectTrackedControls();\n    component.addEventListeners();\n    el.emit('controllerconnected', {\n      name: component.name,\n      component: component\n    });\n  } else {\n    component.removeEventListeners();\n    el.emit('controllerdisconnected', {\n      name: component.name,\n      component: component\n    });\n  }\n};\n/**\n * Enumerate controller (that have pose) and check if they match parameters for WebVR\n *\n * @param {object} component - Tracked controls component.\n * @param {object} idPrefix - Prefix to match in gamepad id if any.\n * @param {object} queryObject - Map of values to match.\n */\n\n\nfunction isControllerPresentWebVR(component, idPrefix, queryObject) {\n  var gamepads;\n  var sceneEl = component.el.sceneEl;\n  var trackedControlsSystem;\n  var filterControllerIndex = queryObject.index || 0;\n\n  if (!idPrefix) {\n    return false;\n  }\n\n  trackedControlsSystem = sceneEl && sceneEl.systems['tracked-controls-webvr'];\n\n  if (!trackedControlsSystem) {\n    return false;\n  }\n\n  gamepads = trackedControlsSystem.controllers;\n\n  if (!gamepads.length) {\n    return false;\n  }\n\n  return !!findMatchingControllerWebVR(gamepads, null, idPrefix, queryObject.hand, filterControllerIndex);\n}\n/**\n *\n * @param {object} component - Tracked controls component.\n */\n\n\nfunction isControllerPresentWebXR(component, id, queryObject) {\n  var controllers;\n  var sceneEl = component.el.sceneEl;\n  var trackedControlsSystem = sceneEl && sceneEl.systems['tracked-controls-webxr'];\n\n  if (!trackedControlsSystem) {\n    return false;\n  }\n\n  controllers = trackedControlsSystem.controllers;\n\n  if (!controllers || !controllers.length) {\n    return false;\n  }\n\n  return findMatchingControllerWebXR(controllers, id, queryObject.hand, queryObject.index, queryObject.iterateControllerProfiles);\n}\n\nmodule.exports.isControllerPresentWebVR = isControllerPresentWebVR;\nmodule.exports.isControllerPresentWebXR = isControllerPresentWebXR;\n/**\n * Walk through the given controllers to find any where the device ID equals\n * filterIdExact, or startsWith filterIdPrefix.\n * A controller where this considered true is considered a 'match'.\n *\n * For each matching controller:\n *   If filterHand is set, and the controller:\n *     is handed, we further verify that controller.hand equals filterHand.\n *     is unhanded (controller.hand is ''), we skip until we have found a\n *     number of matching controllers that equals filterControllerIndex\n *   If filterHand is not set, we skip until we have found the nth matching\n *   controller, where n equals filterControllerIndex\n *\n * The method should be called with one of: [filterIdExact, filterIdPrefix] AND\n * one or both of: [filterHand, filterControllerIndex]\n *\n * @param {object} controllers - Array of gamepads to search\n * @param {string} filterIdExact - If set, used to find controllers with id === this value\n * @param {string} filterIdPrefix - If set, used to find controllers with id startsWith this value\n * @param {object} filterHand - If set, further filters controllers with matching 'hand' property\n * @param {object} filterControllerIndex - Find the nth matching controller,\n * where n equals filterControllerIndex. defaults to 0.\n */\n\nfunction findMatchingControllerWebVR(controllers, filterIdExact, filterIdPrefix, filterHand, filterControllerIndex) {\n  var controller;\n  var i;\n  var matchingControllerOccurence = 0;\n  var targetControllerMatch = filterControllerIndex >= 0 ? filterControllerIndex : 0;\n\n  for (i = 0; i < controllers.length; i++) {\n    controller = controllers[i]; // Determine if the controller ID matches our criteria.\n\n    if (filterIdPrefix && !controller.id.startsWith(filterIdPrefix)) {\n      continue;\n    }\n\n    if (!filterIdPrefix && controller.id !== filterIdExact) {\n      continue;\n    } // If the hand filter and controller handedness are defined we compare them.\n\n\n    if (filterHand && controller.hand && filterHand !== controller.hand) {\n      continue;\n    } // If we have detected an unhanded controller and the component was asking\n    // for a particular hand, we need to treat the controllers in the array as\n    // pairs of controllers. This effectively means that we need to skip\n    // NUM_HANDS matches for each controller number, instead of 1.\n\n\n    if (filterHand && !controller.hand) {\n      targetControllerMatch = NUM_HANDS * filterControllerIndex + (filterHand === DEFAULT_HANDEDNESS ? 0 : 1);\n    } else {\n      return controller;\n    } // We are looking for the nth occurence of a matching controller\n    // (n equals targetControllerMatch).\n\n\n    if (matchingControllerOccurence === targetControllerMatch) {\n      return controller;\n    }\n\n    ++matchingControllerOccurence;\n  }\n\n  return undefined;\n}\n\nfunction findMatchingControllerWebXR(controllers, idPrefix, handedness, index, iterateProfiles) {\n  var i;\n  var j;\n  var controller;\n  var controllerMatch = false;\n  var controllerHasHandedness;\n  var profiles;\n\n  for (i = 0; i < controllers.length; i++) {\n    controller = controllers[i];\n    profiles = controller.profiles;\n\n    if (profiles.length === 0) {\n      return;\n    }\n\n    if (iterateProfiles) {\n      for (j = 0; j < profiles.length; j++) {\n        controllerMatch = profiles[j].startsWith(idPrefix);\n\n        if (controllerMatch) {\n          break;\n        }\n      }\n    } else {\n      controllerMatch = profiles[0].startsWith(idPrefix);\n    }\n\n    if (!controllerMatch) {\n      continue;\n    } // Vive controllers are assigned handedness at runtime and it might not be always available.\n\n\n    controllerHasHandedness = controller.handedness === 'right' || controller.handedness === 'left';\n\n    if (controllerHasHandedness) {\n      if (controller.handedness === handedness) {\n        return controllers[i];\n      }\n    } else {\n      // Fallback to index if controller has no handedness.\n      if (i === index) {\n        return controllers[i];\n      }\n    }\n  }\n\n  return undefined;\n}\n\nmodule.exports.findMatchingControllerWebVR = findMatchingControllerWebVR;\nmodule.exports.findMatchingControllerWebXR = findMatchingControllerWebXR;\n/**\n * Emit specific `moved` event(s) if axes changed based on original axismoved event.\n *\n * @param {object} component - Controller component in use.\n * @param {array} axesMapping - For example `{thumbstick: [0, 1]}`.\n * @param {object} evt - Event to process.\n */\n\nmodule.exports.emitIfAxesChanged = function (component, axesMapping, evt) {\n  var axes;\n  var buttonType;\n  var changed;\n  var detail;\n  var j;\n\n  for (buttonType in axesMapping) {\n    axes = axesMapping[buttonType];\n    changed = false;\n\n    for (j = 0; j < axes.length; j++) {\n      if (evt.detail.changed[axes[j]]) {\n        changed = true;\n      }\n    }\n\n    if (!changed) {\n      continue;\n    } // Axis has changed. Emit the specific moved event with axis values in detail.\n\n\n    detail = {};\n\n    for (j = 0; j < axes.length; j++) {\n      detail[AXIS_LABELS[j]] = evt.detail.axis[axes[j]];\n    }\n\n    component.el.emit(buttonType + 'moved', detail);\n  }\n};\n/**\n * Handle a button event and reemits the events.\n *\n * @param {string} id - id of the button.\n * @param {string} evtName - name of the reemitted event\n * @param {object} component - reference to the component\n * @param {string} hand - handedness of the controller: left or right.\n */\n\n\nmodule.exports.onButtonEvent = function (id, evtName, component, hand) {\n  var mapping = hand ? component.mapping[hand] : component.mapping;\n  var buttonName = mapping.buttons[id];\n  component.el.emit(buttonName + evtName);\n\n  if (component.updateModel) {\n    component.updateModel(buttonName, evtName);\n  }\n};","map":{"version":3,"sources":["C:/Users/Hannuri/Desktop/RoyalCyber/my-first-app/node_modules/aframe/src/utils/tracked-controls.js"],"names":["DEFAULT_HANDEDNESS","require","AXIS_LABELS","NUM_HANDS","module","exports","checkControllerPresentAndSetup","component","idPrefix","queryObject","el","controller","hasWebXR","sceneEl","isControllerPresent","isControllerPresentWebXR","isControllerPresentWebVR","isPresent","controllerPresent","controllerEventsActive","addEventListeners","injectTrackedControls","emit","name","removeEventListeners","gamepads","trackedControlsSystem","filterControllerIndex","index","systems","controllers","length","findMatchingControllerWebVR","hand","id","findMatchingControllerWebXR","iterateControllerProfiles","filterIdExact","filterIdPrefix","filterHand","i","matchingControllerOccurence","targetControllerMatch","startsWith","undefined","handedness","iterateProfiles","j","controllerMatch","controllerHasHandedness","profiles","emitIfAxesChanged","axesMapping","evt","axes","buttonType","changed","detail","axis","onButtonEvent","evtName","mapping","buttonName","buttons","updateModel"],"mappings":"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","sourcesContent":["var DEFAULT_HANDEDNESS = require('../constants').DEFAULT_HANDEDNESS;\nvar AXIS_LABELS = ['x', 'y', 'z', 'w'];\nvar NUM_HANDS = 2;  // Number of hands in a pair. Should always be 2.\n\n/**\n * Called on controller component `.play` handlers.\n * Check if controller matches parameters and inject tracked-controls component.\n * Handle event listeners.\n * Generate controllerconnected or controllerdisconnected events.\n *\n * @param {object} component - Tracked controls component.\n * @param {object} idPrefix - Prefix to match in gamepad id if any.\n * @param {object} queryObject - Map of values to match.\n */\nmodule.exports.checkControllerPresentAndSetup = function (component, idPrefix, queryObject) {\n  var el = component.el;\n  var controller;\n  var hasWebXR = el.sceneEl.hasWebXR;\n  var isControllerPresent = hasWebXR ? isControllerPresentWebXR : isControllerPresentWebVR;\n  var isPresent;\n\n  controller = isControllerPresent(component, idPrefix, queryObject);\n  isPresent = !!controller;\n\n  // If component was previously paused and now playing, re-add event listeners.\n  // Handle the event listeners here since this helper method is control of calling\n  // `.addEventListeners` and `.removeEventListeners`.\n  if (component.controllerPresent && !component.controllerEventsActive && !hasWebXR) {\n    component.addEventListeners();\n  }\n\n  // Nothing changed, no need to do anything.\n  if (isPresent === component.controllerPresent) { return isPresent; }\n\n  component.controllerPresent = isPresent;\n\n  // Update controller presence.\n  if (isPresent) {\n    component.injectTrackedControls();\n    component.addEventListeners();\n    el.emit('controllerconnected', {name: component.name, component: component});\n  } else {\n    component.removeEventListeners();\n    el.emit('controllerdisconnected', {name: component.name, component: component});\n  }\n};\n\n/**\n * Enumerate controller (that have pose) and check if they match parameters for WebVR\n *\n * @param {object} component - Tracked controls component.\n * @param {object} idPrefix - Prefix to match in gamepad id if any.\n * @param {object} queryObject - Map of values to match.\n */\nfunction isControllerPresentWebVR (component, idPrefix, queryObject) {\n  var gamepads;\n  var sceneEl = component.el.sceneEl;\n  var trackedControlsSystem;\n  var filterControllerIndex = queryObject.index || 0;\n\n  if (!idPrefix) { return false; }\n\n  trackedControlsSystem = sceneEl && sceneEl.systems['tracked-controls-webvr'];\n  if (!trackedControlsSystem) { return false; }\n\n  gamepads = trackedControlsSystem.controllers;\n  if (!gamepads.length) { return false; }\n\n  return !!findMatchingControllerWebVR(gamepads, null, idPrefix, queryObject.hand,\n                                  filterControllerIndex);\n}\n\n/**\n *\n * @param {object} component - Tracked controls component.\n */\nfunction isControllerPresentWebXR (component, id, queryObject) {\n  var controllers;\n  var sceneEl = component.el.sceneEl;\n  var trackedControlsSystem = sceneEl && sceneEl.systems['tracked-controls-webxr'];\n  if (!trackedControlsSystem) { return false; }\n\n  controllers = trackedControlsSystem.controllers;\n  if (!controllers || !controllers.length) { return false; }\n\n  return findMatchingControllerWebXR(\n    controllers, id,\n    queryObject.hand, queryObject.index, queryObject.iterateControllerProfiles);\n}\n\nmodule.exports.isControllerPresentWebVR = isControllerPresentWebVR;\nmodule.exports.isControllerPresentWebXR = isControllerPresentWebXR;\n\n/**\n * Walk through the given controllers to find any where the device ID equals\n * filterIdExact, or startsWith filterIdPrefix.\n * A controller where this considered true is considered a 'match'.\n *\n * For each matching controller:\n *   If filterHand is set, and the controller:\n *     is handed, we further verify that controller.hand equals filterHand.\n *     is unhanded (controller.hand is ''), we skip until we have found a\n *     number of matching controllers that equals filterControllerIndex\n *   If filterHand is not set, we skip until we have found the nth matching\n *   controller, where n equals filterControllerIndex\n *\n * The method should be called with one of: [filterIdExact, filterIdPrefix] AND\n * one or both of: [filterHand, filterControllerIndex]\n *\n * @param {object} controllers - Array of gamepads to search\n * @param {string} filterIdExact - If set, used to find controllers with id === this value\n * @param {string} filterIdPrefix - If set, used to find controllers with id startsWith this value\n * @param {object} filterHand - If set, further filters controllers with matching 'hand' property\n * @param {object} filterControllerIndex - Find the nth matching controller,\n * where n equals filterControllerIndex. defaults to 0.\n */\nfunction findMatchingControllerWebVR (controllers, filterIdExact, filterIdPrefix, filterHand,\n                                 filterControllerIndex) {\n  var controller;\n  var i;\n  var matchingControllerOccurence = 0;\n  var targetControllerMatch = filterControllerIndex >= 0 ? filterControllerIndex : 0;\n\n  for (i = 0; i < controllers.length; i++) {\n    controller = controllers[i];\n\n    // Determine if the controller ID matches our criteria.\n    if (filterIdPrefix && !controller.id.startsWith(filterIdPrefix)) {\n      continue;\n    }\n\n    if (!filterIdPrefix && controller.id !== filterIdExact) { continue; }\n\n    // If the hand filter and controller handedness are defined we compare them.\n    if (filterHand && controller.hand && filterHand !== controller.hand) { continue; }\n\n    // If we have detected an unhanded controller and the component was asking\n    // for a particular hand, we need to treat the controllers in the array as\n    // pairs of controllers. This effectively means that we need to skip\n    // NUM_HANDS matches for each controller number, instead of 1.\n    if (filterHand && !controller.hand) {\n      targetControllerMatch = NUM_HANDS * filterControllerIndex + ((filterHand === DEFAULT_HANDEDNESS) ? 0 : 1);\n    } else {\n      return controller;\n    }\n\n    // We are looking for the nth occurence of a matching controller\n    // (n equals targetControllerMatch).\n    if (matchingControllerOccurence === targetControllerMatch) { return controller; }\n    ++matchingControllerOccurence;\n  }\n  return undefined;\n}\n\nfunction findMatchingControllerWebXR (controllers, idPrefix, handedness, index, iterateProfiles) {\n  var i;\n  var j;\n  var controller;\n  var controllerMatch = false;\n  var controllerHasHandedness;\n  var profiles;\n  for (i = 0; i < controllers.length; i++) {\n    controller = controllers[i];\n    profiles = controller.profiles;\n    if (profiles.length === 0) { return; }\n    if (iterateProfiles) {\n      for (j = 0; j < profiles.length; j++) {\n        controllerMatch = profiles[j].startsWith(idPrefix);\n        if (controllerMatch) { break; }\n      }\n    } else {\n      controllerMatch = profiles[0].startsWith(idPrefix);\n    }\n    if (!controllerMatch) { continue; }\n    // Vive controllers are assigned handedness at runtime and it might not be always available.\n    controllerHasHandedness = controller.handedness === 'right' || controller.handedness === 'left';\n    if (controllerHasHandedness) {\n      if (controller.handedness === handedness) { return controllers[i]; }\n    } else { // Fallback to index if controller has no handedness.\n      if ((i === index)) { return controllers[i]; }\n    }\n  }\n  return undefined;\n}\n\nmodule.exports.findMatchingControllerWebVR = findMatchingControllerWebVR;\nmodule.exports.findMatchingControllerWebXR = findMatchingControllerWebXR;\n\n/**\n * Emit specific `moved` event(s) if axes changed based on original axismoved event.\n *\n * @param {object} component - Controller component in use.\n * @param {array} axesMapping - For example `{thumbstick: [0, 1]}`.\n * @param {object} evt - Event to process.\n */\nmodule.exports.emitIfAxesChanged = function (component, axesMapping, evt) {\n  var axes;\n  var buttonType;\n  var changed;\n  var detail;\n  var j;\n\n  for (buttonType in axesMapping) {\n    axes = axesMapping[buttonType];\n\n    changed = false;\n    for (j = 0; j < axes.length; j++) {\n      if (evt.detail.changed[axes[j]]) { changed = true; }\n    }\n\n    if (!changed) { continue; }\n\n    // Axis has changed. Emit the specific moved event with axis values in detail.\n    detail = {};\n    for (j = 0; j < axes.length; j++) {\n      detail[AXIS_LABELS[j]] = evt.detail.axis[axes[j]];\n    }\n    component.el.emit(buttonType + 'moved', detail);\n  }\n};\n\n/**\n * Handle a button event and reemits the events.\n *\n * @param {string} id - id of the button.\n * @param {string} evtName - name of the reemitted event\n * @param {object} component - reference to the component\n * @param {string} hand - handedness of the controller: left or right.\n */\nmodule.exports.onButtonEvent = function (id, evtName, component, hand) {\n  var mapping = hand ? component.mapping[hand] : component.mapping;\n  var buttonName = mapping.buttons[id];\n  component.el.emit(buttonName + evtName);\n  if (component.updateModel) {\n    component.updateModel(buttonName, evtName);\n  }\n};\n"]},"metadata":{},"sourceType":"script"}