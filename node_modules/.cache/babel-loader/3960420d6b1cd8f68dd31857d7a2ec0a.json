{"ast":null,"code":"import _slicedToArray from \"F:\\\\_HCLCommece\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b, _c;\n\nimport { normalizeUnit } from './conversions';\nimport { numberNode, ZERO } from './parsers';\nconst $evaluate = Symbol('evaluate');\nconst $lastValue = Symbol('lastValue');\n/**\n * An Evaluator is used to derive a computed style from part (or all) of a CSS\n * expression AST. This construct is particularly useful for complex ASTs\n * containing function calls such as calc, var and env. Such styles could be\n * costly to re-evaluate on every frame (and in some cases we may try to do\n * that). The Evaluator construct allows us to mark sub-trees of the AST as\n * constant, so that only the dynamic parts are re-evaluated. It also separates\n * one-time AST preparation work from work that necessarily has to happen upon\n * each evaluation.\n */\n\nexport class Evaluator {\n  constructor() {\n    this[_a] = null;\n  }\n  /**\n   * An Evaluatable is a NumberNode or an Evaluator that evaluates a NumberNode\n   * as the result of invoking its evaluate method. This is mainly used to\n   * ensure that CSS function nodes are cast to the corresponding Evaluators\n   * that will resolve the result of the function, but is also used to ensure\n   * that a percentage nested at arbitrary depth in the expression will always\n   * be evaluated against the correct basis.\n   */\n\n\n  static evaluatableFor(node, basis = ZERO) {\n    if (node instanceof Evaluator) {\n      return node;\n    }\n\n    if (node.type === 'number') {\n      if (node.unit === '%') {\n        return new PercentageEvaluator(node, basis);\n      }\n\n      return node;\n    }\n\n    switch (node.name.value) {\n      case 'calc':\n        return new CalcEvaluator(node, basis);\n\n      case 'env':\n        return new EnvEvaluator(node);\n    }\n\n    return ZERO;\n  }\n  /**\n   * If the input is an Evaluator, returns the result of evaluating it.\n   * Otherwise, returns the input.\n   *\n   * This is a helper to aide in resolving a NumberNode without conditionally\n   * checking if the Evaluatable is an Evaluator everywhere.\n   */\n\n\n  static evaluate(evaluatable) {\n    if (evaluatable instanceof Evaluator) {\n      return evaluatable.evaluate();\n    }\n\n    return evaluatable;\n  }\n  /**\n   * If the input is an Evaluator, returns the value of its isConstant property.\n   * Returns true for all other input values.\n   */\n\n\n  static isConstant(evaluatable) {\n    if (evaluatable instanceof Evaluator) {\n      return evaluatable.isConstant;\n    }\n\n    return true;\n  }\n  /**\n   * This method applies a set of structured intrinsic metadata to an evaluated\n   * result from a parsed CSS-like string of expressions. Intrinsics provide\n   * sufficient metadata (e.g., basis values, analogs for keywords) such that\n   * omitted values in the input string can be backfilled, and keywords can be\n   * converted to concrete numbers.\n   *\n   * The result of applying intrinsics is a tuple of NumberNode values whose\n   * units match the units used by the basis of the intrinsics.\n   *\n   * The following is a high-level description of how intrinsics are applied:\n   *\n   *  1. Determine the value of 'auto' for the current term\n   *  2. If there is no corresponding input value for this term, substitute the\n   *     'auto' value.\n   *  3. If the term is an IdentNode, treat it as a keyword and perform the\n   *     appropriate substitution.\n   *  4. If the term is still null, fallback to the 'auto' value\n   *  5. If the term is a percentage, apply it to the basis and return that\n   *     value\n   *  6. Normalize the unit of the term\n   *  7. If the term's unit does not match the basis unit, return the basis\n   *     value\n   *  8. Return the term as is\n   */\n\n\n  static applyIntrinsics(evaluated, intrinsics) {\n    const basis = intrinsics.basis,\n          keywords = intrinsics.keywords;\n    const auto = keywords.auto;\n    return basis.map((basisNode, index) => {\n      // Use an auto value if we have it, otherwise the auto value is the basis:\n      const autoSubstituteNode = auto[index] == null ? basisNode : auto[index]; // If the evaluated nodes do not have a node at the current\n      // index, fallback to the \"auto\" substitute right away:\n\n      let evaluatedNode = evaluated[index] ? evaluated[index] : autoSubstituteNode; // Any ident node is considered a keyword:\n\n      if (evaluatedNode.type === 'ident') {\n        const keyword = evaluatedNode.value; // Substitute any keywords for concrete values first:\n\n        if (keyword in keywords) {\n          evaluatedNode = keywords[keyword][index];\n        }\n      } // If we don't have a NumberNode at this point, fall back to whatever\n      // is specified for auto:\n\n\n      if (evaluatedNode == null || evaluatedNode.type === 'ident') {\n        evaluatedNode = autoSubstituteNode;\n      } // For percentages, we always apply the percentage to the basis value:\n\n\n      if (evaluatedNode.unit === '%') {\n        return numberNode(evaluatedNode.number / 100 * basisNode.number, basisNode.unit);\n      } // Otherwise, normalize whatever we have:\n\n\n      evaluatedNode = normalizeUnit(evaluatedNode, basisNode); // If the normalized units do not match, return the basis as a fallback:\n\n      if (evaluatedNode.unit !== basisNode.unit) {\n        return basisNode;\n      } // Finally, return the evaluated node with intrinsics applied:\n\n\n      return evaluatedNode;\n    });\n  }\n  /**\n   * If true, the Evaluator will only evaluate its AST one time. If false, the\n   * Evaluator will re-evaluate the AST each time that the public evaluate\n   * method is invoked.\n   */\n\n\n  get isConstant() {\n    return false;\n  }\n  /**\n   * Evaluate the Evaluator and return the result. If the Evaluator is constant,\n   * the corresponding AST will only be evaluated once, and the result of\n   * evaluating it the first time will be returned on all subsequent\n   * evaluations.\n   */\n\n\n  evaluate() {\n    if (!this.isConstant || this[$lastValue] == null) {\n      this[$lastValue] = this[$evaluate]();\n    }\n\n    return this[$lastValue];\n  }\n\n}\n_a = $lastValue;\nconst $percentage = Symbol('percentage');\nconst $basis = Symbol('basis');\n/**\n * A PercentageEvaluator scales a given basis value by a given percentage value.\n * The evaluated result is always considered to be constant.\n */\n\nexport class PercentageEvaluator extends Evaluator {\n  constructor(percentage, basis) {\n    super();\n    this[$percentage] = percentage;\n    this[$basis] = basis;\n  }\n\n  get isConstant() {\n    return true;\n  }\n\n  [$evaluate]() {\n    return numberNode(this[$percentage].number / 100 * this[$basis].number, this[$basis].unit);\n  }\n\n}\nconst $identNode = Symbol('identNode');\n/**\n * Evaluator for CSS-like env() functions. Currently, only one environment\n * variable is accepted as an argument for such functions: window-scroll-y.\n *\n * The env() Evaluator is explicitly dynamic because it always refers to\n * external state that changes as the user scrolls, so it should always be\n * re-evaluated to ensure we get the most recent value.\n *\n * Some important notes about this feature include:\n *\n *  - There is no such thing as a \"window-scroll-y\" CSS environment variable in\n *    any stable browser at the time that this comment is being written.\n *  - The actual CSS env() function accepts a second argument as a fallback for\n *    the case that the specified first argument isn't set; our syntax does not\n *    support this second argument.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/env\n */\n\nexport class EnvEvaluator extends Evaluator {\n  constructor(envFunction) {\n    super();\n    this[_b] = null;\n    const identNode = envFunction.arguments.length ? envFunction.arguments[0].terms[0] : null;\n\n    if (identNode != null && identNode.type === 'ident') {\n      this[$identNode] = identNode;\n    }\n  }\n\n  get isConstant() {\n    return false;\n  }\n\n  [(_b = $identNode, $evaluate)]() {\n    if (this[$identNode] != null) {\n      switch (this[$identNode].value) {\n        case 'window-scroll-y':\n          const verticalScrollPosition = window.pageYOffset;\n          const verticalScrollMax = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight);\n          const scrollY = verticalScrollPosition / (verticalScrollMax - window.innerHeight) || 0;\n          return {\n            type: 'number',\n            number: scrollY,\n            unit: null\n          };\n      }\n    }\n\n    return ZERO;\n  }\n\n}\nconst IS_MULTIPLICATION_RE = /[\\*\\/]/;\nconst $evaluator = Symbol('evalutor');\n/**\n * Evaluator for CSS-like calc() functions. Our implementation of calc()\n * evaluation currently support nested function calls, an unlimited number of\n * terms, and all four algebraic operators (+, -, * and /).\n *\n * The Evaluator is marked as constant unless the calc expression contains an\n * internal env expression at any depth, in which case it will be marked as\n * dynamic.\n *\n * @see https://www.w3.org/TR/css-values-3/#calc-syntax\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/calc\n */\n\nexport class CalcEvaluator extends Evaluator {\n  constructor(calcFunction, basis = ZERO) {\n    super();\n    this[_c] = null;\n\n    if (calcFunction.arguments.length !== 1) {\n      return;\n    }\n\n    const terms = calcFunction.arguments[0].terms.slice();\n    const secondOrderTerms = [];\n\n    while (terms.length) {\n      const term = terms.shift();\n\n      if (secondOrderTerms.length > 0) {\n        const previousTerm = secondOrderTerms[secondOrderTerms.length - 1];\n\n        if (previousTerm.type === 'operator' && IS_MULTIPLICATION_RE.test(previousTerm.value)) {\n          const operator = secondOrderTerms.pop();\n          const leftValue = secondOrderTerms.pop();\n\n          if (leftValue == null) {\n            return;\n          }\n\n          secondOrderTerms.push(new OperatorEvaluator(operator, Evaluator.evaluatableFor(leftValue, basis), Evaluator.evaluatableFor(term, basis)));\n          continue;\n        }\n      }\n\n      secondOrderTerms.push(term.type === 'operator' ? term : Evaluator.evaluatableFor(term, basis));\n    }\n\n    while (secondOrderTerms.length > 2) {\n      const _secondOrderTerms$spl = secondOrderTerms.splice(0, 3),\n            _secondOrderTerms$spl2 = _slicedToArray(_secondOrderTerms$spl, 3),\n            left = _secondOrderTerms$spl2[0],\n            operator = _secondOrderTerms$spl2[1],\n            right = _secondOrderTerms$spl2[2];\n\n      if (operator.type !== 'operator') {\n        return;\n      }\n\n      secondOrderTerms.unshift(new OperatorEvaluator(operator, Evaluator.evaluatableFor(left, basis), Evaluator.evaluatableFor(right, basis)));\n    } // There should only be one combined evaluator at this point:\n\n\n    if (secondOrderTerms.length === 1) {\n      this[$evaluator] = secondOrderTerms[0];\n    }\n  }\n\n  get isConstant() {\n    return this[$evaluator] == null || Evaluator.isConstant(this[$evaluator]);\n  }\n\n  [(_c = $evaluator, $evaluate)]() {\n    return this[$evaluator] != null ? Evaluator.evaluate(this[$evaluator]) : ZERO;\n  }\n\n}\nconst $operator = Symbol('operator');\nconst $left = Symbol('left');\nconst $right = Symbol('right');\n/**\n * An Evaluator for the operators found inside CSS calc() functions.\n * The evaluator accepts an operator and left/right operands. The operands can\n * be any valid expression term typically allowed inside a CSS calc function.\n *\n * As detail of this implementation, the only supported unit types are angles\n * expressed as radians or degrees, and lengths expressed as meters, centimeters\n * or millimeters.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/calc\n */\n\nexport class OperatorEvaluator extends Evaluator {\n  constructor(operator, left, right) {\n    super();\n    this[$operator] = operator;\n    this[$left] = left;\n    this[$right] = right;\n  }\n\n  get isConstant() {\n    return Evaluator.isConstant(this[$left]) && Evaluator.isConstant(this[$right]);\n  }\n\n  [$evaluate]() {\n    const leftNode = normalizeUnit(Evaluator.evaluate(this[$left]));\n    const rightNode = normalizeUnit(Evaluator.evaluate(this[$right]));\n    const leftValue = leftNode.number,\n          leftUnit = leftNode.unit;\n    const rightValue = rightNode.number,\n          rightUnit = rightNode.unit; // Disallow operations for mismatched normalized units e.g., m and rad:\n\n    if (rightUnit != null && leftUnit != null && rightUnit != leftUnit) {\n      return ZERO;\n    } // NOTE(cdata): rules for calc type checking are defined here\n    // https://drafts.csswg.org/css-values-3/#calc-type-checking\n    // This is a simplification and may not hold up once we begin to support\n    // additional unit types:\n\n\n    const unit = leftUnit || rightUnit;\n    let value;\n\n    switch (this[$operator].value) {\n      case '+':\n        value = leftValue + rightValue;\n        break;\n\n      case '-':\n        value = leftValue - rightValue;\n        break;\n\n      case '/':\n        value = leftValue / rightValue;\n        break;\n\n      case '*':\n        value = leftValue * rightValue;\n        break;\n\n      default:\n        return ZERO;\n    }\n\n    return {\n      type: 'number',\n      number: value,\n      unit\n    };\n  }\n\n}\nconst $evaluatables = Symbol('evaluatables');\nconst $intrinsics = Symbol('intrinsics');\n/**\n * A VectorEvaluator evaluates a series of numeric terms that usually represent\n * a data structure such as a multi-dimensional vector or a spherical\n *\n * The form of the evaluator's result is determined by the Intrinsics that are\n * given to it when it is constructed. For example, spherical intrinsics would\n * establish two angle terms and a length term, so the result of evaluating the\n * evaluator that is configured with spherical intrinsics is a three element\n * array where the first two elements represent angles in radians and the third\n * element representing a length in meters.\n */\n\nexport class StyleEvaluator extends Evaluator {\n  constructor(expressions, intrinsics) {\n    super();\n    this[$intrinsics] = intrinsics;\n    const firstExpression = expressions[0];\n    const terms = firstExpression != null ? firstExpression.terms : [];\n    this[$evaluatables] = intrinsics.basis.map((basisNode, index) => {\n      const term = terms[index];\n\n      if (term == null) {\n        return {\n          type: 'ident',\n          value: 'auto'\n        };\n      }\n\n      if (term.type === 'ident') {\n        return term;\n      }\n\n      return Evaluator.evaluatableFor(term, basisNode);\n    });\n  }\n\n  get isConstant() {\n    for (const evaluatable of this[$evaluatables]) {\n      if (!Evaluator.isConstant(evaluatable)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  [$evaluate]() {\n    const evaluated = this[$evaluatables].map(evaluatable => Evaluator.evaluate(evaluatable));\n    return Evaluator.applyIntrinsics(evaluated, this[$intrinsics]).map(numberNode => numberNode.number);\n  }\n\n}","map":{"version":3,"sources":["../../src/styles/evaluators.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {normalizeUnit} from './conversions';\nimport {ExpressionNode, ExpressionTerm, FunctionNode, IdentNode, NumberNode, numberNode, OperatorNode, Percentage, Unit, ZERO} from './parsers';\n\nexport type Evaluatable<T> = Evaluator<T>|T;\n\n/**\n * A NumberNodeSequence is a vector of NumberNodes with a specified\n * sequence of units.\n */\nexport type NumberNodeSequence<T extends Array<Unit>, U = never> = {\n  [I in keyof T]:\n      NumberNode&{\n        unit: T[I]|U;\n      };\n};\n\nexport type Sparse<T> = {\n  [I in keyof T]: null|T[I];\n};\n\n/**\n * Intrinsics describe the metadata required to do four things for any given\n * type of number-based CSS expression:\n *\n *  1. Establish the expected units of a final, evaluated result\n *  2. Provide a foundational value that percentages should scale against\n *  3. Describe the analog number values that correspond to various keywords\n *  4. Have an available concrete value to fallback to when needed\n *\n * Intrinsics must always specify a basis and the substitute values for the\n * keyword 'auto'.\n *\n * Intrinsics may optionally specify the substitute values for any additional\n * number of keywords.\n */\nexport interface Intrinsics<T extends Array<Unit> = []> {\n  basis: NumberNodeSequence<T>;\n  keywords: {\n    auto: Sparse<NumberNodeSequence<T, Percentage>>;\n    [index: string]: Sparse<NumberNodeSequence<T, Percentage>>;\n  };\n}\n\nconst $evaluate = Symbol('evaluate');\nconst $lastValue = Symbol('lastValue');\n\n/**\n * An Evaluator is used to derive a computed style from part (or all) of a CSS\n * expression AST. This construct is particularly useful for complex ASTs\n * containing function calls such as calc, var and env. Such styles could be\n * costly to re-evaluate on every frame (and in some cases we may try to do\n * that). The Evaluator construct allows us to mark sub-trees of the AST as\n * constant, so that only the dynamic parts are re-evaluated. It also separates\n * one-time AST preparation work from work that necessarily has to happen upon\n * each evaluation.\n */\nexport abstract class Evaluator<T> {\n  /**\n   * An Evaluatable is a NumberNode or an Evaluator that evaluates a NumberNode\n   * as the result of invoking its evaluate method. This is mainly used to\n   * ensure that CSS function nodes are cast to the corresponding Evaluators\n   * that will resolve the result of the function, but is also used to ensure\n   * that a percentage nested at arbitrary depth in the expression will always\n   * be evaluated against the correct basis.\n   */\n  static evaluatableFor(\n      node: ExpressionTerm|Evaluator<NumberNode>,\n      basis: NumberNode = ZERO): Evaluatable<NumberNode> {\n    if (node instanceof Evaluator) {\n      return node;\n    }\n\n    if (node.type === 'number') {\n      if (node.unit === '%') {\n        return new PercentageEvaluator(node as NumberNode<'%'>, basis);\n      }\n      return node;\n    }\n\n    switch ((node as FunctionNode).name.value) {\n      case 'calc':\n        return new CalcEvaluator(node as FunctionNode, basis);\n      case 'env':\n        return new EnvEvaluator(node as FunctionNode);\n    }\n\n    return ZERO;\n  }\n\n  /**\n   * If the input is an Evaluator, returns the result of evaluating it.\n   * Otherwise, returns the input.\n   *\n   * This is a helper to aide in resolving a NumberNode without conditionally\n   * checking if the Evaluatable is an Evaluator everywhere.\n   */\n  static evaluate<T extends NumberNode|IdentNode>(evaluatable: Evaluatable<T>):\n      T {\n    if (evaluatable instanceof Evaluator) {\n      return evaluatable.evaluate();\n    }\n\n    return evaluatable;\n  }\n\n  /**\n   * If the input is an Evaluator, returns the value of its isConstant property.\n   * Returns true for all other input values.\n   */\n  static isConstant<T>(evaluatable: Evaluatable<T>): boolean {\n    if (evaluatable instanceof Evaluator) {\n      return evaluatable.isConstant;\n    }\n    return true;\n  }\n\n  /**\n   * This method applies a set of structured intrinsic metadata to an evaluated\n   * result from a parsed CSS-like string of expressions. Intrinsics provide\n   * sufficient metadata (e.g., basis values, analogs for keywords) such that\n   * omitted values in the input string can be backfilled, and keywords can be\n   * converted to concrete numbers.\n   *\n   * The result of applying intrinsics is a tuple of NumberNode values whose\n   * units match the units used by the basis of the intrinsics.\n   *\n   * The following is a high-level description of how intrinsics are applied:\n   *\n   *  1. Determine the value of 'auto' for the current term\n   *  2. If there is no corresponding input value for this term, substitute the\n   *     'auto' value.\n   *  3. If the term is an IdentNode, treat it as a keyword and perform the\n   *     appropriate substitution.\n   *  4. If the term is still null, fallback to the 'auto' value\n   *  5. If the term is a percentage, apply it to the basis and return that\n   *     value\n   *  6. Normalize the unit of the term\n   *  7. If the term's unit does not match the basis unit, return the basis\n   *     value\n   *  8. Return the term as is\n   */\n  static applyIntrinsics<T extends Array<Unit>>(\n      evaluated: Array<any>, intrinsics: Intrinsics<T>): NumberNodeSequence<T> {\n    const {basis, keywords} = intrinsics;\n    const {auto} = keywords;\n\n    return basis.map<NumberNode>((basisNode, index) => {\n      // Use an auto value if we have it, otherwise the auto value is the basis:\n      const autoSubstituteNode = auto[index] == null ? basisNode : auto[index];\n\n      // If the evaluated nodes do not have a node at the current\n      // index, fallback to the \"auto\" substitute right away:\n      let evaluatedNode =\n          evaluated[index] ? evaluated[index] : autoSubstituteNode;\n\n      // Any ident node is considered a keyword:\n      if (evaluatedNode.type === 'ident') {\n        const keyword = evaluatedNode.value;\n        // Substitute any keywords for concrete values first:\n        if (keyword in keywords) {\n          evaluatedNode = keywords[keyword][index];\n        }\n      }\n\n      // If we don't have a NumberNode at this point, fall back to whatever\n      // is specified for auto:\n      if (evaluatedNode == null || evaluatedNode.type === 'ident') {\n        evaluatedNode = autoSubstituteNode;\n      }\n\n      // For percentages, we always apply the percentage to the basis value:\n      if (evaluatedNode.unit === '%') {\n        return numberNode(\n            evaluatedNode.number / 100 * basisNode.number, basisNode.unit);\n      }\n\n      // Otherwise, normalize whatever we have:\n      evaluatedNode = normalizeUnit(evaluatedNode, basisNode);\n\n      // If the normalized units do not match, return the basis as a fallback:\n      if (evaluatedNode.unit !== basisNode.unit) {\n        return basisNode;\n      }\n\n      // Finally, return the evaluated node with intrinsics applied:\n      return evaluatedNode;\n    }) as NumberNodeSequence<T>;\n  }\n\n  /**\n   * If true, the Evaluator will only evaluate its AST one time. If false, the\n   * Evaluator will re-evaluate the AST each time that the public evaluate\n   * method is invoked.\n   */\n  get isConstant(): boolean {\n    return false;\n  }\n\n  protected[$lastValue]: T|null = null;\n\n  /**\n   * This method must be implemented by subclasses. Its implementation should be\n   * the actual steps to evaluate the AST, and should return the evaluated\n   * result.\n   */\n  protected abstract[$evaluate](): T;\n\n  /**\n   * Evaluate the Evaluator and return the result. If the Evaluator is constant,\n   * the corresponding AST will only be evaluated once, and the result of\n   * evaluating it the first time will be returned on all subsequent\n   * evaluations.\n   */\n  evaluate(): T {\n    if (!this.isConstant || this[$lastValue] == null) {\n      this[$lastValue] = this[$evaluate]();\n    }\n    return this[$lastValue]!;\n  }\n}\n\n\nconst $percentage = Symbol('percentage');\nconst $basis = Symbol('basis');\n\n\n/**\n * A PercentageEvaluator scales a given basis value by a given percentage value.\n * The evaluated result is always considered to be constant.\n */\nexport class PercentageEvaluator extends Evaluator<NumberNode> {\n  protected[$percentage]: NumberNode<'%'>;\n  protected[$basis]: NumberNode;\n\n  constructor(percentage: NumberNode<'%'>, basis: NumberNode) {\n    super();\n\n    this[$percentage] = percentage;\n    this[$basis] = basis;\n  }\n\n  get isConstant() {\n    return true;\n  }\n\n  [$evaluate]() {\n    return numberNode(\n        this[$percentage].number / 100 * this[$basis].number,\n        this[$basis].unit);\n  }\n}\n\n\nconst $identNode = Symbol('identNode');\n\n/**\n * Evaluator for CSS-like env() functions. Currently, only one environment\n * variable is accepted as an argument for such functions: window-scroll-y.\n *\n * The env() Evaluator is explicitly dynamic because it always refers to\n * external state that changes as the user scrolls, so it should always be\n * re-evaluated to ensure we get the most recent value.\n *\n * Some important notes about this feature include:\n *\n *  - There is no such thing as a \"window-scroll-y\" CSS environment variable in\n *    any stable browser at the time that this comment is being written.\n *  - The actual CSS env() function accepts a second argument as a fallback for\n *    the case that the specified first argument isn't set; our syntax does not\n *    support this second argument.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/env\n */\nexport class EnvEvaluator extends Evaluator<NumberNode> {\n  protected[$identNode]: IdentNode|null = null;\n\n  constructor(envFunction: FunctionNode) {\n    super();\n\n    const identNode =\n        envFunction.arguments.length ? envFunction.arguments[0].terms[0] : null;\n\n    if (identNode != null && identNode.type === 'ident') {\n      this[$identNode] = identNode;\n    }\n  }\n\n  get isConstant(): boolean {\n    return false;\n  };\n\n  [$evaluate](): NumberNode {\n    if (this[$identNode] != null) {\n      switch (this[$identNode]!.value) {\n        case 'window-scroll-y':\n          const verticalScrollPosition = window.pageYOffset;\n          const verticalScrollMax = Math.max(\n              document.body.scrollHeight,\n              document.body.offsetHeight,\n              document.documentElement.clientHeight,\n              document.documentElement.scrollHeight,\n              document.documentElement.offsetHeight);\n          const scrollY = verticalScrollPosition /\n                  (verticalScrollMax - window.innerHeight) ||\n              0;\n\n          return {type: 'number', number: scrollY, unit: null};\n      }\n    }\n\n    return ZERO;\n  }\n}\n\n\nconst IS_MULTIPLICATION_RE = /[\\*\\/]/;\nconst $evaluator = Symbol('evalutor');\n\n/**\n * Evaluator for CSS-like calc() functions. Our implementation of calc()\n * evaluation currently support nested function calls, an unlimited number of\n * terms, and all four algebraic operators (+, -, * and /).\n *\n * The Evaluator is marked as constant unless the calc expression contains an\n * internal env expression at any depth, in which case it will be marked as\n * dynamic.\n *\n * @see https://www.w3.org/TR/css-values-3/#calc-syntax\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/calc\n */\nexport class CalcEvaluator extends Evaluator<NumberNode> {\n  protected[$evaluator]: Evaluator<NumberNode>|null = null;\n\n  constructor(calcFunction: FunctionNode, basis: NumberNode = ZERO) {\n    super();\n\n    if (calcFunction.arguments.length !== 1) {\n      return;\n    }\n\n    const terms: Array<ExpressionTerm> =\n        calcFunction.arguments[0].terms.slice();\n    const secondOrderTerms: Array<ExpressionTerm|Evaluator<NumberNode>> = [];\n\n    while (terms.length) {\n      const term: ExpressionTerm = terms.shift()!;\n\n      if (secondOrderTerms.length > 0) {\n        const previousTerm =\n            secondOrderTerms[secondOrderTerms.length - 1] as ExpressionTerm;\n        if (previousTerm.type === 'operator' &&\n            IS_MULTIPLICATION_RE.test(previousTerm.value)) {\n          const operator = secondOrderTerms.pop() as OperatorNode;\n          const leftValue = secondOrderTerms.pop();\n\n          if (leftValue == null) {\n            return;\n          }\n\n          secondOrderTerms.push(new OperatorEvaluator(\n              operator,\n              Evaluator.evaluatableFor(leftValue, basis),\n              Evaluator.evaluatableFor(term, basis)));\n          continue;\n        }\n      }\n\n      secondOrderTerms.push(\n          term.type === 'operator' ? term :\n                                     Evaluator.evaluatableFor(term, basis));\n    }\n\n    while (secondOrderTerms.length > 2) {\n      const [left, operator, right] = secondOrderTerms.splice(0, 3);\n      if ((operator as ExpressionTerm).type !== 'operator') {\n        return;\n      }\n\n      secondOrderTerms.unshift(new OperatorEvaluator(\n          operator as OperatorNode,\n          Evaluator.evaluatableFor(left, basis),\n          Evaluator.evaluatableFor(right, basis)));\n    }\n\n    // There should only be one combined evaluator at this point:\n    if (secondOrderTerms.length === 1) {\n      this[$evaluator] = secondOrderTerms[0] as Evaluator<NumberNode>;\n    }\n  }\n\n  get isConstant() {\n    return this[$evaluator] == null || Evaluator.isConstant(this[$evaluator]!);\n  }\n\n  [$evaluate]() {\n    return this[$evaluator] != null ? Evaluator.evaluate(this[$evaluator]!) :\n                                      ZERO;\n  }\n}\n\n\n\nconst $operator = Symbol('operator');\nconst $left = Symbol('left');\nconst $right = Symbol('right');\n\n/**\n * An Evaluator for the operators found inside CSS calc() functions.\n * The evaluator accepts an operator and left/right operands. The operands can\n * be any valid expression term typically allowed inside a CSS calc function.\n *\n * As detail of this implementation, the only supported unit types are angles\n * expressed as radians or degrees, and lengths expressed as meters, centimeters\n * or millimeters.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/calc\n */\nexport class OperatorEvaluator extends Evaluator<NumberNode> {\n  protected[$operator]: OperatorNode;\n  protected[$left]: Evaluatable<NumberNode>;\n  protected[$right]: Evaluatable<NumberNode>;\n\n  constructor(\n      operator: OperatorNode, left: Evaluatable<NumberNode>,\n      right: Evaluatable<NumberNode>) {\n    super();\n    this[$operator] = operator;\n    this[$left] = left;\n    this[$right] = right;\n  }\n\n  get isConstant() {\n    return Evaluator.isConstant(this[$left]) &&\n        Evaluator.isConstant(this[$right]);\n  }\n\n  [$evaluate](): NumberNode {\n    const leftNode = normalizeUnit(Evaluator.evaluate(this[$left]));\n    const rightNode = normalizeUnit(Evaluator.evaluate(this[$right]));\n    const {number: leftValue, unit: leftUnit} = leftNode;\n    const {number: rightValue, unit: rightUnit} = rightNode;\n\n    // Disallow operations for mismatched normalized units e.g., m and rad:\n    if (rightUnit != null && leftUnit != null && rightUnit != leftUnit) {\n      return ZERO;\n    }\n\n    // NOTE(cdata): rules for calc type checking are defined here\n    // https://drafts.csswg.org/css-values-3/#calc-type-checking\n    // This is a simplification and may not hold up once we begin to support\n    // additional unit types:\n    const unit = leftUnit || rightUnit;\n    let value;\n\n    switch (this[$operator].value) {\n      case '+':\n        value = leftValue + rightValue;\n        break;\n      case '-':\n        value = leftValue - rightValue;\n        break;\n      case '/':\n        value = leftValue / rightValue;\n        break;\n      case '*':\n        value = leftValue * rightValue;\n        break;\n      default:\n        return ZERO;\n    }\n\n    return {type: 'number', number: value, unit};\n  }\n}\n\n\nexport type EvaluatedStyle<T extends Intrinsics<Array<Unit>>> = {\n  [I in keyof T['basis']]: number;\n}&Array<never>;\n\nconst $evaluatables = Symbol('evaluatables');\nconst $intrinsics = Symbol('intrinsics');\n\n/**\n * A VectorEvaluator evaluates a series of numeric terms that usually represent\n * a data structure such as a multi-dimensional vector or a spherical\n *\n * The form of the evaluator's result is determined by the Intrinsics that are\n * given to it when it is constructed. For example, spherical intrinsics would\n * establish two angle terms and a length term, so the result of evaluating the\n * evaluator that is configured with spherical intrinsics is a three element\n * array where the first two elements represent angles in radians and the third\n * element representing a length in meters.\n */\nexport class StyleEvaluator<T extends Intrinsics<Array<any>>> extends\n    Evaluator<EvaluatedStyle<T>> {\n  protected[$intrinsics]: T;\n  protected[$evaluatables]: Array<Evaluatable<NumberNode|IdentNode>>;\n\n  constructor(expressions: Array<ExpressionNode>, intrinsics: T) {\n    super();\n\n    this[$intrinsics] = intrinsics;\n\n    const firstExpression = expressions[0];\n    const terms = firstExpression != null ? firstExpression.terms : [];\n\n    this[$evaluatables] =\n        intrinsics.basis.map<Evaluatable<NumberNode|IdentNode>>(\n            (basisNode, index) => {\n              const term = terms[index];\n              if (term == null) {\n                return {type: 'ident', value: 'auto'};\n              }\n\n              if (term.type === 'ident') {\n                return term;\n              }\n\n              return Evaluator.evaluatableFor(term, basisNode);\n            });\n  }\n\n  get isConstant(): boolean {\n    for (const evaluatable of this[$evaluatables]) {\n      if (!Evaluator.isConstant(evaluatable)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  [$evaluate]() {\n    const evaluated = this[$evaluatables].map<NumberNode|IdentNode>(\n        evaluatable => Evaluator.evaluate(evaluatable));\n    return Evaluator.applyIntrinsics(evaluated, this[$intrinsics])\n               .map<number>(numberNode => numberNode.number) as\n        EvaluatedStyle<T>;\n  }\n}\n\n// SphericalIntrinsics are Intrinsics that expect two angle terms\n// and one length term\nexport type SphericalIntrinsics = Intrinsics<['rad', 'rad', 'm']>;\n// Vector3Intrinsics expect three length terms\nexport type Vector3Intrinsics = Intrinsics<['m', 'm', 'm']>;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}