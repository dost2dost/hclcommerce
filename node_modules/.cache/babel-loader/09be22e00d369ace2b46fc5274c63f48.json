{"ast":null,"code":"/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { ThreeDOMExecutionContext } from '@google/3dom/lib/context.js';\nimport { ModelGraft } from '@google/3dom/lib/facade/three-js/model-graft.js';\nimport { property } from 'lit-element';\nimport { $needsRender, $onModelLoad, $scene } from '../model-viewer-base.js';\nconst SCENE_GRAPH_SCRIPT_TYPE = 'experimental-scene-graph-worklet';\nconst VALID_CAPABILITIES = new Set(['messaging', 'fetch', 'material-properties']);\nconst $onChildListMutation = Symbol('onChildListMutation');\nconst $childListMutationHandler = Symbol('childListMutationHandler');\nconst $mutationObserver = Symbol('mutationObserver');\nconst $createExecutionContext = Symbol('createExecutionContext');\nconst $onScriptElementAdded = Symbol('onScriptElementAdded');\nconst $executionContext = Symbol('executionContext');\nconst $updateExecutionContextModel = Symbol('updateExecutionContextModel');\nconst $modelGraft = Symbol('modelGraft');\nconst $onModelGraftMutation = Symbol('onModelGraftMutation');\nconst $modelGraftMutationHandler = Symbol('modelGraftMutationHandler');\nconst $isValid3DOMScript = Symbol('isValid3DOMScript');\n/**\n * SceneGraphMixin manages a `<model-viewer>` integration with the 3DOM library\n * in order to support custom scripts that operate on the <model-viewer> scene\n * graph.\n *\n * When applied, users can specify a special `<script>` type that can be added\n * as a child of `<model-viewer>`. The script will be invoked in a special\n * Web Worker, conventionally referred to as a \"scene graph worklet.\"\n *\n * Script on the browser main thread can communicate with the scene graph\n * worklet via `modelViewer.worklet` using `postMessage`, much like they would\n * with any other Web Worker.\n *\n * Scene graph worklet scripts must be bestowed capabilities by the author of\n * the `<model-viewer>` markup. The three capabilities currently available\n * include:\n *\n *  - `messaging`: The ability to communicate with other contexts via\n *    `postMessage` and `MessageChannel`\n *  - `fetch`: Access to the global `fetch` method for network operations\n *  - `material-properties`: The ability to manipulate the basic properties of\n *    a Material and its associated constructs in the scene graph\n *\n * A trivial example of creating a scene graph worklet that can manipulate\n * material properties looks like this:\n *\n * ```html\n * <model-viewer>\n *   <script type=\"experimental-scene-graph-worklet\"\n *       allow=\"material-properties\">\n *\n *     console.log('Hello from the scene graph worklet!');\n *\n *     self.addEventListener('model-change', () => {\n *       model.materials[0].pbrMetallicRoughness\n *         .setBaseColorFactor([1, 0, 0, 1]);\n *     });\n *\n *   </script>\n * </model-viewer>\n * ```\n *\n * Only one worklet is allowed per `<model-viewer>` at a time. If a new worklet\n * script is appended to a `<model-viewer>` with a running worklet, a new\n * worklet will be created and the previous one will be terminated. If there\n * is more than one worklet script at HTML parse time, the last one in tree\n * order will be used.\n *\n * When a worklet is created, `<model-viewer>` will dispatch a 'worklet-created'\n * event. At the time that this event is dispatched, the worklet will be created\n * but the model is not guaranteed to have been made available to the worklet.\n */\n\nexport const SceneGraphMixin = ModelViewerElement => {\n  var _a, _b, _c, _d;\n\n  var _e;\n\n  class SceneGraphModelViewerElement extends ModelViewerElement {\n    constructor() {\n      super(...arguments);\n      this[_e] = null;\n\n      this[_a] = records => this[$onChildListMutation](records);\n\n      this[_b] = event => this[$onModelGraftMutation](event);\n\n      this[_c] = new MutationObserver(this[$childListMutationHandler]);\n      this[_d] = null;\n    }\n    /**\n     * A reference to the active worklet if one exists, or else `null`. A\n     * worklet is not created until a scene graph worklet script has been\n     * detected as a child of this `<model-viewer>`.\n     */\n\n\n    get worklet() {\n      const executionContext = this[$executionContext];\n      return executionContext != null ? executionContext.worker : null;\n    }\n\n    connectedCallback() {\n      super.connectedCallback();\n      this[$mutationObserver].observe(this, {\n        childList: true\n      });\n      const script = this.querySelector(`script[type=\"${SCENE_GRAPH_SCRIPT_TYPE}\"]:last-of-type`);\n\n      if (script != null && this[$isValid3DOMScript](script)) {\n        this[$onScriptElementAdded](script);\n      }\n    }\n\n    async disconnectedCallback() {\n      super.disconnectedCallback();\n      this[$mutationObserver].disconnect();\n      const executionContext = this[$executionContext];\n\n      if (executionContext != null) {\n        await executionContext.terminate();\n        this[$executionContext] = null;\n      }\n    }\n\n    updated(changedProperties) {\n      super.updated(changedProperties);\n\n      if (changedProperties.has($modelGraft)) {\n        const oldModelGraft = changedProperties.get($modelGraft);\n\n        if (oldModelGraft != null) {\n          oldModelGraft.removeEventListener('mutation', this[$modelGraftMutationHandler]);\n        }\n\n        const modelGraft = this[$modelGraft];\n\n        if (modelGraft != null) {\n          modelGraft.addEventListener('mutation', this[$modelGraftMutationHandler]);\n        }\n      }\n    }\n\n    [(_e = $modelGraft, _a = $childListMutationHandler, _b = $modelGraftMutationHandler, _c = $mutationObserver, _d = $executionContext, $onModelLoad)](event) {\n      super[$onModelLoad](event);\n      this[$updateExecutionContextModel]();\n    }\n\n    [$isValid3DOMScript](node) {\n      return node instanceof HTMLScriptElement && (node.textContent || node.src) && node.getAttribute('type') === SCENE_GRAPH_SCRIPT_TYPE;\n    }\n\n    [$onChildListMutation](records) {\n      if (this.parentNode == null) {\n        // Ignore a lazily reported list of mutations if we are detached from\n        // the document...\n        return;\n      }\n\n      let lastScriptElement = null;\n\n      for (const record of records) {\n        for (const node of Array.from(record.addedNodes)) {\n          if (this[$isValid3DOMScript](node)) {\n            lastScriptElement = node;\n          }\n        }\n      }\n\n      if (lastScriptElement != null) {\n        this[$onScriptElementAdded](lastScriptElement);\n      }\n    }\n\n    [$onScriptElementAdded](script) {\n      if (!this[$isValid3DOMScript](script)) {\n        return;\n      }\n\n      const allowString = script.getAttribute('allow') || '';\n      const allowList = allowString.split(';').map(fragment => fragment.trim()).filter(capability => VALID_CAPABILITIES.has(capability));\n\n      if (script.src) {\n        this[$createExecutionContext](script.src, allowList);\n      } else {\n        this[$createExecutionContext](script.textContent, allowList, {\n          eval: true\n        });\n      }\n    }\n\n    async [$createExecutionContext](scriptSource, capabilities, options = {\n      eval: false\n    }) {\n      let executionContext = this[$executionContext];\n\n      if (executionContext != null) {\n        await executionContext.terminate();\n      }\n\n      this[$executionContext] = executionContext = new ThreeDOMExecutionContext(capabilities);\n      this.dispatchEvent(new CustomEvent('worklet-created', {\n        detail: {\n          worklet: this.worklet\n        }\n      }));\n\n      if (options.eval) {\n        await executionContext.eval(scriptSource);\n      } else {\n        await executionContext.import(scriptSource);\n      }\n\n      this[$updateExecutionContextModel]();\n    }\n\n    [$updateExecutionContextModel]() {\n      const executionContext = this[$executionContext];\n\n      if (executionContext == null || this.parentNode == null) {\n        // Ignore if we don't have a 3DOM script to run, or if we are currently\n        // detached from the document\n        return;\n      }\n\n      const scene = this[$scene];\n      const modelGraft = this.loaded ? // TODO: Use a proper GLTF artifact as cached by the loader for this:\n      new ModelGraft(scene.model.url || '', {\n        scene: scene,\n        scenes: [scene],\n        animations: [],\n        cameras: [],\n        parser: {},\n        asset: {},\n        userData: {}\n      }) : null;\n      executionContext.changeModel(modelGraft);\n      this[$modelGraft] = modelGraft;\n    }\n\n    [$onModelGraftMutation](_event) {\n      this[$needsRender]();\n    }\n\n  }\n\n  __decorate([property({\n    type: Object\n  })], SceneGraphModelViewerElement.prototype, _e, void 0);\n\n  return SceneGraphModelViewerElement;\n};","map":{"version":3,"sources":["../../src/features/scene-graph.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {ThreeDOMCapability} from '@google/3dom/lib/api.js';\nimport {ThreeDOMExecutionContext} from '@google/3dom/lib/context.js';\nimport {ModelGraft} from '@google/3dom/lib/facade/three-js/model-graft.js';\nimport {property} from 'lit-element';\nimport {Group} from 'three';\nimport {GLTFParser} from 'three/examples/jsm/loaders/GLTFLoader';\n\nimport ModelViewerElementBase, {$needsRender, $onModelLoad, $scene} from '../model-viewer-base.js';\nimport {Constructor} from '../utilities.js';\n\nconst SCENE_GRAPH_SCRIPT_TYPE = 'experimental-scene-graph-worklet';\nconst VALID_CAPABILITIES: Set<ThreeDOMCapability> =\n    new Set(['messaging', 'fetch', 'material-properties']);\n\nconst $onChildListMutation = Symbol('onChildListMutation');\nconst $childListMutationHandler = Symbol('childListMutationHandler');\nconst $mutationObserver = Symbol('mutationObserver');\nconst $createExecutionContext = Symbol('createExecutionContext');\nconst $onScriptElementAdded = Symbol('onScriptElementAdded');\nconst $executionContext = Symbol('executionContext');\nconst $updateExecutionContextModel = Symbol('updateExecutionContextModel');\nconst $modelGraft = Symbol('modelGraft');\nconst $onModelGraftMutation = Symbol('onModelGraftMutation');\nconst $modelGraftMutationHandler = Symbol('modelGraftMutationHandler');\nconst $isValid3DOMScript = Symbol('isValid3DOMScript');\n\nexport interface SceneGraphInterface {\n  worklet: Worker|null;\n}\n\n/**\n * SceneGraphMixin manages a `<model-viewer>` integration with the 3DOM library\n * in order to support custom scripts that operate on the <model-viewer> scene\n * graph.\n *\n * When applied, users can specify a special `<script>` type that can be added\n * as a child of `<model-viewer>`. The script will be invoked in a special\n * Web Worker, conventionally referred to as a \"scene graph worklet.\"\n *\n * Script on the browser main thread can communicate with the scene graph\n * worklet via `modelViewer.worklet` using `postMessage`, much like they would\n * with any other Web Worker.\n *\n * Scene graph worklet scripts must be bestowed capabilities by the author of\n * the `<model-viewer>` markup. The three capabilities currently available\n * include:\n *\n *  - `messaging`: The ability to communicate with other contexts via\n *    `postMessage` and `MessageChannel`\n *  - `fetch`: Access to the global `fetch` method for network operations\n *  - `material-properties`: The ability to manipulate the basic properties of\n *    a Material and its associated constructs in the scene graph\n *\n * A trivial example of creating a scene graph worklet that can manipulate\n * material properties looks like this:\n *\n * ```html\n * <model-viewer>\n *   <script type=\"experimental-scene-graph-worklet\"\n *       allow=\"material-properties\">\n *\n *     console.log('Hello from the scene graph worklet!');\n *\n *     self.addEventListener('model-change', () => {\n *       model.materials[0].pbrMetallicRoughness\n *         .setBaseColorFactor([1, 0, 0, 1]);\n *     });\n *\n *   </script>\n * </model-viewer>\n * ```\n *\n * Only one worklet is allowed per `<model-viewer>` at a time. If a new worklet\n * script is appended to a `<model-viewer>` with a running worklet, a new\n * worklet will be created and the previous one will be terminated. If there\n * is more than one worklet script at HTML parse time, the last one in tree\n * order will be used.\n *\n * When a worklet is created, `<model-viewer>` will dispatch a 'worklet-created'\n * event. At the time that this event is dispatched, the worklet will be created\n * but the model is not guaranteed to have been made available to the worklet.\n */\nexport const SceneGraphMixin = <T extends Constructor<ModelViewerElementBase>>(\n    ModelViewerElement: T): Constructor<SceneGraphInterface>&T => {\n  class SceneGraphModelViewerElement extends ModelViewerElement {\n    @property({type: Object}) protected[$modelGraft]: ModelGraft|null = null;\n\n    protected[$childListMutationHandler] = (records: Array<MutationRecord>) =>\n        this[$onChildListMutation](records);\n\n    protected[$modelGraftMutationHandler] = (event: Event) =>\n        this[$onModelGraftMutation](event);\n\n    protected[$mutationObserver] =\n        new MutationObserver(this[$childListMutationHandler]);\n\n    protected[$executionContext]: ThreeDOMExecutionContext|null = null;\n\n    /**\n     * A reference to the active worklet if one exists, or else `null`. A\n     * worklet is not created until a scene graph worklet script has been\n     * detected as a child of this `<model-viewer>`.\n     */\n    get worklet() {\n      const executionContext = this[$executionContext];\n      return executionContext != null ? executionContext.worker : null;\n    }\n\n    connectedCallback() {\n      super.connectedCallback();\n\n      this[$mutationObserver].observe(this, {childList: true});\n\n      const script = this.querySelector<HTMLScriptElement>(\n          `script[type=\"${SCENE_GRAPH_SCRIPT_TYPE}\"]:last-of-type`);\n\n      if (script != null && this[$isValid3DOMScript](script)) {\n        this[$onScriptElementAdded](script);\n      }\n    }\n\n    async disconnectedCallback() {\n      super.disconnectedCallback();\n\n      this[$mutationObserver].disconnect();\n\n      const executionContext = this[$executionContext];\n\n      if (executionContext != null) {\n        await executionContext.terminate();\n        this[$executionContext] = null;\n      }\n    }\n\n    updated(changedProperties: Map<string|symbol, unknown>): void {\n      super.updated(changedProperties);\n      if (changedProperties.has($modelGraft)) {\n        const oldModelGraft =\n            changedProperties.get($modelGraft) as ModelGraft | null;\n        if (oldModelGraft != null) {\n          oldModelGraft.removeEventListener(\n              'mutation', this[$modelGraftMutationHandler]);\n        }\n\n        const modelGraft = this[$modelGraft];\n\n        if (modelGraft != null) {\n          modelGraft.addEventListener(\n              'mutation', this[$modelGraftMutationHandler]);\n        }\n      }\n    }\n\n    [$onModelLoad](event: any) {\n      super[$onModelLoad](event);\n\n      this[$updateExecutionContextModel]();\n    }\n\n    [$isValid3DOMScript](node: Node) {\n      return node instanceof HTMLScriptElement &&\n          (node.textContent || node.src) &&\n          node.getAttribute('type') === SCENE_GRAPH_SCRIPT_TYPE\n    }\n\n    [$onChildListMutation](records: Array<MutationRecord>) {\n      if (this.parentNode == null) {\n        // Ignore a lazily reported list of mutations if we are detached from\n        // the document...\n        return;\n      }\n\n      let lastScriptElement: HTMLScriptElement|null = null;\n\n      for (const record of records) {\n        for (const node of Array.from(record.addedNodes)) {\n          if (this[$isValid3DOMScript](node)) {\n            lastScriptElement = node as HTMLScriptElement;\n          }\n        }\n      }\n\n      if (lastScriptElement != null) {\n        this[$onScriptElementAdded](lastScriptElement);\n      }\n    }\n\n    [$onScriptElementAdded](script: HTMLScriptElement) {\n      if (!this[$isValid3DOMScript](script)) {\n        return;\n      }\n\n      const allowString = script.getAttribute('allow') || '';\n      const allowList =\n          allowString.split(';')\n              .map((fragment) => fragment.trim())\n              .filter<ThreeDOMCapability>(\n                  (capability): capability is ThreeDOMCapability =>\n                      VALID_CAPABILITIES.has(capability as ThreeDOMCapability));\n\n      if (script.src) {\n        this[$createExecutionContext](script.src, allowList);\n      } else {\n        this[$createExecutionContext](\n            script.textContent!, allowList, {eval: true});\n      }\n    }\n\n    async[$createExecutionContext](\n        scriptSource: string, capabilities: Array<ThreeDOMCapability>,\n        options = {eval: false}) {\n      let executionContext = this[$executionContext];\n\n      if (executionContext != null) {\n        await executionContext.terminate();\n      }\n\n      this[$executionContext] = executionContext =\n          new ThreeDOMExecutionContext(capabilities);\n\n      this.dispatchEvent(new CustomEvent(\n          'worklet-created', {detail: {worklet: this.worklet}}));\n\n      if (options.eval) {\n        await executionContext.eval(scriptSource);\n      } else {\n        await executionContext.import(scriptSource);\n      }\n\n      this[$updateExecutionContextModel]();\n    }\n\n    [$updateExecutionContextModel]() {\n      const executionContext = this[$executionContext];\n\n      if (executionContext == null || this.parentNode == null) {\n        // Ignore if we don't have a 3DOM script to run, or if we are currently\n        // detached from the document\n        return;\n      }\n\n      const scene = this[$scene];\n      const modelGraft: ModelGraft|null = this.loaded ?\n          // TODO: Use a proper GLTF artifact as cached by the loader for this:\n          new ModelGraft(scene.model.url || '', {\n            scene: scene as unknown as Group,\n            scenes: [scene as unknown as Group],\n            animations: [],\n            cameras: [],\n            parser: {} as unknown as GLTFParser,\n            asset: {},\n            userData: {}\n          }) :\n          null;\n\n      executionContext.changeModel(modelGraft);\n\n      this[$modelGraft] = modelGraft;\n    }\n\n    [$onModelGraftMutation](_event: Event) {\n      this[$needsRender]();\n    }\n  }\n\n  return SceneGraphModelViewerElement;\n};"],"sourceRoot":""},"metadata":{},"sourceType":"module"}