{"ast":null,"code":"/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ThreeDOMMessageType } from '../protocol.js';\n/**\n * A constructor factory for a ModelKernel class. The ModelKernel is defined\n * based on a provided implementation for all specified 3DOM scene graph\n * element types.\n *\n * The sole reason for using this factory pattern is to enable sound type\n * checking while also providing for the ability to stringify the factory so\n * that it can be part of a runtime-generated Worker script.\n */\n\nexport function defineModelKernel(Model, Material, PBRMetallicRoughness) {\n  var _a, _b, _c, _d, _e, _f;\n\n  const constructorsByType = {\n    'model': Model,\n    'material': Material,\n    'pbr-metallic-roughness': PBRMetallicRoughness\n  };\n  const $onMessageEvent = Symbol('onMessageEvent');\n  const $messageEventHandler = Symbol('messageEventHandler');\n  const $port = Symbol('port');\n  const $model = Symbol('model');\n  const $elementsByLocalId = Symbol('elementsByLocalId');\n  const $localIdsByElement = Symbol('localIdsByElement');\n  const $elementsByType = Symbol('elementsByType');\n  const $pendingMutations = Symbol('pendingMutations');\n  const $nextMutationId = Symbol('nextMutationId');\n  /**\n   * A ModelKernel is the core business logic implementation for a distinct\n   * Model that has been exposed to a script execution context. The ModelKernel\n   * is an internal detail, and should never be explicitly exposed to users of\n   * a Model.\n   *\n   * The ModelKernel primarily handles deserializing scene graph elements, and\n   * communicating mutations from the 3DOM execution context to the host\n   * execution context where the backing scene graph lives.\n   *\n   * A ModelKernel also maintains a comprehensive map of elements by type to\n   * assist scene graph elements in querying for their contemporaries.\n   */\n\n  class ModelKernel {\n    constructor(port, serialized) {\n      this[_a] = new Map();\n      this[_b] = new Map();\n      this[_c] = new Map();\n\n      this[_d] = event => this[$onMessageEvent](event);\n\n      this[_e] = new Map();\n      this[_f] = 0;\n      const types = Object.keys(constructorsByType);\n\n      for (const type of types) {\n        this[$elementsByType].set(type, new Set());\n      }\n\n      this[$port] = port;\n      this[$port].addEventListener('message', this[$messageEventHandler]);\n      this[$port].start();\n      this[$model] = this.deserialize('model', serialized);\n    }\n    /**\n     * The root scene graph element, a Model, that is the entrypoint for the\n     * entire scene graph that is backed by this kernel.\n     */\n\n\n    get model() {\n      return this[$model];\n    }\n    /**\n     * Mutate a property of a property of a given scene graph element. All\n     * direct mutations of the scene graph are considered asynchronous. This\n     * method returns a Promise that resolves when the mutation has been\n     * successfully applied to the backing scene graph, and rejects if the\n     * mutation failed or is otherwise not allowed.\n     *\n     * TODO(#1006): How to validate values?\n     */\n\n\n    async mutate(element, property, value) {\n      if (!this[$localIdsByElement].has(element)) {\n        throw new Error('Cannot mutate unknown element');\n      }\n\n      const id = this[$localIdsByElement].get(element);\n      return new Promise((resolve, reject) => {\n        const mutationId = this[$nextMutationId]++; // TODO(#1006): Validate mutations before sending to host context:\n\n        this[$port].postMessage({\n          type: ThreeDOMMessageType.MUTATE,\n          id,\n          property,\n          value,\n          mutationId\n        }); // TODO(#1011): Add timeout to reject this mutation:\n\n        this[$pendingMutations].set(mutationId, {\n          resolve,\n          reject\n        });\n      });\n    }\n    /**\n     * Deserializes a JSON representation of a scene graph element into a live\n     * element that is backed by this ModelKernel.\n     */\n\n\n    deserialize(type, serialized) {\n      if (!(type in constructorsByType)) {\n        throw new Error(`Cannot deserialize unknown type: ${type}`);\n      }\n\n      const id = serialized.id;\n      const ElementConstructor = constructorsByType[type]; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      const element = new ElementConstructor(this, serialized);\n      this[$elementsByLocalId].set(id, element);\n      this[$localIdsByElement].set(element, id); // We know that the all accepted types have been pre-populated in the\n      // [$elementsByType] map:\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n      this[$elementsByType].get(type).add(element);\n      return element;\n    }\n    /**\n     * Look up all scene graph elements given a type string. Type strings\n     * are lower-cased, hyphenated versions of the constructor names of their\n     * corresponding classes. For example, a query for 'pbr-metallic-roughness'\n     * element types will yield the list of PBRMetallicRoughness elements in\n     * sparse tree order.\n     */\n\n\n    getElementsByType(type) {\n      if (!this[$elementsByType].has(type)) {\n        return [];\n      } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n      return Array.from(this[$elementsByType].get(type));\n    }\n    /**\n     * Deactivate the ModelKernel. This has the effect of blocking all future\n     * mutations to the scene graph. Once deactivated, a ModelKernel cannot be\n     * reactivated.\n     *\n     * The ModelKernel should be deactivated before it is disposed of, or else\n     * it will leak in memory.\n     */\n\n\n    deactivate() {\n      this[$port].close();\n      this[$port].removeEventListener('message', this[$messageEventHandler]);\n    }\n\n    [(_a = $elementsByLocalId, _b = $localIdsByElement, _c = $elementsByType, _d = $messageEventHandler, _e = $pendingMutations, _f = $nextMutationId, $onMessageEvent)](event) {\n      const data = event.data;\n\n      switch (data && data.type) {\n        case ThreeDOMMessageType.MUTATION_RESULT:\n          {\n            const message = data;\n            const applied = message.applied,\n                  mutationId = message.mutationId;\n            const pendingMutation = this[$pendingMutations].get(mutationId);\n            this[$pendingMutations].delete(mutationId);\n\n            if (pendingMutation != null) {\n              applied ? pendingMutation.resolve() : pendingMutation.reject();\n            }\n\n            break;\n          }\n      }\n    }\n\n  }\n\n  return ModelKernel;\n}","map":{"version":3,"sources":["../../src/api/model-kernel.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {ConstructedWithArguments, Constructor, Material, Model, PBRMetallicRoughness, ThreeDOMElement, ThreeDOMElementMap} from '../api.js';\nimport {MutationResultMessage, SerializedElementMap, SerializedMaterial, SerializedModel, SerializedPBRMetallicRoughness, ThreeDOMMessageType} from '../protocol.js';\n\nexport interface ModelKernelInterface {\n  readonly model: Model;\n\n  mutate(element: ThreeDOMElement, property: string, value: unknown):\n      Promise<void>;\n  deserialize<T extends keyof ThreeDOMElementMap>(\n      type: T, serialized: SerializedElementMap[T]): ThreeDOMElementMap[T];\n  getElementsByType<T extends keyof ThreeDOMElementMap>(type: T):\n      Array<ThreeDOMElementMap[T]>;\n  deactivate(): void;\n}\n\nexport type ModelKernelConstructor = Constructor<ModelKernelInterface>&\n    ConstructedWithArguments<[MessagePort, SerializedModel]>;\n\nexport type ModelKernel = InstanceType<ModelKernelConstructor>;\n\ntype ElementsByType<T = ThreeDOMElementMap, U extends keyof T = keyof T> =\n    Map<U, Set<T[U]>>;\n\ntype ModelConstructor = Constructor<Model>&\n    ConstructedWithArguments<[ModelKernelInterface, SerializedModel]>;\ntype MaterialConstructor = Constructor<Material>&\n    ConstructedWithArguments<[ModelKernelInterface, SerializedMaterial]>;\ntype PBRMetallicRoughnessConstructor =\n    Constructor<PBRMetallicRoughness>&ConstructedWithArguments<\n        [ModelKernelInterface, SerializedPBRMetallicRoughness]>;\n\ninterface Deferred {\n  resolve: () => void;\n  reject: () => void;\n}\n\n/**\n * A constructor factory for a ModelKernel class. The ModelKernel is defined\n * based on a provided implementation for all specified 3DOM scene graph\n * element types.\n *\n * The sole reason for using this factory pattern is to enable sound type\n * checking while also providing for the ability to stringify the factory so\n * that it can be part of a runtime-generated Worker script.\n */\nexport function defineModelKernel(\n    Model: ModelConstructor,\n    Material: MaterialConstructor,\n    PBRMetallicRoughness: PBRMetallicRoughnessConstructor):\n    ModelKernelConstructor {\n  const constructorsByType: {\n    [K in keyof ThreeDOMElementMap]: Constructor<ThreeDOMElementMap[K]>&\n    ConstructedWithArguments<[ModelKernelInterface, SerializedElementMap[K]]>\n  } = {\n    'model': Model,\n    'material': Material,\n    'pbr-metallic-roughness': PBRMetallicRoughness\n  };\n\n  const $onMessageEvent = Symbol('onMessageEvent');\n  const $messageEventHandler = Symbol('messageEventHandler');\n  const $port = Symbol('port');\n  const $model = Symbol('model');\n\n  const $elementsByLocalId = Symbol('elementsByLocalId');\n  const $localIdsByElement = Symbol('localIdsByElement');\n  const $elementsByType = Symbol('elementsByType');\n\n  const $pendingMutations = Symbol('pendingMutations');\n  const $nextMutationId = Symbol('nextMutationId');\n\n  /**\n   * A ModelKernel is the core business logic implementation for a distinct\n   * Model that has been exposed to a script execution context. The ModelKernel\n   * is an internal detail, and should never be explicitly exposed to users of\n   * a Model.\n   *\n   * The ModelKernel primarily handles deserializing scene graph elements, and\n   * communicating mutations from the 3DOM execution context to the host\n   * execution context where the backing scene graph lives.\n   *\n   * A ModelKernel also maintains a comprehensive map of elements by type to\n   * assist scene graph elements in querying for their contemporaries.\n   */\n  class ModelKernel implements ModelKernelInterface {\n    protected[$elementsByLocalId] = new Map<number, ThreeDOMElement>();\n    protected[$localIdsByElement] = new Map<ThreeDOMElement, number>();\n\n    protected[$elementsByType]: ElementsByType = new Map();\n\n    protected[$messageEventHandler] = (event: MessageEvent) =>\n        this[$onMessageEvent](event);\n    protected[$port]: MessagePort;\n\n    protected[$model]: Model;\n\n    protected[$pendingMutations]: Map<number, Deferred> = new Map();\n\n    protected[$nextMutationId] = 0;\n\n    constructor(port: MessagePort, serialized: SerializedModel) {\n      const types =\n          Object.keys(constructorsByType) as Array<keyof ThreeDOMElementMap>;\n\n      for (const type of types) {\n        this[$elementsByType].set(type, new Set());\n      }\n\n      this[$port] = port;\n      this[$port].addEventListener('message', this[$messageEventHandler]);\n      this[$port].start();\n\n      this[$model] = this.deserialize('model', serialized);\n    }\n\n    /**\n     * The root scene graph element, a Model, that is the entrypoint for the\n     * entire scene graph that is backed by this kernel.\n     */\n    get model() {\n      return this[$model];\n    }\n\n    /**\n     * Mutate a property of a property of a given scene graph element. All\n     * direct mutations of the scene graph are considered asynchronous. This\n     * method returns a Promise that resolves when the mutation has been\n     * successfully applied to the backing scene graph, and rejects if the\n     * mutation failed or is otherwise not allowed.\n     *\n     * TODO(#1006): How to validate values?\n     */\n    async mutate(element: ThreeDOMElement, property: string, value: unknown):\n        Promise<void> {\n      if (!this[$localIdsByElement].has(element)) {\n        throw new Error('Cannot mutate unknown element');\n      }\n\n      const id = this[$localIdsByElement].get(element);\n\n      return new Promise((resolve, reject) => {\n        const mutationId = this[$nextMutationId]++;\n        // TODO(#1006): Validate mutations before sending to host context:\n        this[$port].postMessage({\n          type: ThreeDOMMessageType.MUTATE,\n          id,\n          property,\n          value,\n          mutationId,\n        });\n\n        // TODO(#1011): Add timeout to reject this mutation:\n        this[$pendingMutations].set(mutationId, {\n          resolve,\n          reject,\n        });\n      });\n    }\n\n    /**\n     * Deserializes a JSON representation of a scene graph element into a live\n     * element that is backed by this ModelKernel.\n     */\n    deserialize<T extends keyof ThreeDOMElementMap>(\n        type: T, serialized: SerializedElementMap[T]): ThreeDOMElementMap[T] {\n      if (!(type in constructorsByType)) {\n        throw new Error(`Cannot deserialize unknown type: ${type}`);\n      }\n\n      const {id} = serialized;\n      const ElementConstructor = constructorsByType[type];\n\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const element = new ElementConstructor(this, serialized as any);\n\n      this[$elementsByLocalId].set(id, element);\n      this[$localIdsByElement].set(element, id);\n\n      // We know that the all accepted types have been pre-populated in the\n      // [$elementsByType] map:\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this[$elementsByType].get(type)!.add(element);\n\n      return element as ThreeDOMElementMap[T];\n    }\n\n    /**\n     * Look up all scene graph elements given a type string. Type strings\n     * are lower-cased, hyphenated versions of the constructor names of their\n     * corresponding classes. For example, a query for 'pbr-metallic-roughness'\n     * element types will yield the list of PBRMetallicRoughness elements in\n     * sparse tree order.\n     */\n    getElementsByType<T extends keyof ThreeDOMElementMap>(type: T):\n        Array<ThreeDOMElementMap[T]> {\n      if (!this[$elementsByType].has(type)) {\n        return [];\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return Array.from(this[$elementsByType].get(type)!) as\n          Array<ThreeDOMElementMap[T]>;\n    }\n\n    /**\n     * Deactivate the ModelKernel. This has the effect of blocking all future\n     * mutations to the scene graph. Once deactivated, a ModelKernel cannot be\n     * reactivated.\n     *\n     * The ModelKernel should be deactivated before it is disposed of, or else\n     * it will leak in memory.\n     */\n    deactivate() {\n      this[$port].close();\n      this[$port].removeEventListener('message', this[$messageEventHandler]);\n    }\n\n    protected[$onMessageEvent](event: MessageEvent) {\n      const {data} = event;\n\n      switch (data && data.type) {\n        case ThreeDOMMessageType.MUTATION_RESULT: {\n          const message: MutationResultMessage = data;\n          const {applied, mutationId} = message;\n          const pendingMutation = this[$pendingMutations].get(mutationId);\n\n          this[$pendingMutations].delete(mutationId);\n\n          if (pendingMutation != null) {\n            applied ? pendingMutation.resolve() : pendingMutation.reject();\n          }\n          break;\n        }\n      }\n    }\n  }\n\n  return ModelKernel;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}