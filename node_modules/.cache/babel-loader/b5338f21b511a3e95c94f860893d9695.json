{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b;\n\nimport { ACESFilmicToneMapping, EventDispatcher, GammaEncoding, PCFSoftShadowMap, WebGLRenderer } from 'three';\nimport { IS_WEBXR_AR_CANDIDATE, USE_OFFSCREEN_CANVAS } from '../constants.js';\nimport { $tick } from '../model-viewer-base.js';\nimport { isDebugMode, resolveDpr } from '../utilities.js';\nimport { ARRenderer } from './ARRenderer.js';\nimport { Debugger } from './Debugger.js';\nimport TextureUtils from './TextureUtils.js';\nimport * as WebGLUtils from './WebGLUtils.js';\nexport const $arRenderer = Symbol('arRenderer');\nconst $onWebGLContextLost = Symbol('onWebGLContextLost');\nconst $webGLContextLostHandler = Symbol('webGLContextLostHandler');\nconst $singleton = Symbol('singleton');\n/**\n * Registers canvases with Canvas2DRenderingContexts and renders them\n * all in the same WebGLRenderingContext, spitting out textures to apply\n * to the canvases. Creates a fullscreen WebGL canvas that is not added\n * to the DOM, and on each frame, renders each registered canvas on a portion\n * of the WebGL canvas, and applies the texture on the registered canvas.\n *\n * In the future, can use ImageBitmapRenderingContext instead of\n * Canvas2DRenderingContext if supported for cheaper transfering of\n * the texture.\n */\n\nexport class Renderer extends EventDispatcher {\n  constructor(options) {\n    super();\n    this.width = 0;\n    this.height = 0;\n    this.debugger = null;\n    this.scenes = new Set();\n\n    this[_b] = event => this[$onWebGLContextLost](event);\n\n    const webGlOptions = {\n      alpha: true,\n      antialias: true\n    }; // Only enable certain options when Web XR capabilities are detected:\n\n    if (IS_WEBXR_AR_CANDIDATE) {\n      Object.assign(webGlOptions, {\n        alpha: true,\n        preserveDrawingBuffer: true\n      });\n    }\n\n    this.canvasElement = document.createElement('canvas');\n    this.canvas3D = USE_OFFSCREEN_CANVAS ? this.canvasElement.transferControlToOffscreen() : this.canvasElement;\n    this.canvas3D.addEventListener('webglcontextlost', this[$webGLContextLostHandler]);\n\n    try {\n      // Need to support both 'webgl' and 'experimental-webgl' (IE11).\n      this.context3D = WebGLUtils.getContext(this.canvas3D, webGlOptions); // Patch the gl context's extension functions before passing\n      // it to three.\n\n      WebGLUtils.applyExtensionCompatibility(this.context3D);\n      this.threeRenderer = new WebGLRenderer({\n        canvas: this.canvas3D,\n        context: this.context3D\n      });\n      this.threeRenderer.autoClear = true;\n      this.threeRenderer.outputEncoding = GammaEncoding;\n      this.threeRenderer.gammaFactor = 2.2;\n      this.threeRenderer.physicallyCorrectLights = true;\n      this.threeRenderer.setPixelRatio(resolveDpr());\n      this.threeRenderer.shadowMap.enabled = true;\n      this.threeRenderer.shadowMap.type = PCFSoftShadowMap;\n      this.threeRenderer.shadowMap.autoUpdate = false;\n      this.debugger = options != null && !!options.debug ? new Debugger(this) : null;\n      this.threeRenderer.debug = {\n        checkShaderErrors: !!this.debugger\n      }; // ACESFilmicToneMapping appears to be the most \"saturated\",\n      // and similar to Filament's gltf-viewer.\n\n      this.threeRenderer.toneMapping = ACESFilmicToneMapping;\n    } catch (error) {\n      this.context3D = null;\n      console.warn(error);\n    }\n\n    this[$arRenderer] = new ARRenderer(this);\n    this.textureUtils = this.canRender ? new TextureUtils(this.threeRenderer) : null;\n    this.setRendererSize(1, 1);\n    this.lastTick = performance.now();\n  }\n\n  static get singleton() {\n    return this[$singleton];\n  }\n\n  static resetSingleton() {\n    this[$singleton].dispose();\n    this[$singleton] = new Renderer({\n      debug: isDebugMode()\n    });\n  }\n\n  get canRender() {\n    return this.threeRenderer != null && this.context3D != null;\n  }\n\n  setRendererSize(width, height) {\n    if (this.canRender) {\n      this.threeRenderer.setSize(width, height, false);\n    }\n\n    this.width = width;\n    this.height = height;\n  }\n\n  registerScene(scene) {\n    this.scenes.add(scene);\n\n    if (this.canRender && this.scenes.size > 0) {\n      this.threeRenderer.setAnimationLoop(time => this.render(time));\n    }\n\n    if (this.debugger != null) {\n      this.debugger.addScene(scene);\n    }\n  }\n\n  unregisterScene(scene) {\n    this.scenes.delete(scene);\n\n    if (this.canRender && this.scenes.size === 0) {\n      this.threeRenderer.setAnimationLoop(null);\n    }\n\n    if (this.debugger != null) {\n      this.debugger.removeScene(scene);\n    }\n  }\n\n  get hasOnlyOneScene() {\n    return this.scenes.size === 1;\n  }\n\n  async supportsPresentation() {\n    return this.canRender && this[$arRenderer].supportsPresentation();\n  }\n\n  get presentedScene() {\n    return this[$arRenderer].presentedScene;\n  }\n\n  async present(scene) {\n    try {\n      return await this[$arRenderer].present(scene);\n    } catch (error) {\n      await this[$arRenderer].stopPresenting();\n      throw error;\n    } finally {\n      // NOTE(cdata): Setting width and height to 0 will have the effect of\n      // invoking a `setSize` the next time we render in this threeRenderer\n      this.width = this.height = 0;\n    }\n  }\n\n  stopPresenting() {\n    return this[$arRenderer].stopPresenting();\n  }\n\n  get isPresenting() {\n    return this[$arRenderer] != null && this[$arRenderer].isPresenting;\n  }\n  /**\n   * This method takes care of updating the element and renderer state based on\n   * the time that has passed since the last rendered frame.\n   */\n\n\n  preRender(scene, t, delta) {\n    const element = scene.element,\n          exposure = scene.exposure,\n          model = scene.model;\n    element[$tick](t, delta);\n    const exposureIsNumber = typeof exposure === 'number' && !self.isNaN(exposure);\n    this.threeRenderer.toneMappingExposure = exposureIsNumber ? exposure : 1.0;\n\n    if (model.updateShadow()) {\n      this.threeRenderer.shadowMap.needsUpdate = true;\n    }\n  }\n  /**\n   * Expands the size of the renderer to the max of its current size and the\n   * incoming size.\n   */\n\n\n  expandTo(width, height) {\n    const maxWidth = Math.max(width, this.width);\n    const maxHeight = Math.max(height, this.height);\n    this.setRendererSize(maxWidth, maxHeight);\n    this.canvasElement.style.width = `${maxWidth}px`;\n    this.canvasElement.style.height = `${maxHeight}px`;\n\n    for (const scene of this.scenes) {\n      scene.canvas.width = maxWidth;\n      scene.canvas.height = maxHeight;\n    }\n  }\n\n  render(t) {\n    if (!this.canRender || this.isPresenting) {\n      return;\n    }\n\n    const delta = t - this.lastTick;\n    const dpr = resolveDpr();\n\n    if (dpr !== this.threeRenderer.getPixelRatio()) {\n      this.threeRenderer.setPixelRatio(dpr);\n      this.canvasElement.style.width = `${this.width}px`;\n      this.canvasElement.style.height = `${this.height}px`;\n\n      for (const scene of this.scenes) {\n        scene.isDirty = true;\n      }\n    }\n\n    for (const scene of this.scenes) {\n      if (!scene.visible || scene.paused) {\n        continue;\n      }\n\n      this.preRender(scene, t, delta);\n\n      if (!scene.isDirty) {\n        continue;\n      }\n\n      const width = scene.width,\n            height = scene.height;\n\n      if (width > this.width || height > this.height) {\n        const maxWidth = Math.max(width, this.width);\n        const maxHeight = Math.max(height, this.height);\n        this.setRendererSize(maxWidth, maxHeight);\n      } // Need to set the render target in order to prevent\n      // clearing the depth from a different buffer -- possibly\n      // from something in\n\n\n      this.threeRenderer.setRenderTarget(null);\n      this.threeRenderer.setViewport(0, this.height - height, width, height);\n      this.threeRenderer.render(scene, scene.getCamera());\n\n      if (!this.hasOnlyOneScene) {\n        if (scene.context == null) {\n          scene.createContext();\n        }\n\n        if (USE_OFFSCREEN_CANVAS) {\n          const contextBitmap = scene.context;\n          const bitmap = this.canvas3D.transferToImageBitmap();\n          contextBitmap.transferFromImageBitmap(bitmap);\n        } else {\n          const context2D = scene.context;\n          context2D.clearRect(0, 0, width, height);\n          context2D.drawImage(this.threeRenderer.domElement, 0, 0, width * dpr, height * dpr, 0, 0, width, height);\n        }\n      }\n\n      scene.isDirty = false;\n    }\n\n    this.lastTick = t;\n  }\n\n  dispose() {\n    if (this.textureUtils != null) {\n      this.textureUtils.dispose();\n    }\n\n    if (this.threeRenderer != null) {\n      this.threeRenderer.dispose();\n    }\n\n    this.textureUtils = null;\n    this.threeRenderer = null;\n    this.scenes.clear();\n    this.canvas3D.removeEventListener('webglcontextlost', this[$webGLContextLostHandler]);\n  }\n\n  [(_a = $singleton, _b = $webGLContextLostHandler, $onWebGLContextLost)](event) {\n    this.dispatchEvent({\n      type: 'contextlost',\n      sourceEvent: event\n    });\n  }\n\n}\nRenderer[_a] = new Renderer({\n  debug: isDebugMode()\n});","map":{"version":3,"sources":["../../src/three-components/Renderer.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {ACESFilmicToneMapping, Event, EventDispatcher, GammaEncoding, PCFSoftShadowMap, WebGLRenderer} from 'three';\n\nimport {IS_WEBXR_AR_CANDIDATE, USE_OFFSCREEN_CANVAS} from '../constants.js';\nimport {$tick} from '../model-viewer-base.js';\nimport {isDebugMode, resolveDpr} from '../utilities.js';\n\nimport {ARRenderer} from './ARRenderer.js';\nimport {Debugger} from './Debugger.js';\nimport {ModelScene} from './ModelScene.js';\nimport TextureUtils from './TextureUtils.js';\nimport * as WebGLUtils from './WebGLUtils.js';\n\nexport interface RendererOptions {\n  debug?: boolean;\n}\n\nexport interface ContextLostEvent extends Event {\n  type: 'contextlost';\n  sourceEvent: WebGLContextEvent;\n}\n\nexport const $arRenderer = Symbol('arRenderer');\n\nconst $onWebGLContextLost = Symbol('onWebGLContextLost');\nconst $webGLContextLostHandler = Symbol('webGLContextLostHandler');\nconst $singleton = Symbol('singleton');\n\n/**\n * Registers canvases with Canvas2DRenderingContexts and renders them\n * all in the same WebGLRenderingContext, spitting out textures to apply\n * to the canvases. Creates a fullscreen WebGL canvas that is not added\n * to the DOM, and on each frame, renders each registered canvas on a portion\n * of the WebGL canvas, and applies the texture on the registered canvas.\n *\n * In the future, can use ImageBitmapRenderingContext instead of\n * Canvas2DRenderingContext if supported for cheaper transfering of\n * the texture.\n */\nexport class Renderer extends EventDispatcher {\n  static[$singleton] = new Renderer({debug: isDebugMode()});\n\n  static get singleton() {\n    return this[$singleton];\n  }\n\n  static resetSingleton() {\n    this[$singleton].dispose();\n    this[$singleton] = new Renderer({debug: isDebugMode()});\n  }\n\n  public threeRenderer!: WebGLRenderer;\n  public context3D!: WebGLRenderingContext|null;\n  public canvasElement: HTMLCanvasElement;\n  public canvas3D: HTMLCanvasElement|OffscreenCanvas;\n  public textureUtils: TextureUtils|null;\n  public width: number = 0;\n  public height: number = 0;\n\n  protected debugger: Debugger|null = null;\n  private[$arRenderer]: ARRenderer;\n  private scenes: Set<ModelScene> = new Set();\n  private lastTick: number;\n\n  private[$webGLContextLostHandler] = (event: WebGLContextEvent) =>\n      this[$onWebGLContextLost](event);\n\n  get canRender() {\n    return this.threeRenderer != null && this.context3D != null;\n  }\n\n  constructor(options?: RendererOptions) {\n    super();\n\n    const webGlOptions = {alpha: true, antialias: true};\n\n    // Only enable certain options when Web XR capabilities are detected:\n    if (IS_WEBXR_AR_CANDIDATE) {\n      Object.assign(webGlOptions, {alpha: true, preserveDrawingBuffer: true});\n    }\n\n    this.canvasElement = document.createElement('canvas');\n\n    this.canvas3D = USE_OFFSCREEN_CANVAS ?\n        this.canvasElement.transferControlToOffscreen() :\n        this.canvasElement;\n\n    this.canvas3D.addEventListener(\n        'webglcontextlost', this[$webGLContextLostHandler] as EventListener);\n\n    try {\n      // Need to support both 'webgl' and 'experimental-webgl' (IE11).\n      this.context3D = WebGLUtils.getContext(this.canvas3D, webGlOptions);\n\n      // Patch the gl context's extension functions before passing\n      // it to three.\n      WebGLUtils.applyExtensionCompatibility(this.context3D);\n\n      this.threeRenderer = new WebGLRenderer({\n        canvas: this.canvas3D,\n        context: this.context3D,\n      });\n      this.threeRenderer.autoClear = true;\n      this.threeRenderer.outputEncoding = GammaEncoding;\n      this.threeRenderer.gammaFactor = 2.2;\n      this.threeRenderer.physicallyCorrectLights = true;\n      this.threeRenderer.setPixelRatio(resolveDpr());\n      this.threeRenderer.shadowMap.enabled = true;\n      this.threeRenderer.shadowMap.type = PCFSoftShadowMap;\n      this.threeRenderer.shadowMap.autoUpdate = false;\n\n      this.debugger =\n          options != null && !!options.debug ? new Debugger(this) : null;\n      this.threeRenderer.debug = {checkShaderErrors: !!this.debugger};\n\n      // ACESFilmicToneMapping appears to be the most \"saturated\",\n      // and similar to Filament's gltf-viewer.\n      this.threeRenderer.toneMapping = ACESFilmicToneMapping;\n    } catch (error) {\n      this.context3D = null;\n      console.warn(error);\n    }\n\n    this[$arRenderer] = new ARRenderer(this);\n    this.textureUtils =\n        this.canRender ? new TextureUtils(this.threeRenderer) : null;\n\n    this.setRendererSize(1, 1);\n    this.lastTick = performance.now();\n  }\n\n  setRendererSize(width: number, height: number) {\n    if (this.canRender) {\n      this.threeRenderer.setSize(width, height, false);\n    }\n\n    this.width = width;\n    this.height = height;\n  }\n\n  registerScene(scene: ModelScene) {\n    this.scenes.add(scene);\n    if (this.canRender && this.scenes.size > 0) {\n      this.threeRenderer.setAnimationLoop((time: number) => this.render(time));\n    }\n\n    if (this.debugger != null) {\n      this.debugger.addScene(scene);\n    }\n  }\n\n  unregisterScene(scene: ModelScene) {\n    this.scenes.delete(scene);\n    if (this.canRender && this.scenes.size === 0) {\n      (this.threeRenderer.setAnimationLoop as any)(null);\n    }\n\n    if (this.debugger != null) {\n      this.debugger.removeScene(scene);\n    }\n  }\n\n  get hasOnlyOneScene(): boolean {\n    return this.scenes.size === 1;\n  }\n\n  async supportsPresentation() {\n    return this.canRender && this[$arRenderer].supportsPresentation();\n  }\n\n  get presentedScene() {\n    return this[$arRenderer].presentedScene;\n  }\n\n  async present(scene: ModelScene): Promise<void> {\n    try {\n      return await this[$arRenderer].present(scene);\n    } catch (error) {\n      await this[$arRenderer].stopPresenting();\n      throw error;\n    } finally {\n      // NOTE(cdata): Setting width and height to 0 will have the effect of\n      // invoking a `setSize` the next time we render in this threeRenderer\n      this.width = this.height = 0;\n    }\n  }\n\n  stopPresenting(): Promise<void> {\n    return this[$arRenderer].stopPresenting();\n  }\n\n  get isPresenting(): boolean {\n    return this[$arRenderer] != null && this[$arRenderer].isPresenting;\n  }\n\n  /**\n   * This method takes care of updating the element and renderer state based on\n   * the time that has passed since the last rendered frame.\n   */\n  preRender(scene: ModelScene, t: number, delta: number) {\n    const {element, exposure, model} = scene;\n\n    element[$tick](t, delta);\n\n    const exposureIsNumber =\n        typeof exposure === 'number' && !(self as any).isNaN(exposure);\n    this.threeRenderer.toneMappingExposure = exposureIsNumber ? exposure : 1.0;\n\n    if (model.updateShadow()) {\n      this.threeRenderer.shadowMap.needsUpdate = true;\n    }\n  }\n\n  /**\n   * Expands the size of the renderer to the max of its current size and the\n   * incoming size.\n   */\n  expandTo(width: number, height: number) {\n    const maxWidth = Math.max(width, this.width);\n    const maxHeight = Math.max(height, this.height);\n    this.setRendererSize(maxWidth, maxHeight);\n    this.canvasElement.style.width = `${maxWidth}px`;\n    this.canvasElement.style.height = `${maxHeight}px`;\n    for (const scene of this.scenes) {\n      scene.canvas.width = maxWidth;\n      scene.canvas.height = maxHeight;\n    }\n  }\n\n  render(t: number) {\n    if (!this.canRender || this.isPresenting) {\n      return;\n    }\n\n    const delta = t - this.lastTick;\n    const dpr = resolveDpr();\n\n    if (dpr !== this.threeRenderer.getPixelRatio()) {\n      this.threeRenderer.setPixelRatio(dpr);\n      this.canvasElement.style.width = `${this.width}px`;\n      this.canvasElement.style.height = `${this.height}px`;\n      for (const scene of this.scenes) {\n        scene.isDirty = true;\n      }\n    }\n\n    for (const scene of this.scenes) {\n      if (!scene.visible || scene.paused) {\n        continue;\n      }\n\n      this.preRender(scene, t, delta);\n\n      if (!scene.isDirty) {\n        continue;\n      }\n\n      const {width, height} = scene;\n\n      if (width > this.width || height > this.height) {\n        const maxWidth = Math.max(width, this.width);\n        const maxHeight = Math.max(height, this.height);\n        this.setRendererSize(maxWidth, maxHeight);\n      }\n\n      // Need to set the render target in order to prevent\n      // clearing the depth from a different buffer -- possibly\n      // from something in\n      this.threeRenderer.setRenderTarget(null);\n      this.threeRenderer.setViewport(0, this.height - height, width, height);\n      this.threeRenderer.render(scene, scene.getCamera());\n\n      if (!this.hasOnlyOneScene) {\n        if (scene.context == null) {\n          scene.createContext();\n        }\n        if (USE_OFFSCREEN_CANVAS) {\n          const contextBitmap = scene.context as ImageBitmapRenderingContext;\n          const bitmap =\n              (this.canvas3D as OffscreenCanvas).transferToImageBitmap();\n          contextBitmap.transferFromImageBitmap(bitmap);\n        } else {\n          const context2D = scene.context as CanvasRenderingContext2D;\n          context2D.clearRect(0, 0, width, height);\n          context2D.drawImage(\n              this.threeRenderer.domElement,\n              0,\n              0,\n              width * dpr,\n              height * dpr,\n              0,\n              0,\n              width,\n              height);\n        }\n      }\n\n      scene.isDirty = false;\n    }\n    this.lastTick = t;\n  }\n\n  dispose() {\n    if (this.textureUtils != null) {\n      this.textureUtils.dispose();\n    }\n\n    if (this.threeRenderer != null) {\n      this.threeRenderer.dispose();\n    }\n\n    this.textureUtils = null;\n    (this as any).threeRenderer = null;\n\n    this.scenes.clear();\n\n    this.canvas3D.removeEventListener(\n        'webglcontextlost', this[$webGLContextLostHandler] as EventListener);\n  }\n\n  [$onWebGLContextLost](event: WebGLContextEvent) {\n    this.dispatchEvent(\n        {type: 'contextlost', sourceEvent: event} as ContextLostEvent);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}