{"ast":null,"code":"/* global THREE */\nvar registerComponent = require('../core/component').registerComponent;\n\nvar utils = require('../utils/');\n\nvar bind = utils.bind;\nvar EVENTS = {\n  CLICK: 'click',\n  FUSING: 'fusing',\n  MOUSEENTER: 'mouseenter',\n  MOUSEDOWN: 'mousedown',\n  MOUSELEAVE: 'mouseleave',\n  MOUSEUP: 'mouseup'\n};\nvar STATES = {\n  FUSING: 'cursor-fusing',\n  HOVERING: 'cursor-hovering',\n  HOVERED: 'cursor-hovered'\n};\nvar CANVAS_EVENTS = {\n  DOWN: ['mousedown', 'touchstart'],\n  UP: ['mouseup', 'touchend']\n};\nvar CANVAS_HOVER_CLASS = 'a-mouse-cursor-hover';\n/**\n * Cursor component. Applies the raycaster component specifically for starting the raycaster\n * from the camera and pointing from camera's facing direction, and then only returning the\n * closest intersection. Cursor can be fine-tuned by setting raycaster properties.\n *\n * @member {object} fuseTimeout - Timeout to trigger fuse-click.\n * @member {Element} cursorDownEl - Entity that was last mousedowned during current click.\n * @member {object} intersection - Attributes of the current intersection event, including\n *         3D- and 2D-space coordinates. See: http://threejs.org/docs/api/core/Raycaster.html\n * @member {Element} intersectedEl - Currently-intersected entity. Used to keep track to\n *         emit events when unintersecting.\n */\n\nmodule.exports.Component = registerComponent('cursor', {\n  dependencies: ['raycaster'],\n  schema: {\n    downEvents: {\n      default: []\n    },\n    fuse: {\n      default: utils.device.isMobile()\n    },\n    fuseTimeout: {\n      default: 1500,\n      min: 0\n    },\n    mouseCursorStylesEnabled: {\n      default: true\n    },\n    upEvents: {\n      default: []\n    },\n    rayOrigin: {\n      default: 'entity',\n      oneOf: ['mouse', 'entity']\n    }\n  },\n  init: function () {\n    var self = this;\n    this.fuseTimeout = undefined;\n    this.cursorDownEl = null;\n    this.intersectedEl = null;\n    this.canvasBounds = document.body.getBoundingClientRect();\n    this.isCursorDown = false; // Debounce.\n\n    this.updateCanvasBounds = utils.debounce(function updateCanvasBounds() {\n      self.canvasBounds = self.el.sceneEl.canvas.getBoundingClientRect();\n    }, 500);\n    this.eventDetail = {};\n    this.intersectedEventDetail = {\n      cursorEl: this.el\n    }; // Bind methods.\n\n    this.onCursorDown = bind(this.onCursorDown, this);\n    this.onCursorUp = bind(this.onCursorUp, this);\n    this.onIntersection = bind(this.onIntersection, this);\n    this.onIntersectionCleared = bind(this.onIntersectionCleared, this);\n    this.onMouseMove = bind(this.onMouseMove, this);\n  },\n  update: function (oldData) {\n    if (this.data.rayOrigin === oldData.rayOrigin) {\n      return;\n    }\n\n    this.updateMouseEventListeners();\n  },\n  play: function () {\n    this.addEventListeners();\n  },\n  pause: function () {\n    this.removeEventListeners();\n  },\n  remove: function () {\n    var el = this.el;\n    el.removeState(STATES.HOVERING);\n    el.removeState(STATES.FUSING);\n    clearTimeout(this.fuseTimeout);\n\n    if (this.intersectedEl) {\n      this.intersectedEl.removeState(STATES.HOVERED);\n    }\n\n    this.removeEventListeners();\n  },\n  addEventListeners: function () {\n    var canvas;\n    var data = this.data;\n    var el = this.el;\n    var self = this;\n\n    function addCanvasListeners() {\n      canvas = el.sceneEl.canvas;\n\n      if (data.downEvents.length || data.upEvents.length) {\n        return;\n      }\n\n      CANVAS_EVENTS.DOWN.forEach(function (downEvent) {\n        canvas.addEventListener(downEvent, self.onCursorDown);\n      });\n      CANVAS_EVENTS.UP.forEach(function (upEvent) {\n        canvas.addEventListener(upEvent, self.onCursorUp);\n      });\n    }\n\n    canvas = el.sceneEl.canvas;\n\n    if (canvas) {\n      addCanvasListeners();\n    } else {\n      el.sceneEl.addEventListener('render-target-loaded', addCanvasListeners);\n    }\n\n    data.downEvents.forEach(function (downEvent) {\n      el.addEventListener(downEvent, self.onCursorDown);\n    });\n    data.upEvents.forEach(function (upEvent) {\n      el.addEventListener(upEvent, self.onCursorUp);\n    });\n    el.addEventListener('raycaster-intersection', this.onIntersection);\n    el.addEventListener('raycaster-intersection-cleared', this.onIntersectionCleared);\n    el.sceneEl.addEventListener('rendererresize', this.updateCanvasBounds);\n    window.addEventListener('resize', this.updateCanvasBounds);\n    window.addEventListener('scroll', this.updateCanvasBounds);\n    this.updateMouseEventListeners();\n  },\n  removeEventListeners: function () {\n    var canvas;\n    var data = this.data;\n    var el = this.el;\n    var self = this;\n    canvas = el.sceneEl.canvas;\n\n    if (canvas && !data.downEvents.length && !data.upEvents.length) {\n      CANVAS_EVENTS.DOWN.forEach(function (downEvent) {\n        canvas.removeEventListener(downEvent, self.onCursorDown);\n      });\n      CANVAS_EVENTS.UP.forEach(function (upEvent) {\n        canvas.removeEventListener(upEvent, self.onCursorUp);\n      });\n    }\n\n    data.downEvents.forEach(function (downEvent) {\n      el.removeEventListener(downEvent, self.onCursorDown);\n    });\n    data.upEvents.forEach(function (upEvent) {\n      el.removeEventListener(upEvent, self.onCursorUp);\n    });\n    el.removeEventListener('raycaster-intersection', this.onIntersection);\n    el.removeEventListener('raycaster-intersection-cleared', this.onIntersectionCleared);\n    canvas.removeEventListener('mousemove', this.onMouseMove);\n    canvas.removeEventListener('touchstart', this.onMouseMove);\n    canvas.removeEventListener('touchmove', this.onMouseMove);\n    el.sceneEl.removeEventListener('rendererresize', this.updateCanvasBounds);\n    window.removeEventListener('resize', this.updateCanvasBounds);\n    window.removeEventListener('scroll', this.updateCanvasBounds);\n  },\n  updateMouseEventListeners: function () {\n    var canvas;\n    var el = this.el;\n    canvas = el.sceneEl.canvas;\n    canvas.removeEventListener('mousemove', this.onMouseMove);\n    canvas.removeEventListener('touchmove', this.onMouseMove);\n    el.setAttribute('raycaster', 'useWorldCoordinates', false);\n\n    if (this.data.rayOrigin !== 'mouse') {\n      return;\n    }\n\n    canvas.addEventListener('mousemove', this.onMouseMove, false);\n    canvas.addEventListener('touchmove', this.onMouseMove, false);\n    el.setAttribute('raycaster', 'useWorldCoordinates', true);\n    this.updateCanvasBounds();\n  },\n  onMouseMove: function () {\n    var direction = new THREE.Vector3();\n    var mouse = new THREE.Vector2();\n    var origin = new THREE.Vector3();\n    var rayCasterConfig = {\n      origin: origin,\n      direction: direction\n    };\n    return function (evt) {\n      var bounds = this.canvasBounds;\n      var camera = this.el.sceneEl.camera;\n      var left;\n      var point;\n      var top;\n      camera.parent.updateMatrixWorld(); // Calculate mouse position based on the canvas element\n\n      if (evt.type === 'touchmove' || evt.type === 'touchstart') {\n        // Track the first touch for simplicity.\n        point = evt.touches.item(0);\n      } else {\n        point = evt;\n      }\n\n      left = point.clientX - bounds.left;\n      top = point.clientY - bounds.top;\n      mouse.x = left / bounds.width * 2 - 1;\n      mouse.y = -(top / bounds.height) * 2 + 1;\n      origin.setFromMatrixPosition(camera.matrixWorld);\n      direction.set(mouse.x, mouse.y, 0.5).unproject(camera).sub(origin).normalize();\n      this.el.setAttribute('raycaster', rayCasterConfig);\n\n      if (evt.type === 'touchmove') {\n        evt.preventDefault();\n      }\n    };\n  }(),\n\n  /**\n   * Trigger mousedown and keep track of the mousedowned entity.\n   */\n  onCursorDown: function (evt) {\n    this.isCursorDown = true; // Raycast again for touch.\n\n    if (this.data.rayOrigin === 'mouse' && evt.type === 'touchstart') {\n      this.onMouseMove(evt);\n      this.el.components.raycaster.checkIntersections();\n      evt.preventDefault();\n    }\n\n    this.twoWayEmit(EVENTS.MOUSEDOWN);\n    this.cursorDownEl = this.intersectedEl;\n  },\n\n  /**\n   * Trigger mouseup if:\n   * - Not fusing (mobile has no mouse).\n   * - Currently intersecting an entity.\n   * - Currently-intersected entity is the same as the one when mousedown was triggered,\n   *   in case user mousedowned one entity, dragged to another, and mouseupped.\n   */\n  onCursorUp: function (evt) {\n    if (!this.isCursorDown) {\n      return;\n    }\n\n    this.isCursorDown = false;\n    var data = this.data;\n    this.twoWayEmit(EVENTS.MOUSEUP); // If intersected entity has changed since the cursorDown, still emit mouseUp on the\n    // previously cursorUp entity.\n\n    if (this.cursorDownEl && this.cursorDownEl !== this.intersectedEl) {\n      this.intersectedEventDetail.intersection = null;\n      this.cursorDownEl.emit(EVENTS.MOUSEUP, this.intersectedEventDetail);\n    }\n\n    if ((!data.fuse || data.rayOrigin === 'mouse') && this.intersectedEl && this.cursorDownEl === this.intersectedEl) {\n      this.twoWayEmit(EVENTS.CLICK);\n    }\n\n    this.cursorDownEl = null;\n\n    if (evt.type === 'touchend') {\n      evt.preventDefault();\n    }\n  },\n\n  /**\n   * Handle intersection.\n   */\n  onIntersection: function (evt) {\n    var currentIntersection;\n    var cursorEl = this.el;\n    var index;\n    var intersectedEl;\n    var intersection; // Select closest object, excluding the cursor.\n\n    index = evt.detail.els[0] === cursorEl ? 1 : 0;\n    intersection = evt.detail.intersections[index];\n    intersectedEl = evt.detail.els[index]; // If cursor is the only intersected object, ignore the event.\n\n    if (!intersectedEl) {\n      return;\n    } // Already intersecting this entity.\n\n\n    if (this.intersectedEl === intersectedEl) {\n      return;\n    } // Ignore events further away than active intersection.\n\n\n    if (this.intersectedEl) {\n      currentIntersection = this.el.components.raycaster.getIntersection(this.intersectedEl);\n\n      if (currentIntersection && currentIntersection.distance <= intersection.distance) {\n        return;\n      }\n    } // Unset current intersection.\n\n\n    this.clearCurrentIntersection(true);\n    this.setIntersection(intersectedEl, intersection);\n  },\n\n  /**\n   * Handle intersection cleared.\n   */\n  onIntersectionCleared: function (evt) {\n    var clearedEls = evt.detail.clearedEls; // Check if the current intersection has ended\n\n    if (clearedEls.indexOf(this.intersectedEl) === -1) {\n      return;\n    }\n\n    this.clearCurrentIntersection();\n  },\n  setIntersection: function (intersectedEl, intersection) {\n    var cursorEl = this.el;\n    var data = this.data;\n    var self = this; // Already intersecting.\n\n    if (this.intersectedEl === intersectedEl) {\n      return;\n    } // Set new intersection.\n\n\n    this.intersectedEl = intersectedEl; // Hovering.\n\n    cursorEl.addState(STATES.HOVERING);\n    intersectedEl.addState(STATES.HOVERED);\n    this.twoWayEmit(EVENTS.MOUSEENTER);\n\n    if (this.data.mouseCursorStylesEnabled && this.data.rayOrigin === 'mouse') {\n      this.el.sceneEl.canvas.classList.add(CANVAS_HOVER_CLASS);\n    } // Begin fuse if necessary.\n\n\n    if (data.fuseTimeout === 0 || !data.fuse) {\n      return;\n    }\n\n    cursorEl.addState(STATES.FUSING);\n    this.twoWayEmit(EVENTS.FUSING);\n    this.fuseTimeout = setTimeout(function fuse() {\n      cursorEl.removeState(STATES.FUSING);\n      self.twoWayEmit(EVENTS.CLICK);\n    }, data.fuseTimeout);\n  },\n  clearCurrentIntersection: function (ignoreRemaining) {\n    var index;\n    var intersection;\n    var intersections;\n    var cursorEl = this.el; // Nothing to be cleared.\n\n    if (!this.intersectedEl) {\n      return;\n    } // No longer hovering (or fusing).\n\n\n    this.intersectedEl.removeState(STATES.HOVERED);\n    cursorEl.removeState(STATES.HOVERING);\n    cursorEl.removeState(STATES.FUSING);\n    this.twoWayEmit(EVENTS.MOUSELEAVE);\n\n    if (this.data.mouseCursorStylesEnabled && this.data.rayOrigin === 'mouse') {\n      this.el.sceneEl.canvas.classList.remove(CANVAS_HOVER_CLASS);\n    } // Unset intersected entity (after emitting the event).\n\n\n    this.intersectedEl = null; // Clear fuseTimeout.\n\n    clearTimeout(this.fuseTimeout); // Set intersection to another raycasted element if any.\n\n    if (ignoreRemaining === true) {\n      return;\n    }\n\n    intersections = this.el.components.raycaster.intersections;\n\n    if (intersections.length === 0) {\n      return;\n    } // Exclude the cursor.\n\n\n    index = intersections[0].object.el === cursorEl ? 1 : 0;\n    intersection = intersections[index];\n\n    if (!intersection) {\n      return;\n    }\n\n    this.setIntersection(intersection.object.el, intersection);\n  },\n\n  /**\n   * Helper to emit on both the cursor and the intersected entity (if exists).\n   */\n  twoWayEmit: function (evtName) {\n    var el = this.el;\n    var intersectedEl = this.intersectedEl;\n    var intersection;\n    intersection = this.el.components.raycaster.getIntersection(intersectedEl);\n    this.eventDetail.intersectedEl = intersectedEl;\n    this.eventDetail.intersection = intersection;\n    el.emit(evtName, this.eventDetail);\n\n    if (!intersectedEl) {\n      return;\n    }\n\n    this.intersectedEventDetail.intersection = intersection;\n    intersectedEl.emit(evtName, this.intersectedEventDetail);\n  }\n});","map":{"version":3,"sources":["C:/Users/Hannuri/Desktop/RoyalCyber/my-first-app/node_modules/aframe/src/components/cursor.js"],"names":["registerComponent","require","utils","bind","EVENTS","CLICK","FUSING","MOUSEENTER","MOUSEDOWN","MOUSELEAVE","MOUSEUP","STATES","HOVERING","HOVERED","CANVAS_EVENTS","DOWN","UP","CANVAS_HOVER_CLASS","module","exports","Component","dependencies","schema","downEvents","default","fuse","device","isMobile","fuseTimeout","min","mouseCursorStylesEnabled","upEvents","rayOrigin","oneOf","init","self","undefined","cursorDownEl","intersectedEl","canvasBounds","document","body","getBoundingClientRect","isCursorDown","updateCanvasBounds","debounce","el","sceneEl","canvas","eventDetail","intersectedEventDetail","cursorEl","onCursorDown","onCursorUp","onIntersection","onIntersectionCleared","onMouseMove","update","oldData","data","updateMouseEventListeners","play","addEventListeners","pause","removeEventListeners","remove","removeState","clearTimeout","addCanvasListeners","length","forEach","downEvent","addEventListener","upEvent","window","removeEventListener","setAttribute","direction","THREE","Vector3","mouse","Vector2","origin","rayCasterConfig","evt","bounds","camera","left","point","top","parent","updateMatrixWorld","type","touches","item","clientX","clientY","x","width","y","height","setFromMatrixPosition","matrixWorld","set","unproject","sub","normalize","preventDefault","components","raycaster","checkIntersections","twoWayEmit","intersection","emit","currentIntersection","index","detail","els","intersections","getIntersection","distance","clearCurrentIntersection","setIntersection","clearedEls","indexOf","addState","classList","add","setTimeout","ignoreRemaining","object","evtName"],"mappings":"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","sourcesContent":["/* global THREE */\nvar registerComponent = require('../core/component').registerComponent;\nvar utils = require('../utils/');\n\nvar bind = utils.bind;\n\nvar EVENTS = {\n  CLICK: 'click',\n  FUSING: 'fusing',\n  MOUSEENTER: 'mouseenter',\n  MOUSEDOWN: 'mousedown',\n  MOUSELEAVE: 'mouseleave',\n  MOUSEUP: 'mouseup'\n};\n\nvar STATES = {\n  FUSING: 'cursor-fusing',\n  HOVERING: 'cursor-hovering',\n  HOVERED: 'cursor-hovered'\n};\n\nvar CANVAS_EVENTS = {\n  DOWN: ['mousedown', 'touchstart'],\n  UP: ['mouseup', 'touchend']\n};\n\nvar CANVAS_HOVER_CLASS = 'a-mouse-cursor-hover';\n\n/**\n * Cursor component. Applies the raycaster component specifically for starting the raycaster\n * from the camera and pointing from camera's facing direction, and then only returning the\n * closest intersection. Cursor can be fine-tuned by setting raycaster properties.\n *\n * @member {object} fuseTimeout - Timeout to trigger fuse-click.\n * @member {Element} cursorDownEl - Entity that was last mousedowned during current click.\n * @member {object} intersection - Attributes of the current intersection event, including\n *         3D- and 2D-space coordinates. See: http://threejs.org/docs/api/core/Raycaster.html\n * @member {Element} intersectedEl - Currently-intersected entity. Used to keep track to\n *         emit events when unintersecting.\n */\nmodule.exports.Component = registerComponent('cursor', {\n  dependencies: ['raycaster'],\n\n  schema: {\n    downEvents: {default: []},\n    fuse: {default: utils.device.isMobile()},\n    fuseTimeout: {default: 1500, min: 0},\n    mouseCursorStylesEnabled: {default: true},\n    upEvents: {default: []},\n    rayOrigin: {default: 'entity', oneOf: ['mouse', 'entity']}\n  },\n\n  init: function () {\n    var self = this;\n\n    this.fuseTimeout = undefined;\n    this.cursorDownEl = null;\n    this.intersectedEl = null;\n    this.canvasBounds = document.body.getBoundingClientRect();\n    this.isCursorDown = false;\n\n    // Debounce.\n    this.updateCanvasBounds = utils.debounce(function updateCanvasBounds () {\n      self.canvasBounds = self.el.sceneEl.canvas.getBoundingClientRect();\n    }, 500);\n\n    this.eventDetail = {};\n    this.intersectedEventDetail = {cursorEl: this.el};\n\n    // Bind methods.\n    this.onCursorDown = bind(this.onCursorDown, this);\n    this.onCursorUp = bind(this.onCursorUp, this);\n    this.onIntersection = bind(this.onIntersection, this);\n    this.onIntersectionCleared = bind(this.onIntersectionCleared, this);\n    this.onMouseMove = bind(this.onMouseMove, this);\n  },\n\n  update: function (oldData) {\n    if (this.data.rayOrigin === oldData.rayOrigin) { return; }\n    this.updateMouseEventListeners();\n  },\n\n  play: function () {\n    this.addEventListeners();\n  },\n\n  pause: function () {\n    this.removeEventListeners();\n  },\n\n  remove: function () {\n    var el = this.el;\n    el.removeState(STATES.HOVERING);\n    el.removeState(STATES.FUSING);\n    clearTimeout(this.fuseTimeout);\n    if (this.intersectedEl) { this.intersectedEl.removeState(STATES.HOVERED); }\n    this.removeEventListeners();\n  },\n\n  addEventListeners: function () {\n    var canvas;\n    var data = this.data;\n    var el = this.el;\n    var self = this;\n\n    function addCanvasListeners () {\n      canvas = el.sceneEl.canvas;\n      if (data.downEvents.length || data.upEvents.length) { return; }\n      CANVAS_EVENTS.DOWN.forEach(function (downEvent) {\n        canvas.addEventListener(downEvent, self.onCursorDown);\n      });\n      CANVAS_EVENTS.UP.forEach(function (upEvent) {\n        canvas.addEventListener(upEvent, self.onCursorUp);\n      });\n    }\n\n    canvas = el.sceneEl.canvas;\n    if (canvas) {\n      addCanvasListeners();\n    } else {\n      el.sceneEl.addEventListener('render-target-loaded', addCanvasListeners);\n    }\n\n    data.downEvents.forEach(function (downEvent) {\n      el.addEventListener(downEvent, self.onCursorDown);\n    });\n    data.upEvents.forEach(function (upEvent) {\n      el.addEventListener(upEvent, self.onCursorUp);\n    });\n    el.addEventListener('raycaster-intersection', this.onIntersection);\n    el.addEventListener('raycaster-intersection-cleared', this.onIntersectionCleared);\n\n    el.sceneEl.addEventListener('rendererresize', this.updateCanvasBounds);\n    window.addEventListener('resize', this.updateCanvasBounds);\n    window.addEventListener('scroll', this.updateCanvasBounds);\n\n    this.updateMouseEventListeners();\n  },\n\n  removeEventListeners: function () {\n    var canvas;\n    var data = this.data;\n    var el = this.el;\n    var self = this;\n\n    canvas = el.sceneEl.canvas;\n    if (canvas && !data.downEvents.length && !data.upEvents.length) {\n      CANVAS_EVENTS.DOWN.forEach(function (downEvent) {\n        canvas.removeEventListener(downEvent, self.onCursorDown);\n      });\n      CANVAS_EVENTS.UP.forEach(function (upEvent) {\n        canvas.removeEventListener(upEvent, self.onCursorUp);\n      });\n    }\n\n    data.downEvents.forEach(function (downEvent) {\n      el.removeEventListener(downEvent, self.onCursorDown);\n    });\n    data.upEvents.forEach(function (upEvent) {\n      el.removeEventListener(upEvent, self.onCursorUp);\n    });\n    el.removeEventListener('raycaster-intersection', this.onIntersection);\n    el.removeEventListener('raycaster-intersection-cleared', this.onIntersectionCleared);\n    canvas.removeEventListener('mousemove', this.onMouseMove);\n    canvas.removeEventListener('touchstart', this.onMouseMove);\n    canvas.removeEventListener('touchmove', this.onMouseMove);\n\n    el.sceneEl.removeEventListener('rendererresize', this.updateCanvasBounds);\n    window.removeEventListener('resize', this.updateCanvasBounds);\n    window.removeEventListener('scroll', this.updateCanvasBounds);\n  },\n\n  updateMouseEventListeners: function () {\n    var canvas;\n    var el = this.el;\n\n    canvas = el.sceneEl.canvas;\n    canvas.removeEventListener('mousemove', this.onMouseMove);\n    canvas.removeEventListener('touchmove', this.onMouseMove);\n    el.setAttribute('raycaster', 'useWorldCoordinates', false);\n    if (this.data.rayOrigin !== 'mouse') { return; }\n    canvas.addEventListener('mousemove', this.onMouseMove, false);\n    canvas.addEventListener('touchmove', this.onMouseMove, false);\n    el.setAttribute('raycaster', 'useWorldCoordinates', true);\n    this.updateCanvasBounds();\n  },\n\n  onMouseMove: (function () {\n    var direction = new THREE.Vector3();\n    var mouse = new THREE.Vector2();\n    var origin = new THREE.Vector3();\n    var rayCasterConfig = {origin: origin, direction: direction};\n\n    return function (evt) {\n      var bounds = this.canvasBounds;\n      var camera = this.el.sceneEl.camera;\n      var left;\n      var point;\n      var top;\n\n      camera.parent.updateMatrixWorld();\n\n      // Calculate mouse position based on the canvas element\n      if (evt.type === 'touchmove' || evt.type === 'touchstart') {\n        // Track the first touch for simplicity.\n        point = evt.touches.item(0);\n      } else {\n        point = evt;\n      }\n\n      left = point.clientX - bounds.left;\n      top = point.clientY - bounds.top;\n      mouse.x = (left / bounds.width) * 2 - 1;\n      mouse.y = -(top / bounds.height) * 2 + 1;\n\n      origin.setFromMatrixPosition(camera.matrixWorld);\n      direction.set(mouse.x, mouse.y, 0.5).unproject(camera).sub(origin).normalize();\n      this.el.setAttribute('raycaster', rayCasterConfig);\n      if (evt.type === 'touchmove') { evt.preventDefault(); }\n    };\n  })(),\n\n  /**\n   * Trigger mousedown and keep track of the mousedowned entity.\n   */\n  onCursorDown: function (evt) {\n    this.isCursorDown = true;\n    // Raycast again for touch.\n    if (this.data.rayOrigin === 'mouse' && evt.type === 'touchstart') {\n      this.onMouseMove(evt);\n      this.el.components.raycaster.checkIntersections();\n      evt.preventDefault();\n    }\n\n    this.twoWayEmit(EVENTS.MOUSEDOWN);\n    this.cursorDownEl = this.intersectedEl;\n  },\n\n  /**\n   * Trigger mouseup if:\n   * - Not fusing (mobile has no mouse).\n   * - Currently intersecting an entity.\n   * - Currently-intersected entity is the same as the one when mousedown was triggered,\n   *   in case user mousedowned one entity, dragged to another, and mouseupped.\n   */\n  onCursorUp: function (evt) {\n    if (!this.isCursorDown) { return; }\n\n    this.isCursorDown = false;\n\n    var data = this.data;\n    this.twoWayEmit(EVENTS.MOUSEUP);\n\n    // If intersected entity has changed since the cursorDown, still emit mouseUp on the\n    // previously cursorUp entity.\n    if (this.cursorDownEl && this.cursorDownEl !== this.intersectedEl) {\n      this.intersectedEventDetail.intersection = null;\n      this.cursorDownEl.emit(EVENTS.MOUSEUP, this.intersectedEventDetail);\n    }\n\n    if ((!data.fuse || data.rayOrigin === 'mouse') &&\n        this.intersectedEl && this.cursorDownEl === this.intersectedEl) {\n      this.twoWayEmit(EVENTS.CLICK);\n    }\n\n    this.cursorDownEl = null;\n    if (evt.type === 'touchend') { evt.preventDefault(); }\n  },\n\n  /**\n   * Handle intersection.\n   */\n  onIntersection: function (evt) {\n    var currentIntersection;\n    var cursorEl = this.el;\n    var index;\n    var intersectedEl;\n    var intersection;\n\n    // Select closest object, excluding the cursor.\n    index = evt.detail.els[0] === cursorEl ? 1 : 0;\n    intersection = evt.detail.intersections[index];\n    intersectedEl = evt.detail.els[index];\n\n    // If cursor is the only intersected object, ignore the event.\n    if (!intersectedEl) { return; }\n\n    // Already intersecting this entity.\n    if (this.intersectedEl === intersectedEl) { return; }\n\n    // Ignore events further away than active intersection.\n    if (this.intersectedEl) {\n      currentIntersection = this.el.components.raycaster.getIntersection(this.intersectedEl);\n      if (currentIntersection && currentIntersection.distance <= intersection.distance) { return; }\n    }\n\n    // Unset current intersection.\n    this.clearCurrentIntersection(true);\n\n    this.setIntersection(intersectedEl, intersection);\n  },\n\n  /**\n   * Handle intersection cleared.\n   */\n  onIntersectionCleared: function (evt) {\n    var clearedEls = evt.detail.clearedEls;\n    // Check if the current intersection has ended\n    if (clearedEls.indexOf(this.intersectedEl) === -1) { return; }\n    this.clearCurrentIntersection();\n  },\n\n  setIntersection: function (intersectedEl, intersection) {\n    var cursorEl = this.el;\n    var data = this.data;\n    var self = this;\n\n    // Already intersecting.\n    if (this.intersectedEl === intersectedEl) { return; }\n\n    // Set new intersection.\n    this.intersectedEl = intersectedEl;\n\n    // Hovering.\n    cursorEl.addState(STATES.HOVERING);\n    intersectedEl.addState(STATES.HOVERED);\n    this.twoWayEmit(EVENTS.MOUSEENTER);\n\n    if (this.data.mouseCursorStylesEnabled && this.data.rayOrigin === 'mouse') {\n      this.el.sceneEl.canvas.classList.add(CANVAS_HOVER_CLASS);\n    }\n\n    // Begin fuse if necessary.\n    if (data.fuseTimeout === 0 || !data.fuse) { return; }\n    cursorEl.addState(STATES.FUSING);\n    this.twoWayEmit(EVENTS.FUSING);\n    this.fuseTimeout = setTimeout(function fuse () {\n      cursorEl.removeState(STATES.FUSING);\n      self.twoWayEmit(EVENTS.CLICK);\n    }, data.fuseTimeout);\n  },\n\n  clearCurrentIntersection: function (ignoreRemaining) {\n    var index;\n    var intersection;\n    var intersections;\n    var cursorEl = this.el;\n\n    // Nothing to be cleared.\n    if (!this.intersectedEl) { return; }\n\n    // No longer hovering (or fusing).\n    this.intersectedEl.removeState(STATES.HOVERED);\n    cursorEl.removeState(STATES.HOVERING);\n    cursorEl.removeState(STATES.FUSING);\n    this.twoWayEmit(EVENTS.MOUSELEAVE);\n\n    if (this.data.mouseCursorStylesEnabled && this.data.rayOrigin === 'mouse') {\n      this.el.sceneEl.canvas.classList.remove(CANVAS_HOVER_CLASS);\n    }\n\n    // Unset intersected entity (after emitting the event).\n    this.intersectedEl = null;\n\n    // Clear fuseTimeout.\n    clearTimeout(this.fuseTimeout);\n\n    // Set intersection to another raycasted element if any.\n    if (ignoreRemaining === true) { return; }\n    intersections = this.el.components.raycaster.intersections;\n    if (intersections.length === 0) { return; }\n    // Exclude the cursor.\n    index = intersections[0].object.el === cursorEl ? 1 : 0;\n    intersection = intersections[index];\n    if (!intersection) { return; }\n    this.setIntersection(intersection.object.el, intersection);\n  },\n\n  /**\n   * Helper to emit on both the cursor and the intersected entity (if exists).\n   */\n  twoWayEmit: function (evtName) {\n    var el = this.el;\n    var intersectedEl = this.intersectedEl;\n    var intersection;\n\n    intersection = this.el.components.raycaster.getIntersection(intersectedEl);\n    this.eventDetail.intersectedEl = intersectedEl;\n    this.eventDetail.intersection = intersection;\n    el.emit(evtName, this.eventDetail);\n\n    if (!intersectedEl) { return; }\n\n    this.intersectedEventDetail.intersection = intersection;\n    intersectedEl.emit(evtName, this.intersectedEventDetail);\n  }\n});\n"]},"metadata":{},"sourceType":"script"}