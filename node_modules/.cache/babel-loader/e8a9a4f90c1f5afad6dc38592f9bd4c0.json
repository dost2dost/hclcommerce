{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b, _c;\n\nimport { AnimationMixer, Box3, Object3D, Vector3 } from 'three';\nimport { CachingGLTFLoader } from './CachingGLTFLoader.js';\nimport { ModelViewerGLTFInstance } from './gltf-instance/ModelViewerGLTFInstance.js';\nimport { Hotspot } from './Hotspot.js';\nimport { moveChildren, reduceVertices } from './ModelUtils.js';\nimport { Shadow } from './Shadow.js';\nexport const DEFAULT_FOV_DEG = 45;\nconst DEFAULT_HALF_FOV = DEFAULT_FOV_DEG / 2 * Math.PI / 180;\nexport const SAFE_RADIUS_RATIO = Math.sin(DEFAULT_HALF_FOV);\nexport const DEFAULT_TAN_FOV = Math.tan(DEFAULT_HALF_FOV);\nexport const $shadow = Symbol('shadow');\nconst $cancelPendingSourceChange = Symbol('cancelPendingSourceChange');\nconst $currentGLTF = Symbol('currentGLTF');\nconst $loader = Symbol('loader');\nconst view = new Vector3();\nconst target = new Vector3();\nconst normalWorld = new Vector3();\n/**\n * An Object3D that can swap out its underlying model.\n */\n\nexport default class Model extends Object3D {\n  /**\n   * Creates a model.\n   */\n  constructor() {\n    super();\n    this[_a] = null;\n    this[_b] = null;\n    this[_c] = new CachingGLTFLoader(ModelViewerGLTFInstance);\n    this.animations = [];\n    this.animationsByName = new Map();\n    this.currentAnimationAction = null;\n    this.modelContainer = new Object3D();\n    this.animationNames = [];\n    this.boundingBox = new Box3();\n    this.size = new Vector3();\n    this.idealCameraDistance = 0;\n    this.fieldOfViewAspect = 0;\n    this.userData = {\n      url: null\n    };\n    this.url = null;\n    this.name = 'Model';\n    this.modelContainer.name = 'ModelContainer';\n    this.add(this.modelContainer);\n    this.mixer = new AnimationMixer(this.modelContainer);\n  }\n\n  get loader() {\n    return this[$loader];\n  }\n  /**\n   * Returns a boolean indicating whether or not there is a\n   * loaded model attached.\n   */\n\n\n  hasModel() {\n    return !!this.modelContainer.children.length;\n  }\n  /**\n   * Pass in a THREE.Object3D to be controlled\n   * by this model.\n   */\n\n\n  setObject(model) {\n    this.clear();\n    this.modelContainer.add(model);\n    this.updateFraming();\n    this.dispatchEvent({\n      type: 'model-load'\n    });\n  }\n\n  async setSource(url, progressCallback) {\n    if (!url || url === this.url) {\n      if (progressCallback) {\n        progressCallback(1);\n      }\n\n      return;\n    } // If we have pending work due to a previous source change in progress,\n    // cancel it so that we do not incur a race condition:\n\n\n    if (this[$cancelPendingSourceChange] != null) {\n      this[$cancelPendingSourceChange]();\n      this[$cancelPendingSourceChange] = null;\n    }\n\n    this.url = url;\n    let gltf;\n\n    try {\n      gltf = await new Promise(async (resolve, reject) => {\n        this[$cancelPendingSourceChange] = () => reject();\n\n        try {\n          const result = await this.loader.load(url, progressCallback);\n          resolve(result);\n        } catch (error) {\n          reject(error);\n        }\n      });\n    } catch (error) {\n      if (error == null) {\n        // Loading was cancelled, so silently return\n        return;\n      }\n\n      throw error;\n    }\n\n    this.clear();\n    this[$currentGLTF] = gltf;\n\n    if (gltf != null) {\n      moveChildren(gltf.scene, this.modelContainer);\n    }\n\n    const _gltf = gltf,\n          animations = _gltf.animations;\n    const animationsByName = new Map();\n    const animationNames = [];\n\n    for (const animation of animations) {\n      animationsByName.set(animation.name, animation);\n      animationNames.push(animation.name);\n    }\n\n    this.animations = animations;\n    this.animationsByName = animationsByName;\n    this.animationNames = animationNames;\n    this.userData.url = url;\n    this.updateFraming();\n    this.dispatchEvent({\n      type: 'model-load',\n      url\n    });\n  }\n\n  set animationTime(value) {\n    this.mixer.setTime(value);\n  }\n\n  get animationTime() {\n    if (this.currentAnimationAction != null) {\n      return this.currentAnimationAction.time;\n    }\n\n    return 0;\n  }\n\n  get hasActiveAnimation() {\n    return this.currentAnimationAction != null;\n  }\n  /**\n   * Plays an animation if there are any associated with the current model.\n   * Accepts an optional string name of an animation to play. If no name is\n   * provided, or if no animation is found by the given name, always falls back\n   * to playing the first animation.\n   */\n\n\n  playAnimation(name = null, crossfadeTime = 0) {\n    const animations = this.animations;\n\n    if (animations == null || animations.length === 0) {\n      console.warn(`Cannot play animation (model does not have any animations)`);\n      return;\n    }\n\n    let animationClip = null;\n\n    if (name != null) {\n      animationClip = this.animationsByName.get(name);\n    }\n\n    if (animationClip == null) {\n      animationClip = animations[0];\n    }\n\n    try {\n      const lastAnimationAction = this.currentAnimationAction;\n      this.currentAnimationAction = this.mixer.clipAction(animationClip, this).play();\n      this.currentAnimationAction.enabled = true;\n\n      if (lastAnimationAction != null && this.currentAnimationAction !== lastAnimationAction) {\n        this.currentAnimationAction.crossFadeFrom(lastAnimationAction, crossfadeTime, false);\n      }\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  stopAnimation() {\n    if (this.currentAnimationAction != null) {\n      this.currentAnimationAction.stop();\n      this.currentAnimationAction.reset();\n      this.currentAnimationAction = null;\n    }\n\n    this.mixer.stopAllAction();\n  }\n\n  updateAnimation(step) {\n    this.mixer.update(step);\n  }\n\n  clear() {\n    this.url = null;\n    this.userData = {\n      url: null\n    };\n    const gltf = this[$currentGLTF]; // Remove all current children\n\n    if (gltf != null) {\n      moveChildren(this.modelContainer, gltf.scene);\n      gltf.dispose();\n      this[$currentGLTF] = null;\n    }\n\n    if (this.currentAnimationAction != null) {\n      this.currentAnimationAction.stop();\n      this.currentAnimationAction = null;\n    }\n\n    this.mixer.stopAllAction();\n    this.mixer.uncacheRoot(this);\n  }\n  /**\n   * Calculates the idealCameraDistance and fieldOfViewAspect that allows the 3D\n   * object to be framed tightly in a 2D window of any aspect ratio without\n   * clipping at any camera orbit. The camera's center target point can be\n   * optionally specified. If no center is specified, it defaults to the center\n   * of the bounding box, which means asymmetric models will tend to be tight on\n   * one side instead of both. Proper choice of center can correct this.\n   */\n\n\n  updateFraming(center = null) {\n    this.remove(this.modelContainer);\n\n    if (center == null) {\n      this.boundingBox.setFromObject(this.modelContainer);\n      this.boundingBox.getSize(this.size);\n      center = this.boundingBox.getCenter(new Vector3());\n    }\n\n    const radiusSquared = (value, vertex) => {\n      return Math.max(value, center.distanceToSquared(vertex));\n    };\n\n    const framedRadius = Math.sqrt(reduceVertices(this.modelContainer, radiusSquared));\n    this.idealCameraDistance = framedRadius / SAFE_RADIUS_RATIO;\n\n    const horizontalFov = (value, vertex) => {\n      vertex.sub(center);\n      const radiusXZ = Math.sqrt(vertex.x * vertex.x + vertex.z * vertex.z);\n      return Math.max(value, radiusXZ / (this.idealCameraDistance - Math.abs(vertex.y)));\n    };\n\n    this.fieldOfViewAspect = reduceVertices(this.modelContainer, horizontalFov) / DEFAULT_TAN_FOV;\n    this.add(this.modelContainer);\n  }\n  /**\n   * Sets the shadow's intensity, lazily creating the shadow as necessary.\n   */\n\n\n  setShadowIntensity(shadowIntensity, shadowSoftness) {\n    let shadow = this[$shadow];\n\n    if (shadow != null) {\n      shadow.setIntensity(shadowIntensity);\n      shadow.setModel(this, shadowSoftness);\n    } else if (shadowIntensity > 0) {\n      shadow = new Shadow(this, shadowSoftness);\n      shadow.setIntensity(shadowIntensity);\n      this[$shadow] = shadow;\n    }\n  }\n  /**\n   * Sets the shadow's softness by mapping a [0, 1] softness parameter to the\n   * shadow's resolution. This involves reallocation, so it should not be\n   * changed frequently. Softer shadows are cheaper to render.\n   */\n\n\n  setShadowSoftness(softness) {\n    const shadow = this[$shadow];\n\n    if (shadow != null) {\n      shadow.setSoftness(softness);\n    }\n  }\n  /**\n   * The shadow must be rotated manually to match any global rotation applied to\n   * this model. The input is the global orientation about the Y axis.\n   */\n\n\n  setShadowRotation(radiansY) {\n    const shadow = this[$shadow];\n\n    if (shadow != null) {\n      shadow.setRotation(radiansY);\n    }\n  }\n  /**\n   * Call when updating the shadow; returns true if an update is needed and\n   * resets the state.\n   */\n\n\n  updateShadow() {\n    const shadow = this[$shadow];\n\n    if (shadow == null) {\n      return false;\n    } else {\n      const needsUpdate = shadow.needsUpdate;\n      shadow.needsUpdate = false;\n      return needsUpdate;\n    }\n  }\n  /**\n   * Shift the floor vertically from the bottom of the model's bounding box by\n   * offset (should generally be negative).\n   */\n\n\n  setShadowScaleAndOffset(scale, offset) {\n    const shadow = this[$shadow];\n\n    if (shadow != null) {\n      shadow.setScaleAndOffset(scale, offset);\n    }\n  }\n  /**\n   * The following methods are for operating on the set of Hotspot objects\n   * attached to the scene. These come from DOM elements, provided to slots by\n   * the Annotation Mixin.\n   */\n\n\n  addHotspot(hotspot) {\n    this.add(hotspot);\n  }\n\n  removeHotspot(hotspot) {\n    this.remove(hotspot);\n  }\n  /**\n   * Helper method to apply a function to all hotspots.\n   */\n\n\n  forHotspots(func) {\n    const children = this.children;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      const hotspot = children[i];\n\n      if (hotspot instanceof Hotspot) {\n        func(hotspot);\n      }\n    }\n  }\n  /**\n   * Update the CSS visibility of the hotspots based on whether their normals\n   * point toward the camera.\n   */\n\n\n  updateHotspots(viewerPosition) {\n    this.forHotspots(hotspot => {\n      view.copy(viewerPosition);\n      target.setFromMatrixPosition(hotspot.matrixWorld);\n      view.sub(target);\n      normalWorld.copy(hotspot.normal).transformDirection(this.matrixWorld);\n\n      if (view.dot(normalWorld) < 0) {\n        hotspot.hide();\n      } else {\n        hotspot.show();\n      }\n    });\n  }\n  /**\n   * Rotate all hotspots to an absolute orientation given by the input number of\n   * radians. Zero returns them to upright.\n   */\n\n\n  orientHotspots(radians) {\n    this.forHotspots(hotspot => {\n      hotspot.orient(radians);\n    });\n  }\n  /**\n   * Set the rendering visibility of all hotspots. This is used to hide them\n   * during transitions and such.\n   */\n\n\n  setHotspotsVisibility(visible) {\n    this.forHotspots(hotspot => {\n      hotspot.visible = visible;\n    });\n  }\n\n}\n_a = $shadow, _b = $currentGLTF, _c = $loader;","map":{"version":3,"sources":["../../src/three-components/Model.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {AnimationAction, AnimationClip, AnimationMixer, Box3, Object3D, Vector3} from 'three';\n\nimport {CachingGLTFLoader} from './CachingGLTFLoader.js';\nimport {ModelViewerGLTFInstance} from './gltf-instance/ModelViewerGLTFInstance.js';\nimport {Hotspot} from './Hotspot.js';\nimport {moveChildren, reduceVertices} from './ModelUtils.js';\nimport {Shadow} from './Shadow.js';\n\nexport const DEFAULT_FOV_DEG = 45;\nconst DEFAULT_HALF_FOV = (DEFAULT_FOV_DEG / 2) * Math.PI / 180;\nexport const SAFE_RADIUS_RATIO = Math.sin(DEFAULT_HALF_FOV);\nexport const DEFAULT_TAN_FOV = Math.tan(DEFAULT_HALF_FOV);\n\nexport const $shadow = Symbol('shadow');\nconst $cancelPendingSourceChange = Symbol('cancelPendingSourceChange');\nconst $currentGLTF = Symbol('currentGLTF');\nconst $loader = Symbol('loader');\n\nconst view = new Vector3();\nconst target = new Vector3();\nconst normalWorld = new Vector3();\n\n/**\n * An Object3D that can swap out its underlying model.\n */\nexport default class Model extends Object3D {\n  protected[$shadow]: Shadow|null = null;\n\n  private[$currentGLTF]: ModelViewerGLTFInstance|null = null;\n  private[$loader] = new CachingGLTFLoader(ModelViewerGLTFInstance);\n  private mixer: AnimationMixer;\n  private[$cancelPendingSourceChange]: (() => void)|null;\n  private animations: Array<AnimationClip> = [];\n  private animationsByName: Map<string, AnimationClip> = new Map();\n  private currentAnimationAction: AnimationAction|null = null;\n\n  public modelContainer = new Object3D();\n  public animationNames: Array<string> = [];\n  public boundingBox = new Box3();\n  public size = new Vector3();\n  public idealCameraDistance = 0;\n  public fieldOfViewAspect = 0;\n  public userData: {url: string|null} = {url: null};\n  public url: string|null = null;\n\n  get loader() {\n    return this[$loader];\n  }\n\n  /**\n   * Creates a model.\n   */\n  constructor() {\n    super();\n\n    this.name = 'Model';\n    this.modelContainer.name = 'ModelContainer';\n\n    this.add(this.modelContainer);\n    this.mixer = new AnimationMixer(this.modelContainer);\n  }\n\n  /**\n   * Returns a boolean indicating whether or not there is a\n   * loaded model attached.\n   */\n  hasModel(): boolean {\n    return !!this.modelContainer.children.length;\n  }\n\n  /**\n   * Pass in a THREE.Object3D to be controlled\n   * by this model.\n   */\n  setObject(model: Object3D) {\n    this.clear();\n    this.modelContainer.add(model);\n    this.updateFraming();\n    this.dispatchEvent({type: 'model-load'});\n  }\n\n  async setSource(\n      url: string|null, progressCallback?: (progress: number) => void) {\n    if (!url || url === this.url) {\n      if (progressCallback) {\n        progressCallback(1);\n      }\n      return;\n    }\n\n    // If we have pending work due to a previous source change in progress,\n    // cancel it so that we do not incur a race condition:\n    if (this[$cancelPendingSourceChange] != null) {\n      this[$cancelPendingSourceChange]!();\n      this[$cancelPendingSourceChange] = null;\n    }\n\n    this.url = url;\n\n    let gltf: ModelViewerGLTFInstance;\n\n    try {\n      gltf = await new Promise<ModelViewerGLTFInstance>(\n          async (resolve, reject) => {\n            this[$cancelPendingSourceChange] = () => reject();\n            try {\n              const result = await this.loader.load(url, progressCallback);\n              resolve(result);\n            } catch (error) {\n              reject(error);\n            }\n          });\n    } catch (error) {\n      if (error == null) {\n        // Loading was cancelled, so silently return\n        return;\n      }\n\n      throw error;\n    }\n\n    this.clear();\n    this[$currentGLTF] = gltf;\n\n    if (gltf != null) {\n      moveChildren(gltf.scene, this.modelContainer);\n    }\n\n    const {animations} = gltf!;\n    const animationsByName = new Map();\n    const animationNames = [];\n\n    for (const animation of animations) {\n      animationsByName.set(animation.name, animation);\n      animationNames.push(animation.name);\n    }\n\n    this.animations = animations;\n    this.animationsByName = animationsByName;\n    this.animationNames = animationNames;\n\n    this.userData.url = url;\n\n    this.updateFraming();\n\n    this.dispatchEvent({type: 'model-load', url});\n  }\n\n  set animationTime(value: number) {\n    this.mixer.setTime(value);\n  }\n\n  get animationTime(): number {\n    if (this.currentAnimationAction != null) {\n      return this.currentAnimationAction.time;\n    }\n\n    return 0;\n  }\n\n  get hasActiveAnimation(): boolean {\n    return this.currentAnimationAction != null;\n  }\n\n  /**\n   * Plays an animation if there are any associated with the current model.\n   * Accepts an optional string name of an animation to play. If no name is\n   * provided, or if no animation is found by the given name, always falls back\n   * to playing the first animation.\n   */\n  playAnimation(name: string|null = null, crossfadeTime: number = 0) {\n    const {animations} = this;\n    if (animations == null || animations.length === 0) {\n      console.warn(\n          `Cannot play animation (model does not have any animations)`);\n      return;\n    }\n\n    let animationClip = null;\n\n    if (name != null) {\n      animationClip = this.animationsByName.get(name);\n    }\n\n    if (animationClip == null) {\n      animationClip = animations[0];\n    }\n\n    try {\n      const {currentAnimationAction: lastAnimationAction} = this;\n\n      this.currentAnimationAction =\n          this.mixer.clipAction(animationClip, this).play();\n      this.currentAnimationAction.enabled = true;\n\n      if (lastAnimationAction != null &&\n          this.currentAnimationAction !== lastAnimationAction) {\n        this.currentAnimationAction.crossFadeFrom(\n            lastAnimationAction, crossfadeTime, false);\n      }\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  stopAnimation() {\n    if (this.currentAnimationAction != null) {\n      this.currentAnimationAction.stop();\n      this.currentAnimationAction.reset();\n      this.currentAnimationAction = null;\n    }\n\n    this.mixer.stopAllAction();\n  }\n\n  updateAnimation(step: number) {\n    this.mixer.update(step);\n  }\n\n  clear() {\n    this.url = null;\n    this.userData = {url: null};\n    const gltf = this[$currentGLTF];\n    // Remove all current children\n    if (gltf != null) {\n      moveChildren(this.modelContainer, gltf.scene);\n      gltf.dispose();\n      this[$currentGLTF] = null;\n    }\n\n    if (this.currentAnimationAction != null) {\n      this.currentAnimationAction.stop();\n      this.currentAnimationAction = null;\n    }\n\n    this.mixer.stopAllAction();\n    this.mixer.uncacheRoot(this);\n  }\n\n  /**\n   * Calculates the idealCameraDistance and fieldOfViewAspect that allows the 3D\n   * object to be framed tightly in a 2D window of any aspect ratio without\n   * clipping at any camera orbit. The camera's center target point can be\n   * optionally specified. If no center is specified, it defaults to the center\n   * of the bounding box, which means asymmetric models will tend to be tight on\n   * one side instead of both. Proper choice of center can correct this.\n   */\n  updateFraming(center: Vector3|null = null) {\n    this.remove(this.modelContainer);\n\n    if (center == null) {\n      this.boundingBox.setFromObject(this.modelContainer);\n      this.boundingBox.getSize(this.size);\n      center = this.boundingBox.getCenter(new Vector3);\n    }\n\n    const radiusSquared = (value: number, vertex: Vector3): number => {\n      return Math.max(value, center!.distanceToSquared(vertex));\n    };\n    const framedRadius =\n        Math.sqrt(reduceVertices(this.modelContainer, radiusSquared));\n\n    this.idealCameraDistance = framedRadius / SAFE_RADIUS_RATIO;\n\n    const horizontalFov = (value: number, vertex: Vector3): number => {\n      vertex.sub(center!);\n      const radiusXZ = Math.sqrt(vertex.x * vertex.x + vertex.z * vertex.z);\n      return Math.max(\n          value, radiusXZ / (this.idealCameraDistance - Math.abs(vertex.y)));\n    };\n    this.fieldOfViewAspect =\n        reduceVertices(this.modelContainer, horizontalFov) / DEFAULT_TAN_FOV;\n\n    this.add(this.modelContainer);\n  }\n\n  /**\n   * Sets the shadow's intensity, lazily creating the shadow as necessary.\n   */\n  setShadowIntensity(shadowIntensity: number, shadowSoftness: number) {\n    let shadow = this[$shadow];\n    if (shadow != null) {\n      shadow.setIntensity(shadowIntensity);\n      shadow.setModel(this, shadowSoftness);\n    } else if (shadowIntensity > 0) {\n      shadow = new Shadow(this, shadowSoftness);\n      shadow.setIntensity(shadowIntensity);\n      this[$shadow] = shadow;\n    }\n  }\n\n  /**\n   * Sets the shadow's softness by mapping a [0, 1] softness parameter to the\n   * shadow's resolution. This involves reallocation, so it should not be\n   * changed frequently. Softer shadows are cheaper to render.\n   */\n  setShadowSoftness(softness: number) {\n    const shadow = this[$shadow];\n    if (shadow != null) {\n      shadow.setSoftness(softness);\n    }\n  }\n\n  /**\n   * The shadow must be rotated manually to match any global rotation applied to\n   * this model. The input is the global orientation about the Y axis.\n   */\n  setShadowRotation(radiansY: number) {\n    const shadow = this[$shadow];\n    if (shadow != null) {\n      shadow.setRotation(radiansY);\n    }\n  }\n\n  /**\n   * Call when updating the shadow; returns true if an update is needed and\n   * resets the state.\n   */\n  updateShadow(): boolean {\n    const shadow = this[$shadow];\n    if (shadow == null) {\n      return false;\n    } else {\n      const {needsUpdate} = shadow;\n      shadow.needsUpdate = false;\n      return needsUpdate;\n    }\n  }\n\n  /**\n   * Shift the floor vertically from the bottom of the model's bounding box by\n   * offset (should generally be negative).\n   */\n  setShadowScaleAndOffset(scale: number, offset: number) {\n    const shadow = this[$shadow];\n    if (shadow != null) {\n      shadow.setScaleAndOffset(scale, offset);\n    }\n  }\n\n  /**\n   * The following methods are for operating on the set of Hotspot objects\n   * attached to the scene. These come from DOM elements, provided to slots by\n   * the Annotation Mixin.\n   */\n  addHotspot(hotspot: Hotspot) {\n    this.add(hotspot);\n  }\n\n  removeHotspot(hotspot: Hotspot) {\n    this.remove(hotspot);\n  }\n\n  /**\n   * Helper method to apply a function to all hotspots.\n   */\n  forHotspots(func: (hotspot: Hotspot) => void) {\n    const {children} = this;\n    for (let i = 0, l = children.length; i < l; i++) {\n      const hotspot = children[i];\n      if (hotspot instanceof Hotspot) {\n        func(hotspot);\n      }\n    }\n  }\n\n  /**\n   * Update the CSS visibility of the hotspots based on whether their normals\n   * point toward the camera.\n   */\n  updateHotspots(viewerPosition: Vector3) {\n    this.forHotspots((hotspot) => {\n      view.copy(viewerPosition);\n      target.setFromMatrixPosition(hotspot.matrixWorld);\n      view.sub(target);\n      normalWorld.copy(hotspot.normal).transformDirection(this.matrixWorld);\n      if (view.dot(normalWorld) < 0) {\n        hotspot.hide();\n      } else {\n        hotspot.show();\n      }\n    });\n  }\n\n  /**\n   * Rotate all hotspots to an absolute orientation given by the input number of\n   * radians. Zero returns them to upright.\n   */\n  orientHotspots(radians: number) {\n    this.forHotspots((hotspot) => {\n      hotspot.orient(radians);\n    });\n  }\n\n  /**\n   * Set the rendering visibility of all hotspots. This is used to hide them\n   * during transitions and such.\n   */\n  setHotspotsVisibility(visible: boolean) {\n    this.forHotspots((hotspot) => {\n      hotspot.visible = visible;\n    });\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}