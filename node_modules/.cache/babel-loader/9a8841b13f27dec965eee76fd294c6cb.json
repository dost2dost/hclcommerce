{"ast":null,"code":"var bind = require('../utils/bind');\n\nvar diff = require('../utils').diff;\n\nvar debug = require('../utils/debug');\n\nvar registerComponent = require('../core/component').registerComponent;\n\nvar THREE = require('../lib/three');\n\nvar degToRad = THREE.Math.degToRad;\nvar warn = debug('components:light:warn');\n/**\n * Light component.\n */\n\nmodule.exports.Component = registerComponent('light', {\n  schema: {\n    angle: {\n      default: 60,\n      if: {\n        type: ['spot']\n      }\n    },\n    color: {\n      type: 'color'\n    },\n    groundColor: {\n      type: 'color',\n      if: {\n        type: ['hemisphere']\n      }\n    },\n    decay: {\n      default: 1,\n      if: {\n        type: ['point', 'spot']\n      }\n    },\n    distance: {\n      default: 0.0,\n      min: 0,\n      if: {\n        type: ['point', 'spot']\n      }\n    },\n    intensity: {\n      default: 1.0,\n      min: 0,\n      if: {\n        type: ['ambient', 'directional', 'hemisphere', 'point', 'spot']\n      }\n    },\n    penumbra: {\n      default: 0,\n      min: 0,\n      max: 1,\n      if: {\n        type: ['spot']\n      }\n    },\n    type: {\n      default: 'directional',\n      oneOf: ['ambient', 'directional', 'hemisphere', 'point', 'spot'],\n      schemaChange: true\n    },\n    target: {\n      type: 'selector',\n      if: {\n        type: ['spot', 'directional']\n      }\n    },\n    // Shadows.\n    castShadow: {\n      default: false,\n      if: {\n        type: ['point', 'spot', 'directional']\n      }\n    },\n    shadowBias: {\n      default: 0,\n      if: {\n        castShadow: true\n      }\n    },\n    shadowCameraFar: {\n      default: 500,\n      if: {\n        castShadow: true\n      }\n    },\n    shadowCameraFov: {\n      default: 90,\n      if: {\n        castShadow: true\n      }\n    },\n    shadowCameraNear: {\n      default: 0.5,\n      if: {\n        castShadow: true\n      }\n    },\n    shadowCameraTop: {\n      default: 5,\n      if: {\n        castShadow: true\n      }\n    },\n    shadowCameraRight: {\n      default: 5,\n      if: {\n        castShadow: true\n      }\n    },\n    shadowCameraBottom: {\n      default: -5,\n      if: {\n        castShadow: true\n      }\n    },\n    shadowCameraLeft: {\n      default: -5,\n      if: {\n        castShadow: true\n      }\n    },\n    shadowCameraVisible: {\n      default: false,\n      if: {\n        castShadow: true\n      }\n    },\n    shadowMapHeight: {\n      default: 512,\n      if: {\n        castShadow: true\n      }\n    },\n    shadowMapWidth: {\n      default: 512,\n      if: {\n        castShadow: true\n      }\n    },\n    shadowRadius: {\n      default: 1,\n      if: {\n        castShadow: true\n      }\n    }\n  },\n\n  /**\n   * Notifies scene a light has been added to remove default lighting.\n   */\n  init: function () {\n    var el = this.el;\n    this.light = null;\n    this.defaultTarget = null;\n    this.rendererSystem = this.el.sceneEl.systems.renderer;\n    this.system.registerLight(el);\n  },\n\n  /**\n   * (Re)create or update light.\n   */\n  update: function (oldData) {\n    var data = this.data;\n    var diffData = diff(data, oldData);\n    var light = this.light;\n    var rendererSystem = this.rendererSystem;\n    var self = this; // Existing light.\n\n    if (light && !('type' in diffData)) {\n      var shadowsLoaded = false; // Light type has not changed. Update light.\n\n      Object.keys(diffData).forEach(function (key) {\n        var value = data[key];\n\n        switch (key) {\n          case 'color':\n            {\n              light.color.set(value);\n              rendererSystem.applyColorCorrection(light.color);\n              break;\n            }\n\n          case 'groundColor':\n            {\n              light.groundColor.set(value);\n              rendererSystem.applyColorCorrection(light.groundColor);\n              break;\n            }\n\n          case 'angle':\n            {\n              light.angle = degToRad(value);\n              break;\n            }\n\n          case 'target':\n            {\n              // Reset target if selector is null.\n              if (value === null) {\n                if (data.type === 'spot' || data.type === 'directional') {\n                  light.target = self.defaultTarget;\n                }\n              } else {\n                // Target specified, set target to entity's `object3D` when it is loaded.\n                if (value.hasLoaded) {\n                  self.onSetTarget(value, light);\n                } else {\n                  value.addEventListener('loaded', bind(self.onSetTarget, self, value, light));\n                }\n              }\n\n              break;\n            }\n\n          case 'castShadow':\n          case 'shadowBias':\n          case 'shadowCameraFar':\n          case 'shadowCameraFov':\n          case 'shadowCameraNear':\n          case 'shadowCameraTop':\n          case 'shadowCameraRight':\n          case 'shadowCameraBottom':\n          case 'shadowCameraLeft':\n          case 'shadowCameraVisible':\n          case 'shadowMapHeight':\n          case 'shadowMapWidth':\n          case 'shadowRadius':\n            if (!shadowsLoaded) {\n              self.updateShadow();\n              shadowsLoaded = true;\n            }\n\n            break;\n\n          default:\n            {\n              light[key] = value;\n            }\n        }\n      });\n      return;\n    } // No light yet or light type has changed. Create and add light.\n\n\n    this.setLight(this.data);\n    this.updateShadow();\n  },\n  setLight: function (data) {\n    var el = this.el;\n    var newLight = this.getLight(data);\n\n    if (newLight) {\n      if (this.light) {\n        el.removeObject3D('light');\n      }\n\n      this.light = newLight;\n      this.light.el = el;\n      el.setObject3D('light', this.light); // HACK solution for issue #1624\n\n      if (data.type === 'spot' || data.type === 'directional' || data.type === 'hemisphere') {\n        el.getObject3D('light').translateY(-1);\n      } // set and position default lighttarget as a child to enable spotlight orientation\n\n\n      if (data.type === 'spot') {\n        el.setObject3D('light-target', this.defaultTarget);\n        el.getObject3D('light-target').position.set(0, 0, -1);\n      }\n    }\n  },\n\n  /**\n   * Updates shadow-related properties on the current light.\n   */\n  updateShadow: function () {\n    var el = this.el;\n    var data = this.data;\n    var light = this.light;\n    light.castShadow = data.castShadow; // Shadow camera helper.\n\n    var cameraHelper = el.getObject3D('cameraHelper');\n\n    if (data.shadowCameraVisible && !cameraHelper) {\n      el.setObject3D('cameraHelper', new THREE.CameraHelper(light.shadow.camera));\n    } else if (!data.shadowCameraVisible && cameraHelper) {\n      el.removeObject3D('cameraHelper');\n    }\n\n    if (!data.castShadow) {\n      return light;\n    } // Shadow appearance.\n\n\n    light.shadow.bias = data.shadowBias;\n    light.shadow.radius = data.shadowRadius;\n    light.shadow.mapSize.height = data.shadowMapHeight;\n    light.shadow.mapSize.width = data.shadowMapWidth; // Shadow camera.\n\n    light.shadow.camera.near = data.shadowCameraNear;\n    light.shadow.camera.far = data.shadowCameraFar;\n\n    if (light.shadow.camera instanceof THREE.OrthographicCamera) {\n      light.shadow.camera.top = data.shadowCameraTop;\n      light.shadow.camera.right = data.shadowCameraRight;\n      light.shadow.camera.bottom = data.shadowCameraBottom;\n      light.shadow.camera.left = data.shadowCameraLeft;\n    } else {\n      light.shadow.camera.fov = data.shadowCameraFov;\n    }\n\n    light.shadow.camera.updateProjectionMatrix();\n\n    if (cameraHelper) {\n      cameraHelper.update();\n    }\n  },\n\n  /**\n   * Creates a new three.js light object given data object defining the light.\n   *\n   * @param {object} data\n   */\n  getLight: function (data) {\n    var angle = data.angle;\n    var color = new THREE.Color(data.color);\n    this.rendererSystem.applyColorCorrection(color);\n    color = color.getHex();\n    var decay = data.decay;\n    var distance = data.distance;\n    var groundColor = new THREE.Color(data.groundColor);\n    this.rendererSystem.applyColorCorrection(groundColor);\n    groundColor = groundColor.getHex();\n    var intensity = data.intensity;\n    var type = data.type;\n    var target = data.target;\n    var light = null;\n\n    switch (type.toLowerCase()) {\n      case 'ambient':\n        {\n          return new THREE.AmbientLight(color, intensity);\n        }\n\n      case 'directional':\n        {\n          light = new THREE.DirectionalLight(color, intensity);\n          this.defaultTarget = light.target;\n\n          if (target) {\n            if (target.hasLoaded) {\n              this.onSetTarget(target, light);\n            } else {\n              target.addEventListener('loaded', bind(this.onSetTarget, this, target, light));\n            }\n          }\n\n          return light;\n        }\n\n      case 'hemisphere':\n        {\n          return new THREE.HemisphereLight(color, groundColor, intensity);\n        }\n\n      case 'point':\n        {\n          return new THREE.PointLight(color, intensity, distance, decay);\n        }\n\n      case 'spot':\n        {\n          light = new THREE.SpotLight(color, intensity, distance, degToRad(angle), data.penumbra, decay);\n          this.defaultTarget = light.target;\n\n          if (target) {\n            if (target.hasLoaded) {\n              this.onSetTarget(target, light);\n            } else {\n              target.addEventListener('loaded', bind(this.onSetTarget, this, target, light));\n            }\n          }\n\n          return light;\n        }\n\n      default:\n        {\n          warn('%s is not a valid light type. ' + 'Choose from ambient, directional, hemisphere, point, spot.', type);\n        }\n    }\n  },\n  onSetTarget: function (targetEl, light) {\n    light.target = targetEl.object3D;\n  },\n\n  /**\n   * Remove light on remove (callback).\n   */\n  remove: function () {\n    var el = this.el;\n    el.removeObject3D('light');\n\n    if (el.getObject3D('cameraHelper')) {\n      el.removeObject3D('cameraHelper');\n    }\n  }\n});","map":{"version":3,"sources":["C:/Users/Hannuri/Desktop/RoyalCyber/my-first-app/node_modules/aframe/src/components/light.js"],"names":["bind","require","diff","debug","registerComponent","THREE","degToRad","Math","warn","module","exports","Component","schema","angle","default","if","type","color","groundColor","decay","distance","min","intensity","penumbra","max","oneOf","schemaChange","target","castShadow","shadowBias","shadowCameraFar","shadowCameraFov","shadowCameraNear","shadowCameraTop","shadowCameraRight","shadowCameraBottom","shadowCameraLeft","shadowCameraVisible","shadowMapHeight","shadowMapWidth","shadowRadius","init","el","light","defaultTarget","rendererSystem","sceneEl","systems","renderer","system","registerLight","update","oldData","data","diffData","self","shadowsLoaded","Object","keys","forEach","key","value","set","applyColorCorrection","hasLoaded","onSetTarget","addEventListener","updateShadow","setLight","newLight","getLight","removeObject3D","setObject3D","getObject3D","translateY","position","cameraHelper","CameraHelper","shadow","camera","bias","radius","mapSize","height","width","near","far","OrthographicCamera","top","right","bottom","left","fov","updateProjectionMatrix","Color","getHex","toLowerCase","AmbientLight","DirectionalLight","HemisphereLight","PointLight","SpotLight","targetEl","object3D","remove"],"mappings":"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","sourcesContent":["var bind = require('../utils/bind');\nvar diff = require('../utils').diff;\nvar debug = require('../utils/debug');\nvar registerComponent = require('../core/component').registerComponent;\nvar THREE = require('../lib/three');\n\nvar degToRad = THREE.Math.degToRad;\nvar warn = debug('components:light:warn');\n\n/**\n * Light component.\n */\nmodule.exports.Component = registerComponent('light', {\n  schema: {\n    angle: {default: 60, if: {type: ['spot']}},\n    color: {type: 'color'},\n    groundColor: {type: 'color', if: {type: ['hemisphere']}},\n    decay: {default: 1, if: {type: ['point', 'spot']}},\n    distance: {default: 0.0, min: 0, if: {type: ['point', 'spot']}},\n    intensity: {default: 1.0, min: 0, if: {type: ['ambient', 'directional', 'hemisphere', 'point', 'spot']}},\n    penumbra: {default: 0, min: 0, max: 1, if: {type: ['spot']}},\n    type: {\n      default: 'directional',\n      oneOf: ['ambient', 'directional', 'hemisphere', 'point', 'spot'],\n      schemaChange: true\n    },\n    target: {type: 'selector', if: {type: ['spot', 'directional']}},\n\n    // Shadows.\n    castShadow: {default: false, if: {type: ['point', 'spot', 'directional']}},\n    shadowBias: {default: 0, if: {castShadow: true}},\n    shadowCameraFar: {default: 500, if: {castShadow: true}},\n    shadowCameraFov: {default: 90, if: {castShadow: true}},\n    shadowCameraNear: {default: 0.5, if: {castShadow: true}},\n    shadowCameraTop: {default: 5, if: {castShadow: true}},\n    shadowCameraRight: {default: 5, if: {castShadow: true}},\n    shadowCameraBottom: {default: -5, if: {castShadow: true}},\n    shadowCameraLeft: {default: -5, if: {castShadow: true}},\n    shadowCameraVisible: {default: false, if: {castShadow: true}},\n    shadowMapHeight: {default: 512, if: {castShadow: true}},\n    shadowMapWidth: {default: 512, if: {castShadow: true}},\n    shadowRadius: {default: 1, if: {castShadow: true}}\n  },\n\n  /**\n   * Notifies scene a light has been added to remove default lighting.\n   */\n  init: function () {\n    var el = this.el;\n    this.light = null;\n    this.defaultTarget = null;\n    this.rendererSystem = this.el.sceneEl.systems.renderer;\n    this.system.registerLight(el);\n  },\n\n  /**\n   * (Re)create or update light.\n   */\n  update: function (oldData) {\n    var data = this.data;\n    var diffData = diff(data, oldData);\n    var light = this.light;\n    var rendererSystem = this.rendererSystem;\n    var self = this;\n\n    // Existing light.\n    if (light && !('type' in diffData)) {\n      var shadowsLoaded = false;\n      // Light type has not changed. Update light.\n      Object.keys(diffData).forEach(function (key) {\n        var value = data[key];\n\n        switch (key) {\n          case 'color': {\n            light.color.set(value);\n            rendererSystem.applyColorCorrection(light.color);\n            break;\n          }\n\n          case 'groundColor': {\n            light.groundColor.set(value);\n            rendererSystem.applyColorCorrection(light.groundColor);\n            break;\n          }\n\n          case 'angle': {\n            light.angle = degToRad(value);\n            break;\n          }\n\n          case 'target': {\n            // Reset target if selector is null.\n            if (value === null) {\n              if (data.type === 'spot' || data.type === 'directional') {\n                light.target = self.defaultTarget;\n              }\n            } else {\n              // Target specified, set target to entity's `object3D` when it is loaded.\n              if (value.hasLoaded) {\n                self.onSetTarget(value, light);\n              } else {\n                value.addEventListener('loaded', bind(self.onSetTarget, self, value, light));\n              }\n            }\n            break;\n          }\n\n          case 'castShadow':\n          case 'shadowBias':\n          case 'shadowCameraFar':\n          case 'shadowCameraFov':\n          case 'shadowCameraNear':\n          case 'shadowCameraTop':\n          case 'shadowCameraRight':\n          case 'shadowCameraBottom':\n          case 'shadowCameraLeft':\n          case 'shadowCameraVisible':\n          case 'shadowMapHeight':\n          case 'shadowMapWidth':\n          case 'shadowRadius':\n            if (!shadowsLoaded) {\n              self.updateShadow();\n              shadowsLoaded = true;\n            }\n            break;\n\n          default: {\n            light[key] = value;\n          }\n        }\n      });\n      return;\n    }\n\n    // No light yet or light type has changed. Create and add light.\n    this.setLight(this.data);\n    this.updateShadow();\n  },\n\n  setLight: function (data) {\n    var el = this.el;\n    var newLight = this.getLight(data);\n    if (newLight) {\n      if (this.light) {\n        el.removeObject3D('light');\n      }\n\n      this.light = newLight;\n      this.light.el = el;\n      el.setObject3D('light', this.light);\n\n      // HACK solution for issue #1624\n      if (data.type === 'spot' || data.type === 'directional' || data.type === 'hemisphere') {\n        el.getObject3D('light').translateY(-1);\n      }\n\n      // set and position default lighttarget as a child to enable spotlight orientation\n      if (data.type === 'spot') {\n        el.setObject3D('light-target', this.defaultTarget);\n        el.getObject3D('light-target').position.set(0, 0, -1);\n      }\n    }\n  },\n\n  /**\n   * Updates shadow-related properties on the current light.\n   */\n  updateShadow: function () {\n    var el = this.el;\n    var data = this.data;\n    var light = this.light;\n\n    light.castShadow = data.castShadow;\n\n    // Shadow camera helper.\n    var cameraHelper = el.getObject3D('cameraHelper');\n    if (data.shadowCameraVisible && !cameraHelper) {\n      el.setObject3D('cameraHelper', new THREE.CameraHelper(light.shadow.camera));\n    } else if (!data.shadowCameraVisible && cameraHelper) {\n      el.removeObject3D('cameraHelper');\n    }\n\n    if (!data.castShadow) { return light; }\n\n    // Shadow appearance.\n    light.shadow.bias = data.shadowBias;\n    light.shadow.radius = data.shadowRadius;\n    light.shadow.mapSize.height = data.shadowMapHeight;\n    light.shadow.mapSize.width = data.shadowMapWidth;\n\n    // Shadow camera.\n    light.shadow.camera.near = data.shadowCameraNear;\n    light.shadow.camera.far = data.shadowCameraFar;\n    if (light.shadow.camera instanceof THREE.OrthographicCamera) {\n      light.shadow.camera.top = data.shadowCameraTop;\n      light.shadow.camera.right = data.shadowCameraRight;\n      light.shadow.camera.bottom = data.shadowCameraBottom;\n      light.shadow.camera.left = data.shadowCameraLeft;\n    } else {\n      light.shadow.camera.fov = data.shadowCameraFov;\n    }\n    light.shadow.camera.updateProjectionMatrix();\n\n    if (cameraHelper) { cameraHelper.update(); }\n  },\n\n  /**\n   * Creates a new three.js light object given data object defining the light.\n   *\n   * @param {object} data\n   */\n  getLight: function (data) {\n    var angle = data.angle;\n    var color = new THREE.Color(data.color);\n    this.rendererSystem.applyColorCorrection(color);\n    color = color.getHex();\n    var decay = data.decay;\n    var distance = data.distance;\n    var groundColor = new THREE.Color(data.groundColor);\n    this.rendererSystem.applyColorCorrection(groundColor);\n    groundColor = groundColor.getHex();\n    var intensity = data.intensity;\n    var type = data.type;\n    var target = data.target;\n    var light = null;\n\n    switch (type.toLowerCase()) {\n      case 'ambient': {\n        return new THREE.AmbientLight(color, intensity);\n      }\n\n      case 'directional': {\n        light = new THREE.DirectionalLight(color, intensity);\n        this.defaultTarget = light.target;\n        if (target) {\n          if (target.hasLoaded) {\n            this.onSetTarget(target, light);\n          } else {\n            target.addEventListener('loaded', bind(this.onSetTarget, this, target, light));\n          }\n        }\n        return light;\n      }\n\n      case 'hemisphere': {\n        return new THREE.HemisphereLight(color, groundColor, intensity);\n      }\n\n      case 'point': {\n        return new THREE.PointLight(color, intensity, distance, decay);\n      }\n\n      case 'spot': {\n        light = new THREE.SpotLight(color, intensity, distance, degToRad(angle), data.penumbra, decay);\n        this.defaultTarget = light.target;\n        if (target) {\n          if (target.hasLoaded) {\n            this.onSetTarget(target, light);\n          } else {\n            target.addEventListener('loaded', bind(this.onSetTarget, this, target, light));\n          }\n        }\n        return light;\n      }\n\n      default: {\n        warn('%s is not a valid light type. ' +\n           'Choose from ambient, directional, hemisphere, point, spot.', type);\n      }\n    }\n  },\n\n  onSetTarget: function (targetEl, light) {\n    light.target = targetEl.object3D;\n  },\n\n  /**\n   * Remove light on remove (callback).\n   */\n  remove: function () {\n    var el = this.el;\n    el.removeObject3D('light');\n    if (el.getObject3D('cameraHelper')) {\n      el.removeObject3D('cameraHelper');\n    }\n  }\n});\n"]},"metadata":{},"sourceType":"script"}