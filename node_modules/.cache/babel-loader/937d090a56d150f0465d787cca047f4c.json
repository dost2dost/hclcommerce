{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b;\n\nconst $retainerCount = Symbol('retainerCount');\nconst $recentlyUsed = Symbol('recentlyUsed');\nconst $evict = Symbol('evict');\nconst $evictionThreshold = Symbol('evictionThreshold');\nconst $cache = Symbol('cache');\n/**\n * The CacheEvictionPolicy manages the lifecycle for items in a cache,\n * evicting any items outside some threshold bounds in \"recently used\" order,\n * if they are evictable.\n *\n * Items are considered cached as they are retained. When all retainers\n * of an item release it, that item is considered evictable.\n */\n\nexport class CacheEvictionPolicy {\n  constructor(cache, evictionThreshold = 5) {\n    this[_a] = new Map();\n    this[_b] = [];\n    this[$cache] = cache;\n    this[$evictionThreshold] = evictionThreshold;\n  }\n  /**\n   * The eviction threshold is the maximum number of items to hold\n   * in cache indefinitely. Items within the threshold (in recently\n   * used order) will continue to be cached even if they have zero\n   * retainers.\n   */\n\n\n  set evictionThreshold(value) {\n    this[$evictionThreshold] = value;\n    this[$evict]();\n  }\n\n  get evictionThreshold() {\n    return this[$evictionThreshold];\n  }\n  /**\n   * A reference to the cache that operates under this policy\n   */\n\n\n  get cache() {\n    return this[$cache];\n  }\n  /**\n   * Given an item key, returns the number of retainers of that item\n   */\n\n\n  retainerCount(key) {\n    return this[$retainerCount].get(key) || 0;\n  }\n  /**\n   * Resets the internal tracking of cache item retainers. Use only in cases\n   * where it is certain that all retained cache items have been accounted for!\n   */\n\n\n  reset() {\n    this[$retainerCount].clear();\n    this[$recentlyUsed] = [];\n  }\n  /**\n   * Mark a given cache item as retained, where the item is represented\n   * by its key. An item can have any number of retainers.\n   */\n\n\n  retain(key) {\n    if (!this[$retainerCount].has(key)) {\n      this[$retainerCount].set(key, 0);\n    }\n\n    this[$retainerCount].set(key, this[$retainerCount].get(key) + 1);\n    const recentlyUsedIndex = this[$recentlyUsed].indexOf(key);\n\n    if (recentlyUsedIndex !== -1) {\n      this[$recentlyUsed].splice(recentlyUsedIndex, 1);\n    }\n\n    this[$recentlyUsed].unshift(key); // Evict, in case retaining a new item pushed an evictable item beyond the\n    // eviction threshold\n\n    this[$evict]();\n  }\n  /**\n   * Mark a given cache item as released by one of its retainers, where the item\n   * is represented by its key. When all retainers of an item have released it,\n   * the item is considered evictable.\n   */\n\n\n  release(key) {\n    if (this[$retainerCount].has(key)) {\n      this[$retainerCount].set(key, Math.max(this[$retainerCount].get(key) - 1, 0));\n    }\n\n    this[$evict]();\n  }\n\n  [(_a = $retainerCount, _b = $recentlyUsed, $evict)]() {\n    if (this[$recentlyUsed].length < this[$evictionThreshold]) {\n      return;\n    }\n\n    for (let i = this[$recentlyUsed].length - 1; i >= this[$evictionThreshold]; --i) {\n      const key = this[$recentlyUsed][i];\n      const retainerCount = this[$retainerCount].get(key);\n\n      if (retainerCount === 0) {\n        this[$cache].delete(key);\n        this[$recentlyUsed].splice(i, 1);\n      }\n    }\n  }\n\n}","map":{"version":3,"sources":["../../src/utilities/cache-eviction-policy.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A mutable cache is any object that has that allows cache\n * items to be deleted imperatively given their key\n */\nexport interface MutableCache<T> {\n  delete(key: T): void;\n}\n\nconst $retainerCount = Symbol('retainerCount');\nconst $recentlyUsed = Symbol('recentlyUsed');\nconst $evict = Symbol('evict');\nconst $evictionThreshold = Symbol('evictionThreshold');\nconst $cache = Symbol('cache');\n\n/**\n * The CacheEvictionPolicy manages the lifecycle for items in a cache,\n * evicting any items outside some threshold bounds in \"recently used\" order,\n * if they are evictable.\n *\n * Items are considered cached as they are retained. When all retainers\n * of an item release it, that item is considered evictable.\n */\nexport class CacheEvictionPolicy<T = string> {\n  private[$retainerCount] = new Map<T, number>();\n  private[$recentlyUsed]: Array<T> = [];\n  private[$evictionThreshold]: number;\n  private[$cache]: MutableCache<T>;\n\n  constructor(cache: MutableCache<T>, evictionThreshold: number = 5) {\n    this[$cache] = cache;\n    this[$evictionThreshold] = evictionThreshold;\n  }\n\n  /**\n   * The eviction threshold is the maximum number of items to hold\n   * in cache indefinitely. Items within the threshold (in recently\n   * used order) will continue to be cached even if they have zero\n   * retainers.\n   */\n  set evictionThreshold(value: number) {\n    this[$evictionThreshold] = value;\n    this[$evict]();\n  }\n\n  get evictionThreshold(): number {\n    return this[$evictionThreshold];\n  }\n\n  /**\n   * A reference to the cache that operates under this policy\n   */\n  get cache(): MutableCache<T> {\n    return this[$cache];\n  }\n\n  /**\n   * Given an item key, returns the number of retainers of that item\n   */\n  retainerCount(key: T): number {\n    return this[$retainerCount].get(key) || 0;\n  }\n\n  /**\n   * Resets the internal tracking of cache item retainers. Use only in cases\n   * where it is certain that all retained cache items have been accounted for!\n   */\n  reset() {\n    this[$retainerCount].clear();\n    this[$recentlyUsed] = [];\n  }\n\n  /**\n   * Mark a given cache item as retained, where the item is represented\n   * by its key. An item can have any number of retainers.\n   */\n  retain(key: T) {\n    if (!this[$retainerCount].has(key)) {\n      this[$retainerCount].set(key, 0);\n    }\n    this[$retainerCount].set(key, this[$retainerCount].get(key)! + 1);\n\n    const recentlyUsedIndex = this[$recentlyUsed].indexOf(key);\n\n    if (recentlyUsedIndex !== -1) {\n      this[$recentlyUsed].splice(recentlyUsedIndex, 1);\n    }\n\n    this[$recentlyUsed].unshift(key);\n    // Evict, in case retaining a new item pushed an evictable item beyond the\n    // eviction threshold\n    this[$evict]();\n  }\n\n  /**\n   * Mark a given cache item as released by one of its retainers, where the item\n   * is represented by its key. When all retainers of an item have released it,\n   * the item is considered evictable.\n   */\n  release(key: T) {\n    if (this[$retainerCount].has(key)) {\n      this[$retainerCount].set(\n          key, Math.max(this[$retainerCount].get(key)! - 1, 0));\n    }\n\n    this[$evict]();\n  }\n\n  [$evict]() {\n    if (this[$recentlyUsed].length < this[$evictionThreshold]) {\n      return;\n    }\n\n    for (let i = this[$recentlyUsed].length - 1; i >= this[$evictionThreshold];\n         --i) {\n      const key = this[$recentlyUsed][i];\n      const retainerCount = this[$retainerCount].get(key);\n\n      if (retainerCount === 0) {\n        this[$cache].delete(key);\n        this[$recentlyUsed].splice(i, 1);\n      }\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}