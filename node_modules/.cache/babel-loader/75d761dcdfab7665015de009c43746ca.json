{"ast":null,"code":"/* global Promise */\nvar utils = require('../utils/');\n\nvar component = require('../core/component');\n\nvar THREE = require('../lib/three');\n\nvar shader = require('../core/shader');\n\nvar error = utils.debug('components:material:error');\nvar registerComponent = component.registerComponent;\nvar shaders = shader.shaders;\nvar shaderNames = shader.shaderNames;\n/**\n * Material component.\n *\n * @member {object} shader - Determines how material is shaded. Defaults to `standard`,\n *         three.js's implementation of PBR. Another standard shading model is `flat` which\n *         uses MeshBasicMaterial.\n */\n\nmodule.exports.Component = registerComponent('material', {\n  schema: {\n    alphaTest: {\n      default: 0.0,\n      min: 0.0,\n      max: 1.0\n    },\n    depthTest: {\n      default: true\n    },\n    depthWrite: {\n      default: true\n    },\n    flatShading: {\n      default: false\n    },\n    npot: {\n      default: false\n    },\n    offset: {\n      type: 'vec2',\n      default: {\n        x: 0,\n        y: 0\n      }\n    },\n    opacity: {\n      default: 1.0,\n      min: 0.0,\n      max: 1.0\n    },\n    repeat: {\n      type: 'vec2',\n      default: {\n        x: 1,\n        y: 1\n      }\n    },\n    shader: {\n      default: 'standard',\n      oneOf: shaderNames,\n      schemaChange: true\n    },\n    side: {\n      default: 'front',\n      oneOf: ['front', 'back', 'double']\n    },\n    transparent: {\n      default: false\n    },\n    vertexColors: {\n      type: 'string',\n      default: 'none',\n      oneOf: ['face', 'vertex']\n    },\n    visible: {\n      default: true\n    },\n    blending: {\n      default: 'normal',\n      oneOf: ['none', 'normal', 'additive', 'subtractive', 'multiply']\n    }\n  },\n  init: function () {\n    this.material = null;\n  },\n\n  /**\n   * Update or create material.\n   *\n   * @param {object|null} oldData\n   */\n  update: function (oldData) {\n    var data = this.data;\n\n    if (!this.shader || data.shader !== oldData.shader) {\n      this.updateShader(data.shader);\n    }\n\n    this.shader.update(this.data);\n    this.updateMaterial(oldData);\n  },\n  updateSchema: function (data) {\n    var currentShader;\n    var newShader;\n    var schema;\n    var shader;\n    newShader = data && data.shader;\n    currentShader = this.oldData && this.oldData.shader;\n    shader = newShader || currentShader;\n    schema = shaders[shader] && shaders[shader].schema;\n\n    if (!schema) {\n      error('Unknown shader schema ' + shader);\n    }\n\n    if (currentShader && newShader === currentShader) {\n      return;\n    }\n\n    this.extendSchema(schema);\n    this.updateBehavior();\n  },\n  updateBehavior: function () {\n    var key;\n    var sceneEl = this.el.sceneEl;\n    var schema = this.schema;\n    var self = this;\n    var tickProperties;\n\n    function tickTime(time, delta) {\n      var key;\n\n      for (key in tickProperties) {\n        tickProperties[key] = time;\n      }\n\n      self.shader.update(tickProperties);\n    }\n\n    this.tick = undefined;\n    tickProperties = {};\n\n    for (key in schema) {\n      if (schema[key].type === 'time') {\n        this.tick = tickTime;\n        tickProperties[key] = true;\n      }\n    }\n\n    if (!sceneEl) {\n      return;\n    }\n\n    if (this.tick) {\n      sceneEl.addBehavior(this);\n    } else {\n      sceneEl.removeBehavior(this);\n    }\n  },\n  updateShader: function (shaderName) {\n    var data = this.data;\n    var Shader = shaders[shaderName] && shaders[shaderName].Shader;\n    var shaderInstance;\n\n    if (!Shader) {\n      throw new Error('Unknown shader ' + shaderName);\n    } // Get material from A-Frame shader.\n\n\n    shaderInstance = this.shader = new Shader();\n    shaderInstance.el = this.el;\n    shaderInstance.init(data);\n    this.setMaterial(shaderInstance.material);\n    this.updateSchema(data);\n  },\n\n  /**\n   * Set and update base material properties.\n   * Set `needsUpdate` when needed.\n   */\n  updateMaterial: function (oldData) {\n    var data = this.data;\n    var material = this.material;\n    var oldDataHasKeys; // Base material properties.\n\n    material.alphaTest = data.alphaTest;\n    material.depthTest = data.depthTest !== false;\n    material.depthWrite = data.depthWrite !== false;\n    material.opacity = data.opacity;\n    material.flatShading = data.flatShading;\n    material.side = parseSide(data.side);\n    material.transparent = data.transparent !== false || data.opacity < 1.0;\n    material.vertexColors = parseVertexColors(data.vertexColors);\n    material.visible = data.visible;\n    material.blending = parseBlending(data.blending); // Check if material needs update.\n\n    for (oldDataHasKeys in oldData) {\n      break;\n    }\n\n    if (oldDataHasKeys && (oldData.alphaTest !== data.alphaTest || oldData.side !== data.side || oldData.vertexColors !== data.vertexColors)) {\n      material.needsUpdate = true;\n    }\n  },\n\n  /**\n   * Remove material on remove (callback).\n   * Dispose of it from memory and unsubscribe from scene updates.\n   */\n  remove: function () {\n    var defaultMaterial = new THREE.MeshBasicMaterial();\n    var material = this.material;\n    var object3D = this.el.getObject3D('mesh');\n\n    if (object3D) {\n      object3D.material = defaultMaterial;\n    }\n\n    disposeMaterial(material, this.system);\n  },\n\n  /**\n   * (Re)create new material. Has side-effects of setting `this.material` and updating\n   * material registration in scene.\n   *\n   * @param {object} data - Material component data.\n   * @param {object} type - Material type to create.\n   * @returns {object} Material.\n   */\n  setMaterial: function (material) {\n    var el = this.el;\n    var mesh;\n    var system = this.system;\n\n    if (this.material) {\n      disposeMaterial(this.material, system);\n    }\n\n    this.material = material;\n    system.registerMaterial(material); // Set on mesh. If mesh does not exist, wait for it.\n\n    mesh = el.getObject3D('mesh');\n\n    if (mesh) {\n      mesh.material = material;\n    } else {\n      el.addEventListener('object3dset', function waitForMesh(evt) {\n        if (evt.detail.type !== 'mesh' || evt.target !== el) {\n          return;\n        }\n\n        el.getObject3D('mesh').material = material;\n        el.removeEventListener('object3dset', waitForMesh);\n      });\n    }\n  }\n});\n/**\n * Return a three.js constant determining which material face sides to render\n * based on the side parameter (passed as a component property).\n *\n * @param {string} [side=front] - `front`, `back`, or `double`.\n * @returns {number} THREE.FrontSide, THREE.BackSide, or THREE.DoubleSide.\n */\n\nfunction parseSide(side) {\n  switch (side) {\n    case 'back':\n      {\n        return THREE.BackSide;\n      }\n\n    case 'double':\n      {\n        return THREE.DoubleSide;\n      }\n\n    default:\n      {\n        // Including case `front`.\n        return THREE.FrontSide;\n      }\n  }\n}\n/**\n * Return a three.js constant determining vertex coloring.\n */\n\n\nfunction parseVertexColors(coloring) {\n  switch (coloring) {\n    case 'face':\n      {\n        return THREE.FaceColors;\n      }\n\n    case 'vertex':\n      {\n        return THREE.VertexColors;\n      }\n\n    default:\n      {\n        return THREE.NoColors;\n      }\n  }\n}\n/**\n * Return a three.js constant determining blending\n *\n * @param {string} [blending=normal]\n * - `none`, additive`, `subtractive`,`multiply` or `normal`.\n * @returns {number}\n */\n\n\nfunction parseBlending(blending) {\n  switch (blending) {\n    case 'none':\n      {\n        return THREE.NoBlending;\n      }\n\n    case 'additive':\n      {\n        return THREE.AdditiveBlending;\n      }\n\n    case 'subtractive':\n      {\n        return THREE.SubtractiveBlending;\n      }\n\n    case 'multiply':\n      {\n        return THREE.MultiplyBlending;\n      }\n\n    default:\n      {\n        return THREE.NormalBlending;\n      }\n  }\n}\n/**\n * Dispose of material from memory and unsubscribe material from scene updates like fog.\n */\n\n\nfunction disposeMaterial(material, system) {\n  material.dispose();\n  system.unregisterMaterial(material);\n}","map":{"version":3,"sources":["C:/Users/Hannuri/Desktop/RoyalCyber/my-first-app/node_modules/aframe/src/components/material.js"],"names":["utils","require","component","THREE","shader","error","debug","registerComponent","shaders","shaderNames","module","exports","Component","schema","alphaTest","default","min","max","depthTest","depthWrite","flatShading","npot","offset","type","x","y","opacity","repeat","oneOf","schemaChange","side","transparent","vertexColors","visible","blending","init","material","update","oldData","data","updateShader","updateMaterial","updateSchema","currentShader","newShader","extendSchema","updateBehavior","key","sceneEl","el","self","tickProperties","tickTime","time","delta","tick","undefined","addBehavior","removeBehavior","shaderName","Shader","shaderInstance","Error","setMaterial","oldDataHasKeys","parseSide","parseVertexColors","parseBlending","needsUpdate","remove","defaultMaterial","MeshBasicMaterial","object3D","getObject3D","disposeMaterial","system","mesh","registerMaterial","addEventListener","waitForMesh","evt","detail","target","removeEventListener","BackSide","DoubleSide","FrontSide","coloring","FaceColors","VertexColors","NoColors","NoBlending","AdditiveBlending","SubtractiveBlending","MultiplyBlending","NormalBlending","dispose","unregisterMaterial"],"mappings":"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","sourcesContent":["/* global Promise */\nvar utils = require('../utils/');\nvar component = require('../core/component');\nvar THREE = require('../lib/three');\nvar shader = require('../core/shader');\n\nvar error = utils.debug('components:material:error');\nvar registerComponent = component.registerComponent;\nvar shaders = shader.shaders;\nvar shaderNames = shader.shaderNames;\n\n/**\n * Material component.\n *\n * @member {object} shader - Determines how material is shaded. Defaults to `standard`,\n *         three.js's implementation of PBR. Another standard shading model is `flat` which\n *         uses MeshBasicMaterial.\n */\nmodule.exports.Component = registerComponent('material', {\n  schema: {\n    alphaTest: {default: 0.0, min: 0.0, max: 1.0},\n    depthTest: {default: true},\n    depthWrite: {default: true},\n    flatShading: {default: false},\n    npot: {default: false},\n    offset: {type: 'vec2', default: {x: 0, y: 0}},\n    opacity: {default: 1.0, min: 0.0, max: 1.0},\n    repeat: {type: 'vec2', default: {x: 1, y: 1}},\n    shader: {default: 'standard', oneOf: shaderNames, schemaChange: true},\n    side: {default: 'front', oneOf: ['front', 'back', 'double']},\n    transparent: {default: false},\n    vertexColors: {type: 'string', default: 'none', oneOf: ['face', 'vertex']},\n    visible: {default: true},\n    blending: {default: 'normal', oneOf: ['none', 'normal', 'additive', 'subtractive', 'multiply']}\n  },\n\n  init: function () {\n    this.material = null;\n  },\n\n  /**\n   * Update or create material.\n   *\n   * @param {object|null} oldData\n   */\n  update: function (oldData) {\n    var data = this.data;\n    if (!this.shader || data.shader !== oldData.shader) {\n      this.updateShader(data.shader);\n    }\n    this.shader.update(this.data);\n    this.updateMaterial(oldData);\n  },\n\n  updateSchema: function (data) {\n    var currentShader;\n    var newShader;\n    var schema;\n    var shader;\n\n    newShader = data && data.shader;\n    currentShader = this.oldData && this.oldData.shader;\n    shader = newShader || currentShader;\n    schema = shaders[shader] && shaders[shader].schema;\n\n    if (!schema) { error('Unknown shader schema ' + shader); }\n    if (currentShader && newShader === currentShader) { return; }\n    this.extendSchema(schema);\n    this.updateBehavior();\n  },\n\n  updateBehavior: function () {\n    var key;\n    var sceneEl = this.el.sceneEl;\n    var schema = this.schema;\n    var self = this;\n    var tickProperties;\n\n    function tickTime (time, delta) {\n      var key;\n      for (key in tickProperties) {\n        tickProperties[key] = time;\n      }\n      self.shader.update(tickProperties);\n    }\n\n    this.tick = undefined;\n\n    tickProperties = {};\n    for (key in schema) {\n      if (schema[key].type === 'time') {\n        this.tick = tickTime;\n        tickProperties[key] = true;\n      }\n    }\n\n    if (!sceneEl) { return; }\n    if (this.tick) {\n      sceneEl.addBehavior(this);\n    } else {\n      sceneEl.removeBehavior(this);\n    }\n  },\n\n  updateShader: function (shaderName) {\n    var data = this.data;\n    var Shader = shaders[shaderName] && shaders[shaderName].Shader;\n    var shaderInstance;\n\n    if (!Shader) { throw new Error('Unknown shader ' + shaderName); }\n\n    // Get material from A-Frame shader.\n    shaderInstance = this.shader = new Shader();\n    shaderInstance.el = this.el;\n    shaderInstance.init(data);\n    this.setMaterial(shaderInstance.material);\n    this.updateSchema(data);\n  },\n\n  /**\n   * Set and update base material properties.\n   * Set `needsUpdate` when needed.\n   */\n  updateMaterial: function (oldData) {\n    var data = this.data;\n    var material = this.material;\n    var oldDataHasKeys;\n\n    // Base material properties.\n    material.alphaTest = data.alphaTest;\n    material.depthTest = data.depthTest !== false;\n    material.depthWrite = data.depthWrite !== false;\n    material.opacity = data.opacity;\n    material.flatShading = data.flatShading;\n    material.side = parseSide(data.side);\n    material.transparent = data.transparent !== false || data.opacity < 1.0;\n    material.vertexColors = parseVertexColors(data.vertexColors);\n    material.visible = data.visible;\n    material.blending = parseBlending(data.blending);\n\n    // Check if material needs update.\n    for (oldDataHasKeys in oldData) { break; }\n    if (oldDataHasKeys &&\n        (oldData.alphaTest !== data.alphaTest ||\n         oldData.side !== data.side ||\n         oldData.vertexColors !== data.vertexColors)) {\n      material.needsUpdate = true;\n    }\n  },\n\n  /**\n   * Remove material on remove (callback).\n   * Dispose of it from memory and unsubscribe from scene updates.\n   */\n  remove: function () {\n    var defaultMaterial = new THREE.MeshBasicMaterial();\n    var material = this.material;\n    var object3D = this.el.getObject3D('mesh');\n    if (object3D) { object3D.material = defaultMaterial; }\n    disposeMaterial(material, this.system);\n  },\n\n  /**\n   * (Re)create new material. Has side-effects of setting `this.material` and updating\n   * material registration in scene.\n   *\n   * @param {object} data - Material component data.\n   * @param {object} type - Material type to create.\n   * @returns {object} Material.\n   */\n  setMaterial: function (material) {\n    var el = this.el;\n    var mesh;\n    var system = this.system;\n\n    if (this.material) { disposeMaterial(this.material, system); }\n\n    this.material = material;\n    system.registerMaterial(material);\n\n    // Set on mesh. If mesh does not exist, wait for it.\n    mesh = el.getObject3D('mesh');\n    if (mesh) {\n      mesh.material = material;\n    } else {\n      el.addEventListener('object3dset', function waitForMesh (evt) {\n        if (evt.detail.type !== 'mesh' || evt.target !== el) { return; }\n        el.getObject3D('mesh').material = material;\n        el.removeEventListener('object3dset', waitForMesh);\n      });\n    }\n  }\n});\n\n/**\n * Return a three.js constant determining which material face sides to render\n * based on the side parameter (passed as a component property).\n *\n * @param {string} [side=front] - `front`, `back`, or `double`.\n * @returns {number} THREE.FrontSide, THREE.BackSide, or THREE.DoubleSide.\n */\nfunction parseSide (side) {\n  switch (side) {\n    case 'back': {\n      return THREE.BackSide;\n    }\n    case 'double': {\n      return THREE.DoubleSide;\n    }\n    default: {\n      // Including case `front`.\n      return THREE.FrontSide;\n    }\n  }\n}\n\n/**\n * Return a three.js constant determining vertex coloring.\n */\nfunction parseVertexColors (coloring) {\n  switch (coloring) {\n    case 'face': {\n      return THREE.FaceColors;\n    }\n    case 'vertex': {\n      return THREE.VertexColors;\n    }\n    default: {\n      return THREE.NoColors;\n    }\n  }\n}\n\n/**\n * Return a three.js constant determining blending\n *\n * @param {string} [blending=normal]\n * - `none`, additive`, `subtractive`,`multiply` or `normal`.\n * @returns {number}\n */\nfunction parseBlending (blending) {\n  switch (blending) {\n    case 'none': {\n      return THREE.NoBlending;\n    }\n    case 'additive': {\n      return THREE.AdditiveBlending;\n    }\n    case 'subtractive': {\n      return THREE.SubtractiveBlending;\n    }\n    case 'multiply': {\n      return THREE.MultiplyBlending;\n    }\n    default: {\n      return THREE.NormalBlending;\n    }\n  }\n}\n\n/**\n * Dispose of material from memory and unsubscribe material from scene updates like fog.\n */\nfunction disposeMaterial (material, system) {\n  material.dispose();\n  system.unregisterMaterial(material);\n}\n"]},"metadata":{},"sourceType":"script"}