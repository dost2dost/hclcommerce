{"ast":null,"code":"var schema = require('./schema');\n\nvar processSchema = schema.process;\nvar shaders = module.exports.shaders = {}; // Keep track of registered shaders.\n\nvar shaderNames = module.exports.shaderNames = []; // Keep track of the names of registered shaders.\n\nvar THREE = require('../lib/three');\n\nvar utils = require('../utils'); // A-Frame properties to three.js uniform types.\n\n\nvar propertyToThreeMapping = {\n  array: 'v3',\n  color: 'v3',\n  int: 'i',\n  number: 'f',\n  map: 't',\n  time: 'f',\n  vec2: 'v2',\n  vec3: 'v3',\n  vec4: 'v4'\n};\n/**\n * Shader class definition.\n *\n * Shaders extend the material component API so you can create your own library\n * of customized materials\n *\n */\n\nvar Shader = module.exports.Shader = function () {};\n\nShader.prototype = {\n  /**\n   * Contains the type schema and defaults for the data values.\n   * Data is coerced into the types of the values of the defaults.\n   */\n  schema: {},\n  vertexShader: 'void main() {' + 'gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);' + '}',\n  fragmentShader: 'void main() {' + 'gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);' + '}',\n\n  /**\n   * Init handler. Similar to attachedCallback.\n   * Called during shader initialization and is only run once.\n   */\n  init: function (data) {\n    this.attributes = this.initVariables(data, 'attribute');\n    this.uniforms = this.initVariables(data, 'uniform');\n    this.material = new (this.raw ? THREE.RawShaderMaterial : THREE.ShaderMaterial)({\n      // attributes: this.attributes,\n      uniforms: this.uniforms,\n      vertexShader: this.vertexShader,\n      fragmentShader: this.fragmentShader\n    });\n    return this.material;\n  },\n  initVariables: function (data, type) {\n    var key;\n    var schema = this.schema;\n    var variables = {};\n    var varType;\n\n    for (key in schema) {\n      if (schema[key].is !== type) {\n        continue;\n      }\n\n      varType = propertyToThreeMapping[schema[key].type];\n      variables[key] = {\n        type: varType,\n        value: undefined // Let updateVariables handle setting these.\n\n      };\n    }\n\n    return variables;\n  },\n\n  /**\n   * Update handler. Similar to attributeChangedCallback.\n   * Called whenever the associated material data changes.\n   *\n   * @param {object} data - New material data.\n   */\n  update: function (data) {\n    this.updateVariables(data, 'attribute');\n    this.updateVariables(data, 'uniform');\n  },\n  updateVariables: function (data, type) {\n    var key;\n    var materialKey;\n    var schema = this.schema;\n    var variables;\n    variables = type === 'uniform' ? this.uniforms : this.attributes;\n\n    for (key in data) {\n      if (!schema[key] || schema[key].is !== type) {\n        continue;\n      }\n\n      if (schema[key].type === 'map') {\n        // If data unchanged, get out early.\n        if (!variables[key] || variables[key].value === data[key]) {\n          continue;\n        } // Special handling is needed for textures.\n\n\n        materialKey = '_texture_' + key; // We can't actually set the variable correctly until we've loaded the texture.\n\n        this.setMapOnTextureLoad(variables, key, materialKey); // Kick off the texture update now that handler is added.\n\n        utils.material.updateMapMaterialFromData(materialKey, key, this, data);\n        continue;\n      }\n\n      variables[key].value = this.parseValue(schema[key].type, data[key]);\n      variables[key].needsUpdate = true;\n    }\n  },\n  parseValue: function (type, value) {\n    var color;\n\n    switch (type) {\n      case 'vec2':\n        {\n          return new THREE.Vector2(value.x, value.y);\n        }\n\n      case 'vec3':\n        {\n          return new THREE.Vector3(value.x, value.y, value.z);\n        }\n\n      case 'vec4':\n        {\n          return new THREE.Vector4(value.x, value.y, value.z, value.w);\n        }\n\n      case 'color':\n        {\n          color = new THREE.Color(value);\n          return new THREE.Vector3(color.r, color.g, color.b);\n        }\n\n      case 'map':\n        {\n          return THREE.ImageUtils.loadTexture(value);\n        }\n\n      default:\n        {\n          return value;\n        }\n    }\n  },\n  setMapOnTextureLoad: function (variables, key, materialKey) {\n    var self = this;\n    this.el.addEventListener('materialtextureloaded', function () {\n      variables[key].value = self.material[materialKey];\n      variables[key].needsUpdate = true;\n    });\n  }\n};\n/**\n * Registers a shader to A-Frame.\n *\n * @param {string} name - shader name.\n * @param {object} definition - shader property and methods.\n * @returns {object} Shader.\n */\n\nmodule.exports.registerShader = function (name, definition) {\n  var NewShader;\n  var proto = {}; // Format definition object to prototype object.\n\n  Object.keys(definition).forEach(function (key) {\n    proto[key] = {\n      value: definition[key],\n      writable: true\n    };\n  });\n\n  if (shaders[name]) {\n    throw new Error('The shader ' + name + ' has been already registered');\n  }\n\n  NewShader = function () {\n    Shader.call(this);\n  };\n\n  NewShader.prototype = Object.create(Shader.prototype, proto);\n  NewShader.prototype.name = name;\n  NewShader.prototype.constructor = NewShader;\n  shaders[name] = {\n    Shader: NewShader,\n    schema: processSchema(NewShader.prototype.schema)\n  };\n  shaderNames.push(name);\n  return NewShader;\n};","map":{"version":3,"sources":["C:/Users/Hannuri/Desktop/RoyalCyber/my-first-app/node_modules/aframe/src/core/shader.js"],"names":["schema","require","processSchema","process","shaders","module","exports","shaderNames","THREE","utils","propertyToThreeMapping","array","color","int","number","map","time","vec2","vec3","vec4","Shader","prototype","vertexShader","fragmentShader","init","data","attributes","initVariables","uniforms","material","raw","RawShaderMaterial","ShaderMaterial","type","key","variables","varType","is","value","undefined","update","updateVariables","materialKey","setMapOnTextureLoad","updateMapMaterialFromData","parseValue","needsUpdate","Vector2","x","y","Vector3","z","Vector4","w","Color","r","g","b","ImageUtils","loadTexture","self","el","addEventListener","registerShader","name","definition","NewShader","proto","Object","keys","forEach","writable","Error","call","create","constructor","push"],"mappings":"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","sourcesContent":["var schema = require('./schema');\n\nvar processSchema = schema.process;\nvar shaders = module.exports.shaders = {};  // Keep track of registered shaders.\nvar shaderNames = module.exports.shaderNames = [];  // Keep track of the names of registered shaders.\nvar THREE = require('../lib/three');\nvar utils = require('../utils');\n\n// A-Frame properties to three.js uniform types.\nvar propertyToThreeMapping = {\n  array: 'v3',\n  color: 'v3',\n  int: 'i',\n  number: 'f',\n  map: 't',\n  time: 'f',\n  vec2: 'v2',\n  vec3: 'v3',\n  vec4: 'v4'\n};\n\n/**\n * Shader class definition.\n *\n * Shaders extend the material component API so you can create your own library\n * of customized materials\n *\n */\nvar Shader = module.exports.Shader = function () {};\n\nShader.prototype = {\n  /**\n   * Contains the type schema and defaults for the data values.\n   * Data is coerced into the types of the values of the defaults.\n   */\n  schema: {},\n\n  vertexShader:\n    'void main() {' +\n      'gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);' +\n    '}',\n\n  fragmentShader:\n    'void main() {' +\n      'gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);' +\n    '}',\n\n  /**\n   * Init handler. Similar to attachedCallback.\n   * Called during shader initialization and is only run once.\n   */\n  init: function (data) {\n    this.attributes = this.initVariables(data, 'attribute');\n    this.uniforms = this.initVariables(data, 'uniform');\n    this.material = new (this.raw ? THREE.RawShaderMaterial : THREE.ShaderMaterial)({\n      // attributes: this.attributes,\n      uniforms: this.uniforms,\n      vertexShader: this.vertexShader,\n      fragmentShader: this.fragmentShader\n    });\n    return this.material;\n  },\n\n  initVariables: function (data, type) {\n    var key;\n    var schema = this.schema;\n    var variables = {};\n    var varType;\n\n    for (key in schema) {\n      if (schema[key].is !== type) { continue; }\n      varType = propertyToThreeMapping[schema[key].type];\n      variables[key] = {\n        type: varType,\n        value: undefined  // Let updateVariables handle setting these.\n      };\n    }\n    return variables;\n  },\n\n  /**\n   * Update handler. Similar to attributeChangedCallback.\n   * Called whenever the associated material data changes.\n   *\n   * @param {object} data - New material data.\n   */\n  update: function (data) {\n    this.updateVariables(data, 'attribute');\n    this.updateVariables(data, 'uniform');\n  },\n\n  updateVariables: function (data, type) {\n    var key;\n    var materialKey;\n    var schema = this.schema;\n    var variables;\n\n    variables = type === 'uniform' ? this.uniforms : this.attributes;\n    for (key in data) {\n      if (!schema[key] || schema[key].is !== type) { continue; }\n\n      if (schema[key].type === 'map') {\n        // If data unchanged, get out early.\n        if (!variables[key] || variables[key].value === data[key]) { continue; }\n\n        // Special handling is needed for textures.\n        materialKey = '_texture_' + key;\n\n        // We can't actually set the variable correctly until we've loaded the texture.\n        this.setMapOnTextureLoad(variables, key, materialKey);\n\n        // Kick off the texture update now that handler is added.\n        utils.material.updateMapMaterialFromData(materialKey, key, this, data);\n        continue;\n      }\n      variables[key].value = this.parseValue(schema[key].type, data[key]);\n      variables[key].needsUpdate = true;\n    }\n  },\n\n  parseValue: function (type, value) {\n    var color;\n    switch (type) {\n      case 'vec2': {\n        return new THREE.Vector2(value.x, value.y);\n      }\n      case 'vec3': {\n        return new THREE.Vector3(value.x, value.y, value.z);\n      }\n      case 'vec4': {\n        return new THREE.Vector4(value.x, value.y, value.z, value.w);\n      }\n      case 'color': {\n        color = new THREE.Color(value);\n        return new THREE.Vector3(color.r, color.g, color.b);\n      }\n      case 'map': {\n        return THREE.ImageUtils.loadTexture(value);\n      }\n      default: {\n        return value;\n      }\n    }\n  },\n\n  setMapOnTextureLoad: function (variables, key, materialKey) {\n    var self = this;\n    this.el.addEventListener('materialtextureloaded', function () {\n      variables[key].value = self.material[materialKey];\n      variables[key].needsUpdate = true;\n    });\n  }\n};\n\n/**\n * Registers a shader to A-Frame.\n *\n * @param {string} name - shader name.\n * @param {object} definition - shader property and methods.\n * @returns {object} Shader.\n */\nmodule.exports.registerShader = function (name, definition) {\n  var NewShader;\n  var proto = {};\n\n  // Format definition object to prototype object.\n  Object.keys(definition).forEach(function (key) {\n    proto[key] = {\n      value: definition[key],\n      writable: true\n    };\n  });\n\n  if (shaders[name]) {\n    throw new Error('The shader ' + name + ' has been already registered');\n  }\n  NewShader = function () { Shader.call(this); };\n  NewShader.prototype = Object.create(Shader.prototype, proto);\n  NewShader.prototype.name = name;\n  NewShader.prototype.constructor = NewShader;\n  shaders[name] = {\n    Shader: NewShader,\n    schema: processSchema(NewShader.prototype.schema)\n  };\n  shaderNames.push(name);\n  return NewShader;\n};\n"]},"metadata":{},"sourceType":"script"}