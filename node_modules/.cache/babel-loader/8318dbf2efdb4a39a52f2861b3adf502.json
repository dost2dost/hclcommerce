{"ast":null,"code":"/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { SkeletonUtils } from 'three/examples/jsm/utils/SkeletonUtils.js';\nexport const $prepared = Symbol('prepared');\nexport const $prepare = Symbol('prepare');\nexport const $preparedGLTF = Symbol('preparedGLTF');\nexport const $clone = Symbol('clone');\n/**\n * Represents the preparation and enhancement of the output of a Three.js\n * GLTFLoader (a Three.js-flavor \"GLTF\"), to make it suitable for optimal,\n * correct viewing in a given presentation context and also make the cloning\n * process more explicit and legible.\n *\n * A GLTFInstance is API-compatible with a Three.js-flavor \"GLTF\", so it should\n * be considered to be interchangeable with the loaded result of a GLTFLoader.\n *\n * This basic implementation only implements trivial preparation and enhancement\n * of a GLTF. These operations are intended to be enhanced by inheriting\n * classes.\n */\n\nexport class GLTFInstance {\n  constructor(preparedGLTF) {\n    this[$preparedGLTF] = preparedGLTF;\n  }\n  /**\n   * Prepares a given GLTF for presentation and future cloning. A GLTF that is\n   * prepared can safely have this method invoked on it multiple times; it will\n   * only be prepared once, including after being cloned.\n   */\n\n\n  static prepare(source) {\n    if (source.scene == null) {\n      throw new Error('Model does not have a scene');\n    }\n\n    if (source[$prepared]) {\n      return source;\n    }\n\n    const prepared = this[$prepare](source); // NOTE: ES5 Symbol polyfill is not compatible with spread operator\n    // so {...prepared, [$prepared]: true} does not work\n\n    prepared[$prepared] = true;\n    return prepared;\n  }\n  /**\n   * Override in an inheriting class to apply specialty one-time preparations\n   * for a given input GLTF.\n   */\n\n\n  static [$prepare](source) {\n    // TODO(#195,#1003): We don't currently support multiple scenes, so we don't\n    // bother preparing extra scenes for now:\n    const scene = source.scene;\n    const scenes = [scene];\n    return Object.assign(Object.assign({}, source), {\n      scene,\n      scenes\n    });\n  }\n\n  get parser() {\n    return this[$preparedGLTF].parser;\n  }\n\n  get animations() {\n    return this[$preparedGLTF].animations;\n  }\n\n  get scene() {\n    return this[$preparedGLTF].scene;\n  }\n\n  get scenes() {\n    return this[$preparedGLTF].scenes;\n  }\n\n  get cameras() {\n    return this[$preparedGLTF].cameras;\n  }\n\n  get asset() {\n    return this[$preparedGLTF].asset;\n  }\n\n  get userData() {\n    return this[$preparedGLTF].userData;\n  }\n  /**\n   * Creates and returns a copy of this instance.\n   */\n\n\n  clone() {\n    const GLTFInstanceConstructor = this.constructor;\n    const clonedGLTF = this[$clone]();\n    return new GLTFInstanceConstructor(clonedGLTF);\n  }\n  /**\n   * Cleans up any retained memory that might not otherwise be released when\n   * this instance is done being used.\n   */\n\n\n  dispose() {\n    this.scenes.forEach(scene => {\n      scene.traverse(object => {\n        if (!object.isMesh) {\n          return;\n        }\n\n        const mesh = object;\n        const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];\n        materials.forEach(material => {\n          material.dispose();\n        });\n        mesh.geometry.dispose();\n      });\n    });\n  }\n  /**\n   * Override in an inheriting class to implement specialized cloning strategies\n   */\n\n\n  [$clone]() {\n    const source = this[$preparedGLTF]; // TODO(#195,#1003): We don't currently support multiple scenes, so we don't\n    // bother cloning extra scenes for now:\n\n    const scene = SkeletonUtils.clone(this.scene);\n    const scenes = [scene];\n    const userData = source.userData ? Object.assign({}, source.userData) : {};\n    return Object.assign(Object.assign({}, source), {\n      scene,\n      scenes,\n      userData\n    });\n  }\n\n}","map":{"version":3,"sources":["../../src/three-components/GLTFInstance.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAiBA,SAAQ,aAAR,QAA4B,2CAA5B;AAIA,OAAO,MAAM,SAAS,GAAG,MAAM,CAAC,UAAD,CAAxB;AAMP,OAAO,MAAM,QAAQ,GAAG,MAAM,CAAC,SAAD,CAAvB;AACP,OAAO,MAAM,aAAa,GAAG,MAAM,CAAC,cAAD,CAA5B;AACP,OAAO,MAAM,MAAM,GAAG,MAAM,CAAC,OAAD,CAArB;AAEP;;;;;;;;;;;;;;AAaA,OAAM,MAAO,YAAP,CAAmB;AAmEvB,EAAA,WAAA,CAAY,YAAZ,EAAsC;AACpC,SAAK,aAAL,IAAsB,YAAtB;AACD;AApED;;;;;;;AAKA,SAAO,OAAP,CAAe,MAAf,EAA2B;AACzB,QAAI,MAAM,CAAC,KAAP,IAAgB,IAApB,EAA0B;AACxB,YAAM,IAAI,KAAJ,CAAU,6BAAV,CAAN;AACD;;AAED,QAAK,MAAuB,CAAC,SAAD,CAA5B,EAAyC;AACvC,aAAO,MAAP;AACD;;AAED,UAAM,QAAQ,GAAG,KAAK,QAAL,EAAe,MAAf,CAAjB,CATyB,CAWzB;AACA;;AACA,IAAA,QAAQ,CAAC,SAAD,CAAR,GAAsB,IAAtB;AAEA,WAAO,QAAP;AACD;AAED;;;;;;AAIU,UAAO,QAAP,EAAiB,MAAjB,EAA6B;AACrC;AACA;AAFqC,UAG9B,KAH8B,GAGrB,MAHqB,CAG9B,KAH8B;AAIrC,UAAM,MAAM,GAAG,CAAC,KAAD,CAAf;AAEA,WAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAW,MAAX,CAAA,EAAiB;AAAE,MAAA,KAAF;AAAS,MAAA;AAAT,KAAjB,CAAA;AACD;;AAID,MAAI,MAAJ,GAAU;AACR,WAAO,KAAK,aAAL,EAAoB,MAA3B;AACD;;AAED,MAAI,UAAJ,GAAc;AACZ,WAAO,KAAK,aAAL,EAAoB,UAA3B;AACD;;AAED,MAAI,KAAJ,GAAS;AACP,WAAO,KAAK,aAAL,EAAoB,KAA3B;AACD;;AAED,MAAI,MAAJ,GAAU;AACR,WAAO,KAAK,aAAL,EAAoB,MAA3B;AACD;;AAED,MAAI,OAAJ,GAAW;AACT,WAAO,KAAK,aAAL,EAAoB,OAA3B;AACD;;AAED,MAAI,KAAJ,GAAS;AACP,WAAO,KAAK,aAAL,EAAoB,KAA3B;AACD;;AAED,MAAI,QAAJ,GAAY;AACV,WAAO,KAAK,aAAL,EAAoB,QAA3B;AACD;AAMD;;;;;AAGA,EAAA,KAAK,GAAA;AACH,UAAM,uBAAuB,GAAG,KAAK,WAArC;AAEA,UAAM,UAAU,GAAG,KAAK,MAAL,GAAnB;AAEA,WAAO,IAAI,uBAAJ,CAA4B,UAA5B,CAAP;AACD;AAED;;;;;;AAIA,EAAA,OAAO,GAAA;AACL,SAAK,MAAL,CAAY,OAAZ,CAAqB,KAAD,IAAiB;AACnC,MAAA,KAAK,CAAC,QAAN,CAAgB,MAAD,IAAqB;AAClC,YAAI,CAAE,MAAe,CAAC,MAAtB,EAA8B;AAC5B;AACD;;AACD,cAAM,IAAI,GAAG,MAAb;AACA,cAAM,SAAS,GACX,KAAK,CAAC,OAAN,CAAc,IAAI,CAAC,QAAnB,IAA+B,IAAI,CAAC,QAApC,GAA+C,CAAC,IAAI,CAAC,QAAN,CADnD;AAEA,QAAA,SAAS,CAAC,OAAV,CAAkB,QAAQ,IAAG;AAC3B,UAAA,QAAQ,CAAC,OAAT;AACD,SAFD;AAGA,QAAA,IAAI,CAAC,QAAL,CAAc,OAAd;AACD,OAXD;AAYD,KAbD;AAcD;AAED;;;;;AAGS,GAAC,MAAD,IAAQ;AACf,UAAM,MAAM,GAAG,KAAK,aAAL,CAAf,CADe,CAEf;AACA;;AACA,UAAM,KAAK,GAAG,aAAa,CAAC,KAAd,CAAoB,KAAK,KAAzB,CAAd;AACA,UAAM,MAAM,GAAG,CAAC,KAAD,CAAf;AACA,UAAM,QAAQ,GAAG,MAAM,CAAC,QAAP,GAAiB,MAAA,CAAA,MAAA,CAAA,EAAA,EAAK,MAAM,CAAC,QAAZ,CAAjB,GAAyC,EAA1D;AACA,WAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAW,MAAX,CAAA,EAAiB;AAAE,MAAA,KAAF;AAAS,MAAA,MAAT;AAAiB,MAAA;AAAjB,KAAjB,CAAA;AACD;;AAlHsB","sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Group, Mesh, Object3D} from 'three';\nimport {GLTF} from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport {SkeletonUtils} from 'three/examples/jsm/utils/SkeletonUtils.js';\n\nimport {Constructor} from '../utilities.js';\n\nexport const $prepared = Symbol('prepared');\n\nexport interface PreparedGLTF extends GLTF {\n  [$prepared]?: boolean;\n}\n\nexport const $prepare = Symbol('prepare');\nexport const $preparedGLTF = Symbol('preparedGLTF');\nexport const $clone = Symbol('clone');\n\n/**\n * Represents the preparation and enhancement of the output of a Three.js\n * GLTFLoader (a Three.js-flavor \"GLTF\"), to make it suitable for optimal,\n * correct viewing in a given presentation context and also make the cloning\n * process more explicit and legible.\n *\n * A GLTFInstance is API-compatible with a Three.js-flavor \"GLTF\", so it should\n * be considered to be interchangeable with the loaded result of a GLTFLoader.\n *\n * This basic implementation only implements trivial preparation and enhancement\n * of a GLTF. These operations are intended to be enhanced by inheriting\n * classes.\n */\nexport class GLTFInstance implements GLTF {\n  /**\n   * Prepares a given GLTF for presentation and future cloning. A GLTF that is\n   * prepared can safely have this method invoked on it multiple times; it will\n   * only be prepared once, including after being cloned.\n   */\n  static prepare(source: GLTF): PreparedGLTF {\n    if (source.scene == null) {\n      throw new Error('Model does not have a scene');\n    }\n\n    if ((source as PreparedGLTF)[$prepared]) {\n      return source;\n    }\n\n    const prepared = this[$prepare](source) as Partial<PreparedGLTF>;\n\n    // NOTE: ES5 Symbol polyfill is not compatible with spread operator\n    // so {...prepared, [$prepared]: true} does not work\n    prepared[$prepared] = true;\n\n    return prepared as PreparedGLTF;\n  }\n\n  /**\n   * Override in an inheriting class to apply specialty one-time preparations\n   * for a given input GLTF.\n   */\n  protected static[$prepare](source: GLTF): GLTF {\n    // TODO(#195,#1003): We don't currently support multiple scenes, so we don't\n    // bother preparing extra scenes for now:\n    const {scene} = source;\n    const scenes = [scene];\n\n    return {...source, scene, scenes};\n  }\n\n  protected[$preparedGLTF]: PreparedGLTF;\n\n  get parser() {\n    return this[$preparedGLTF].parser;\n  }\n\n  get animations() {\n    return this[$preparedGLTF].animations;\n  }\n\n  get scene() {\n    return this[$preparedGLTF].scene;\n  }\n\n  get scenes() {\n    return this[$preparedGLTF].scenes;\n  }\n\n  get cameras() {\n    return this[$preparedGLTF].cameras;\n  }\n\n  get asset() {\n    return this[$preparedGLTF].asset;\n  }\n\n  get userData() {\n    return this[$preparedGLTF].userData;\n  }\n\n  constructor(preparedGLTF: PreparedGLTF) {\n    this[$preparedGLTF] = preparedGLTF;\n  }\n\n  /**\n   * Creates and returns a copy of this instance.\n   */\n  clone<T extends GLTFInstance>(): T {\n    const GLTFInstanceConstructor = this.constructor as Constructor<T>;\n\n    const clonedGLTF = this[$clone]();\n\n    return new GLTFInstanceConstructor(clonedGLTF);\n  }\n\n  /**\n   * Cleans up any retained memory that might not otherwise be released when\n   * this instance is done being used.\n   */\n  dispose(): void {\n    this.scenes.forEach((scene: Group) => {\n      scene.traverse((object: Object3D) => {\n        if (!(object as Mesh).isMesh) {\n          return;\n        }\n        const mesh = object as Mesh;\n        const materials =\n            Array.isArray(mesh.material) ? mesh.material : [mesh.material];\n        materials.forEach(material => {\n          material.dispose();\n        });\n        mesh.geometry.dispose();\n      });\n    });\n  }\n\n  /**\n   * Override in an inheriting class to implement specialized cloning strategies\n   */\n  protected[$clone](): PreparedGLTF {\n    const source = this[$preparedGLTF];\n    // TODO(#195,#1003): We don't currently support multiple scenes, so we don't\n    // bother cloning extra scenes for now:\n    const scene = SkeletonUtils.clone(this.scene) as Group;\n    const scenes = [scene];\n    const userData = source.userData ? {...source.userData} : {};\n    return {...source, scene, scenes, userData};\n  }\n}\n\nexport type GLTFInstanceConstructor =\n    Constructor<GLTFInstance, {prepare: typeof GLTFInstance['prepare']}>;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}