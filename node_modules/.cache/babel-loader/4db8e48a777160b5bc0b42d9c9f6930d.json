{"ast":null,"code":"var registerSystem = require('../core/system').registerSystem;\n\nvar THREE = require('../lib/three');\n\nvar utils = require('../utils/');\n\nvar isHLS = require('../utils/material').isHLS;\n\nvar bind = utils.bind;\nvar debug = utils.debug;\nvar error = debug('components:texture:error');\nvar TextureLoader = new THREE.TextureLoader();\nvar warn = debug('components:texture:warn');\nTextureLoader.setCrossOrigin('anonymous');\n/**\n * System for material component.\n * Handle material registration, updates (for fog), and texture caching.\n *\n * @member {object} materials - Registered materials.\n * @member {object} textureCounts - Number of times each texture is used. Tracked\n *         separately from textureCache, because the cache (1) is populated in\n *         multiple places, and (2) may be cleared at any time.\n * @member {object} textureCache - Texture cache for:\n *   - Images: textureCache has mapping of src -> repeat -> cached three.js texture.\n *   - Videos: textureCache has mapping of videoElement -> cached three.js texture.\n */\n\nmodule.exports.System = registerSystem('material', {\n  init: function () {\n    this.materials = {};\n    this.textureCounts = {};\n    this.textureCache = {};\n    this.sceneEl.addEventListener('materialtextureloaded', bind(this.onMaterialTextureLoaded, this));\n  },\n  clearTextureCache: function () {\n    this.textureCache = {};\n  },\n\n  /**\n   * Determine whether `src` is a image or video. Then try to load the asset, then call back.\n   *\n   * @param {string, or element} src - Texture URL or element.\n   * @param {string} data - Relevant texture data used for caching.\n   * @param {function} cb - Callback to pass texture to.\n   */\n  loadTexture: function (src, data, cb) {\n    var self = this; // Canvas.\n\n    if (src.tagName === 'CANVAS') {\n      this.loadCanvas(src, data, cb);\n      return;\n    } // Video element.\n\n\n    if (src.tagName === 'VIDEO') {\n      if (!src.src && !src.srcObject && !src.childElementCount) {\n        warn('Video element was defined with neither `source` elements nor `src` / `srcObject` attributes.');\n      }\n\n      this.loadVideo(src, data, cb);\n      return;\n    }\n\n    utils.srcLoader.validateSrc(src, loadImageCb, loadVideoCb);\n\n    function loadImageCb(src) {\n      self.loadImage(src, data, cb);\n    }\n\n    function loadVideoCb(src) {\n      self.loadVideo(src, data, cb);\n    }\n  },\n\n  /**\n   * High-level function for loading image textures (THREE.Texture).\n   *\n   * @param {Element|string} src - Texture source.\n   * @param {object} data - Texture data.\n   * @param {function} cb - Callback to pass texture to.\n   */\n  loadImage: function (src, data, handleImageTextureLoaded) {\n    var hash = this.hash(data);\n    var textureCache = this.textureCache; // Texture already being loaded or already loaded. Wait on promise.\n\n    if (textureCache[hash]) {\n      textureCache[hash].then(handleImageTextureLoaded);\n      return;\n    } // Texture not yet being loaded. Start loading it.\n\n\n    textureCache[hash] = loadImageTexture(src, data);\n    textureCache[hash].then(handleImageTextureLoaded);\n  },\n\n  /**\n   * High-level function for loading canvas textures (THREE.Texture).\n   *\n   * @param {Element|string} src - Texture source.\n   * @param {object} data - Texture data.\n   * @param {function} cb - Callback to pass texture to.\n   */\n  loadCanvas: function (src, data, cb) {\n    var texture;\n    texture = new THREE.CanvasTexture(src);\n    setTextureProperties(texture, data);\n    cb(texture);\n  },\n\n  /**\n  * Load video texture (THREE.VideoTexture).\n  * Which is just an image texture that RAFs + needsUpdate.\n  * Note that creating a video texture is synchronous unlike loading an image texture.\n  * Made asynchronous to be consistent with image textures.\n  *\n  * @param {Element|string} src - Texture source.\n  * @param {object} data - Texture data.\n  * @param {function} cb - Callback to pass texture to.\n  */\n  loadVideo: function (src, data, cb) {\n    var hash;\n    var texture;\n    var textureCache = this.textureCache;\n    var videoEl;\n    var videoTextureResult;\n\n    function handleVideoTextureLoaded(result) {\n      result.texture.needsUpdate = true;\n      cb(result.texture, result.videoEl);\n    } // Video element provided.\n\n\n    if (typeof src !== 'string') {\n      // Check cache before creating texture.\n      videoEl = src;\n      hash = this.hashVideo(data, videoEl);\n\n      if (textureCache[hash]) {\n        textureCache[hash].then(handleVideoTextureLoaded);\n        return;\n      } // If not in cache, fix up the attributes then start to create the texture.\n\n\n      fixVideoAttributes(videoEl);\n    } // Only URL provided. Use video element to create texture.\n\n\n    videoEl = videoEl || createVideoEl(src, data.width, data.height); // Generated video element already cached. Use that.\n\n    hash = this.hashVideo(data, videoEl);\n\n    if (textureCache[hash]) {\n      textureCache[hash].then(handleVideoTextureLoaded);\n      return;\n    } // Create new video texture.\n\n\n    texture = new THREE.VideoTexture(videoEl);\n    texture.minFilter = THREE.LinearFilter;\n    setTextureProperties(texture, data); // If iOS and video is HLS, do some hacks.\n\n    if (this.sceneEl.isIOS && isHLS(videoEl.src || videoEl.getAttribute('src'), videoEl.type || videoEl.getAttribute('type'))) {\n      // Actually BGRA. Tell shader to correct later.\n      texture.format = THREE.RGBAFormat;\n      texture.needsCorrectionBGRA = true; // Apparently needed for HLS. Tell shader to correct later.\n\n      texture.flipY = false;\n      texture.needsCorrectionFlipY = true;\n    } // Cache as promise to be consistent with image texture caching.\n\n\n    videoTextureResult = {\n      texture: texture,\n      videoEl: videoEl\n    };\n    textureCache[hash] = Promise.resolve(videoTextureResult);\n    handleVideoTextureLoaded(videoTextureResult);\n  },\n\n  /**\n   * Create a hash of the material properties for texture cache key.\n   */\n  hash: function (data) {\n    if (data.src.tagName) {\n      // Since `data.src` can be an element, parse out the string if necessary for the hash.\n      data = utils.extendDeep({}, data);\n      data.src = data.src.src;\n    }\n\n    return JSON.stringify(data);\n  },\n  hashVideo: function (data, videoEl) {\n    return calculateVideoCacheHash(data, videoEl);\n  },\n\n  /**\n   * Keep track of material in case an update trigger is needed (e.g., fog).\n   *\n   * @param {object} material\n   */\n  registerMaterial: function (material) {\n    this.materials[material.uuid] = material;\n  },\n\n  /**\n   * Stop tracking material, and dispose of any textures not being used by\n   * another material component.\n   *\n   * @param {object} material\n   */\n  unregisterMaterial: function (material) {\n    delete this.materials[material.uuid]; // If any textures on this material are no longer in use, dispose of them.\n\n    var textureCounts = this.textureCounts;\n    Object.keys(material).filter(function (propName) {\n      return material[propName] && material[propName].isTexture;\n    }).forEach(function (mapName) {\n      textureCounts[material[mapName].uuid]--;\n\n      if (textureCounts[material[mapName].uuid] <= 0) {\n        material[mapName].dispose();\n      }\n    });\n  },\n\n  /**\n   * Trigger update to all registered materials.\n   */\n  updateMaterials: function (material) {\n    var materials = this.materials;\n    Object.keys(materials).forEach(function (uuid) {\n      materials[uuid].needsUpdate = true;\n    });\n  },\n\n  /**\n   * Track textures used by material components, so that they can be safely\n   * disposed when no longer in use. Textures must be registered here, and not\n   * through registerMaterial(), because textures may not be attached at the\n   * time the material is registered.\n   *\n   * @param {Event} e\n   */\n  onMaterialTextureLoaded: function (e) {\n    if (!this.textureCounts[e.detail.texture.uuid]) {\n      this.textureCounts[e.detail.texture.uuid] = 0;\n    }\n\n    this.textureCounts[e.detail.texture.uuid]++;\n  }\n});\n/**\n * Calculates consistent hash from a video element using its attributes.\n * If the video element has an ID, use that.\n * Else build a hash that looks like `src:myvideo.mp4;height:200;width:400;`.\n *\n * @param data {object} - Texture data such as repeat.\n * @param videoEl {Element} - Video element.\n * @returns {string}\n */\n\nfunction calculateVideoCacheHash(data, videoEl) {\n  var i;\n  var id = videoEl.getAttribute('id');\n  var hash;\n  var videoAttributes;\n\n  if (id) {\n    return id;\n  } // Calculate hash using sorted video attributes.\n\n\n  hash = '';\n  videoAttributes = data || {};\n\n  for (i = 0; i < videoEl.attributes.length; i++) {\n    videoAttributes[videoEl.attributes[i].name] = videoEl.attributes[i].value;\n  }\n\n  Object.keys(videoAttributes).sort().forEach(function (name) {\n    hash += name + ':' + videoAttributes[name] + ';';\n  });\n  return hash;\n}\n/**\n * Load image texture.\n *\n * @private\n * @param {string|object} src - An <img> element or url to an image file.\n * @param {object} data - Data to set texture properties like `repeat`.\n * @returns {Promise} Resolves once texture is loaded.\n */\n\n\nfunction loadImageTexture(src, data) {\n  return new Promise(doLoadImageTexture);\n\n  function doLoadImageTexture(resolve, reject) {\n    var isEl = typeof src !== 'string';\n\n    function resolveTexture(texture) {\n      setTextureProperties(texture, data);\n      texture.needsUpdate = true;\n      resolve(texture);\n    } // Create texture from an element.\n\n\n    if (isEl) {\n      resolveTexture(new THREE.Texture(src));\n      return;\n    } // Request and load texture from src string. THREE will create underlying element.\n    // Use THREE.TextureLoader (src, onLoad, onProgress, onError) to load texture.\n\n\n    TextureLoader.load(src, resolveTexture, function () {\n      /* no-op */\n    }, function (xhr) {\n      error('`$s` could not be fetched (Error code: %s; Response: %s)', xhr.status, xhr.statusText);\n    });\n  }\n}\n/**\n * Set texture properties such as repeat and offset.\n *\n * @param {object} data - With keys like `repeat`.\n */\n\n\nfunction setTextureProperties(texture, data) {\n  var offset = data.offset || {\n    x: 0,\n    y: 0\n  };\n  var repeat = data.repeat || {\n    x: 1,\n    y: 1\n  };\n  var npot = data.npot || false; // To support NPOT textures, wrap must be ClampToEdge (not Repeat),\n  // and filters must not use mipmaps (i.e. Nearest or Linear).\n\n  if (npot) {\n    texture.wrapS = THREE.ClampToEdgeWrapping;\n    texture.wrapT = THREE.ClampToEdgeWrapping;\n    texture.magFilter = THREE.LinearFilter;\n    texture.minFilter = THREE.LinearFilter;\n  } // Don't bother setting repeat if it is 1/1. Power-of-two is required to repeat.\n\n\n  if (repeat.x !== 1 || repeat.y !== 1) {\n    texture.wrapS = THREE.RepeatWrapping;\n    texture.wrapT = THREE.RepeatWrapping;\n    texture.repeat.set(repeat.x, repeat.y);\n  } // Don't bother setting offset if it is 0/0.\n\n\n  if (offset.x !== 0 || offset.y !== 0) {\n    texture.offset.set(offset.x, offset.y);\n  }\n}\n/**\n * Create video element to be used as a texture.\n *\n * @param {string} src - Url to a video file.\n * @param {number} width - Width of the video.\n * @param {number} height - Height of the video.\n * @returns {Element} Video element.\n */\n\n\nfunction createVideoEl(src, width, height) {\n  var videoEl = document.createElement('video');\n  videoEl.width = width;\n  videoEl.height = height; // Support inline videos for iOS webviews.\n\n  videoEl.setAttribute('playsinline', '');\n  videoEl.setAttribute('webkit-playsinline', '');\n  videoEl.autoplay = true;\n  videoEl.loop = true;\n  videoEl.crossOrigin = 'anonymous';\n  videoEl.addEventListener('error', function () {\n    warn('`$s` is not a valid video', src);\n  }, true);\n  videoEl.src = src;\n  return videoEl;\n}\n/**\n * Fixes a video element's attributes to prevent developers from accidentally passing the\n * wrong attribute values to commonly misused video attributes.\n *\n * <video> does not treat `autoplay`, `controls`, `crossorigin`, `loop`, and `preload` as\n * as booleans. Existence of those attributes will mean truthy.\n *\n * For example, translates <video loop=\"false\"> to <video>.\n *\n * @see https://developer.mozilla.org/docs/Web/HTML/Element/video#Attributes\n * @param {Element} videoEl - Video element.\n * @returns {Element} Video element with the correct properties updated.\n */\n\n\nfunction fixVideoAttributes(videoEl) {\n  videoEl.autoplay = videoEl.hasAttribute('autoplay') && videoEl.getAttribute('autoplay') !== 'false';\n  videoEl.controls = videoEl.hasAttribute('controls') && videoEl.getAttribute('controls') !== 'false';\n\n  if (videoEl.getAttribute('loop') === 'false') {\n    videoEl.removeAttribute('loop');\n  }\n\n  if (videoEl.getAttribute('preload') === 'false') {\n    videoEl.preload = 'none';\n  }\n\n  videoEl.crossOrigin = videoEl.crossOrigin || 'anonymous'; // To support inline videos in iOS webviews.\n\n  videoEl.setAttribute('playsinline', '');\n  videoEl.setAttribute('webkit-playsinline', '');\n  return videoEl;\n}","map":{"version":3,"sources":["C:/Users/Hannuri/Desktop/RoyalCyber/my-first-app/node_modules/aframe/src/systems/material.js"],"names":["registerSystem","require","THREE","utils","isHLS","bind","debug","error","TextureLoader","warn","setCrossOrigin","module","exports","System","init","materials","textureCounts","textureCache","sceneEl","addEventListener","onMaterialTextureLoaded","clearTextureCache","loadTexture","src","data","cb","self","tagName","loadCanvas","srcObject","childElementCount","loadVideo","srcLoader","validateSrc","loadImageCb","loadVideoCb","loadImage","handleImageTextureLoaded","hash","then","loadImageTexture","texture","CanvasTexture","setTextureProperties","videoEl","videoTextureResult","handleVideoTextureLoaded","result","needsUpdate","hashVideo","fixVideoAttributes","createVideoEl","width","height","VideoTexture","minFilter","LinearFilter","isIOS","getAttribute","type","format","RGBAFormat","needsCorrectionBGRA","flipY","needsCorrectionFlipY","Promise","resolve","extendDeep","JSON","stringify","calculateVideoCacheHash","registerMaterial","material","uuid","unregisterMaterial","Object","keys","filter","propName","isTexture","forEach","mapName","dispose","updateMaterials","e","detail","i","id","videoAttributes","attributes","length","name","value","sort","doLoadImageTexture","reject","isEl","resolveTexture","Texture","load","xhr","status","statusText","offset","x","y","repeat","npot","wrapS","ClampToEdgeWrapping","wrapT","magFilter","RepeatWrapping","set","document","createElement","setAttribute","autoplay","loop","crossOrigin","hasAttribute","controls","removeAttribute","preload"],"mappings":"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","sourcesContent":["var registerSystem = require('../core/system').registerSystem;\nvar THREE = require('../lib/three');\nvar utils = require('../utils/');\nvar isHLS = require('../utils/material').isHLS;\n\nvar bind = utils.bind;\nvar debug = utils.debug;\nvar error = debug('components:texture:error');\nvar TextureLoader = new THREE.TextureLoader();\nvar warn = debug('components:texture:warn');\n\nTextureLoader.setCrossOrigin('anonymous');\n\n/**\n * System for material component.\n * Handle material registration, updates (for fog), and texture caching.\n *\n * @member {object} materials - Registered materials.\n * @member {object} textureCounts - Number of times each texture is used. Tracked\n *         separately from textureCache, because the cache (1) is populated in\n *         multiple places, and (2) may be cleared at any time.\n * @member {object} textureCache - Texture cache for:\n *   - Images: textureCache has mapping of src -> repeat -> cached three.js texture.\n *   - Videos: textureCache has mapping of videoElement -> cached three.js texture.\n */\nmodule.exports.System = registerSystem('material', {\n  init: function () {\n    this.materials = {};\n    this.textureCounts = {};\n    this.textureCache = {};\n\n    this.sceneEl.addEventListener(\n      'materialtextureloaded',\n      bind(this.onMaterialTextureLoaded, this)\n    );\n  },\n\n  clearTextureCache: function () {\n    this.textureCache = {};\n  },\n\n  /**\n   * Determine whether `src` is a image or video. Then try to load the asset, then call back.\n   *\n   * @param {string, or element} src - Texture URL or element.\n   * @param {string} data - Relevant texture data used for caching.\n   * @param {function} cb - Callback to pass texture to.\n   */\n  loadTexture: function (src, data, cb) {\n    var self = this;\n\n    // Canvas.\n    if (src.tagName === 'CANVAS') {\n      this.loadCanvas(src, data, cb);\n      return;\n    }\n\n    // Video element.\n    if (src.tagName === 'VIDEO') {\n      if (!src.src && !src.srcObject && !src.childElementCount) {\n        warn('Video element was defined with neither `source` elements nor `src` / `srcObject` attributes.');\n      }\n      this.loadVideo(src, data, cb);\n      return;\n    }\n\n    utils.srcLoader.validateSrc(src, loadImageCb, loadVideoCb);\n    function loadImageCb (src) { self.loadImage(src, data, cb); }\n    function loadVideoCb (src) { self.loadVideo(src, data, cb); }\n  },\n\n  /**\n   * High-level function for loading image textures (THREE.Texture).\n   *\n   * @param {Element|string} src - Texture source.\n   * @param {object} data - Texture data.\n   * @param {function} cb - Callback to pass texture to.\n   */\n  loadImage: function (src, data, handleImageTextureLoaded) {\n    var hash = this.hash(data);\n    var textureCache = this.textureCache;\n\n    // Texture already being loaded or already loaded. Wait on promise.\n    if (textureCache[hash]) {\n      textureCache[hash].then(handleImageTextureLoaded);\n      return;\n    }\n\n    // Texture not yet being loaded. Start loading it.\n    textureCache[hash] = loadImageTexture(src, data);\n    textureCache[hash].then(handleImageTextureLoaded);\n  },\n\n  /**\n   * High-level function for loading canvas textures (THREE.Texture).\n   *\n   * @param {Element|string} src - Texture source.\n   * @param {object} data - Texture data.\n   * @param {function} cb - Callback to pass texture to.\n   */\n  loadCanvas: function (src, data, cb) {\n    var texture;\n    texture = new THREE.CanvasTexture(src);\n    setTextureProperties(texture, data);\n    cb(texture);\n  },\n\n    /**\n   * Load video texture (THREE.VideoTexture).\n   * Which is just an image texture that RAFs + needsUpdate.\n   * Note that creating a video texture is synchronous unlike loading an image texture.\n   * Made asynchronous to be consistent with image textures.\n   *\n   * @param {Element|string} src - Texture source.\n   * @param {object} data - Texture data.\n   * @param {function} cb - Callback to pass texture to.\n   */\n  loadVideo: function (src, data, cb) {\n    var hash;\n    var texture;\n    var textureCache = this.textureCache;\n    var videoEl;\n    var videoTextureResult;\n\n    function handleVideoTextureLoaded (result) {\n      result.texture.needsUpdate = true;\n      cb(result.texture, result.videoEl);\n    }\n\n    // Video element provided.\n    if (typeof src !== 'string') {\n      // Check cache before creating texture.\n      videoEl = src;\n      hash = this.hashVideo(data, videoEl);\n      if (textureCache[hash]) {\n        textureCache[hash].then(handleVideoTextureLoaded);\n        return;\n      }\n      // If not in cache, fix up the attributes then start to create the texture.\n      fixVideoAttributes(videoEl);\n    }\n\n    // Only URL provided. Use video element to create texture.\n    videoEl = videoEl || createVideoEl(src, data.width, data.height);\n\n    // Generated video element already cached. Use that.\n    hash = this.hashVideo(data, videoEl);\n    if (textureCache[hash]) {\n      textureCache[hash].then(handleVideoTextureLoaded);\n      return;\n    }\n\n    // Create new video texture.\n    texture = new THREE.VideoTexture(videoEl);\n    texture.minFilter = THREE.LinearFilter;\n    setTextureProperties(texture, data);\n\n    // If iOS and video is HLS, do some hacks.\n    if (this.sceneEl.isIOS &&\n        isHLS(videoEl.src || videoEl.getAttribute('src'),\n              videoEl.type || videoEl.getAttribute('type'))) {\n      // Actually BGRA. Tell shader to correct later.\n      texture.format = THREE.RGBAFormat;\n      texture.needsCorrectionBGRA = true;\n      // Apparently needed for HLS. Tell shader to correct later.\n      texture.flipY = false;\n      texture.needsCorrectionFlipY = true;\n    }\n\n    // Cache as promise to be consistent with image texture caching.\n    videoTextureResult = {texture: texture, videoEl: videoEl};\n    textureCache[hash] = Promise.resolve(videoTextureResult);\n    handleVideoTextureLoaded(videoTextureResult);\n  },\n\n  /**\n   * Create a hash of the material properties for texture cache key.\n   */\n  hash: function (data) {\n    if (data.src.tagName) {\n      // Since `data.src` can be an element, parse out the string if necessary for the hash.\n      data = utils.extendDeep({}, data);\n      data.src = data.src.src;\n    }\n    return JSON.stringify(data);\n  },\n\n  hashVideo: function (data, videoEl) {\n    return calculateVideoCacheHash(data, videoEl);\n  },\n\n  /**\n   * Keep track of material in case an update trigger is needed (e.g., fog).\n   *\n   * @param {object} material\n   */\n  registerMaterial: function (material) {\n    this.materials[material.uuid] = material;\n  },\n\n  /**\n   * Stop tracking material, and dispose of any textures not being used by\n   * another material component.\n   *\n   * @param {object} material\n   */\n  unregisterMaterial: function (material) {\n    delete this.materials[material.uuid];\n\n    // If any textures on this material are no longer in use, dispose of them.\n    var textureCounts = this.textureCounts;\n    Object.keys(material)\n      .filter(function (propName) {\n        return material[propName] && material[propName].isTexture;\n      })\n      .forEach(function (mapName) {\n        textureCounts[material[mapName].uuid]--;\n        if (textureCounts[material[mapName].uuid] <= 0) {\n          material[mapName].dispose();\n        }\n      });\n  },\n\n  /**\n   * Trigger update to all registered materials.\n   */\n  updateMaterials: function (material) {\n    var materials = this.materials;\n    Object.keys(materials).forEach(function (uuid) {\n      materials[uuid].needsUpdate = true;\n    });\n  },\n\n  /**\n   * Track textures used by material components, so that they can be safely\n   * disposed when no longer in use. Textures must be registered here, and not\n   * through registerMaterial(), because textures may not be attached at the\n   * time the material is registered.\n   *\n   * @param {Event} e\n   */\n  onMaterialTextureLoaded: function (e) {\n    if (!this.textureCounts[e.detail.texture.uuid]) {\n      this.textureCounts[e.detail.texture.uuid] = 0;\n    }\n    this.textureCounts[e.detail.texture.uuid]++;\n  }\n});\n\n/**\n * Calculates consistent hash from a video element using its attributes.\n * If the video element has an ID, use that.\n * Else build a hash that looks like `src:myvideo.mp4;height:200;width:400;`.\n *\n * @param data {object} - Texture data such as repeat.\n * @param videoEl {Element} - Video element.\n * @returns {string}\n */\nfunction calculateVideoCacheHash (data, videoEl) {\n  var i;\n  var id = videoEl.getAttribute('id');\n  var hash;\n  var videoAttributes;\n\n  if (id) { return id; }\n\n  // Calculate hash using sorted video attributes.\n  hash = '';\n  videoAttributes = data || {};\n  for (i = 0; i < videoEl.attributes.length; i++) {\n    videoAttributes[videoEl.attributes[i].name] = videoEl.attributes[i].value;\n  }\n  Object.keys(videoAttributes).sort().forEach(function (name) {\n    hash += name + ':' + videoAttributes[name] + ';';\n  });\n\n  return hash;\n}\n\n/**\n * Load image texture.\n *\n * @private\n * @param {string|object} src - An <img> element or url to an image file.\n * @param {object} data - Data to set texture properties like `repeat`.\n * @returns {Promise} Resolves once texture is loaded.\n */\nfunction loadImageTexture (src, data) {\n  return new Promise(doLoadImageTexture);\n\n  function doLoadImageTexture (resolve, reject) {\n    var isEl = typeof src !== 'string';\n\n    function resolveTexture (texture) {\n      setTextureProperties(texture, data);\n      texture.needsUpdate = true;\n      resolve(texture);\n    }\n\n    // Create texture from an element.\n    if (isEl) {\n      resolveTexture(new THREE.Texture(src));\n      return;\n    }\n\n    // Request and load texture from src string. THREE will create underlying element.\n    // Use THREE.TextureLoader (src, onLoad, onProgress, onError) to load texture.\n    TextureLoader.load(\n      src,\n      resolveTexture,\n      function () { /* no-op */ },\n      function (xhr) {\n        error('`$s` could not be fetched (Error code: %s; Response: %s)', xhr.status,\n              xhr.statusText);\n      }\n    );\n  }\n}\n\n/**\n * Set texture properties such as repeat and offset.\n *\n * @param {object} data - With keys like `repeat`.\n */\nfunction setTextureProperties (texture, data) {\n  var offset = data.offset || {x: 0, y: 0};\n  var repeat = data.repeat || {x: 1, y: 1};\n  var npot = data.npot || false;\n\n  // To support NPOT textures, wrap must be ClampToEdge (not Repeat),\n  // and filters must not use mipmaps (i.e. Nearest or Linear).\n  if (npot) {\n    texture.wrapS = THREE.ClampToEdgeWrapping;\n    texture.wrapT = THREE.ClampToEdgeWrapping;\n    texture.magFilter = THREE.LinearFilter;\n    texture.minFilter = THREE.LinearFilter;\n  }\n\n  // Don't bother setting repeat if it is 1/1. Power-of-two is required to repeat.\n  if (repeat.x !== 1 || repeat.y !== 1) {\n    texture.wrapS = THREE.RepeatWrapping;\n    texture.wrapT = THREE.RepeatWrapping;\n    texture.repeat.set(repeat.x, repeat.y);\n  }\n  // Don't bother setting offset if it is 0/0.\n  if (offset.x !== 0 || offset.y !== 0) {\n    texture.offset.set(offset.x, offset.y);\n  }\n}\n\n/**\n * Create video element to be used as a texture.\n *\n * @param {string} src - Url to a video file.\n * @param {number} width - Width of the video.\n * @param {number} height - Height of the video.\n * @returns {Element} Video element.\n */\nfunction createVideoEl (src, width, height) {\n  var videoEl = document.createElement('video');\n  videoEl.width = width;\n  videoEl.height = height;\n  // Support inline videos for iOS webviews.\n  videoEl.setAttribute('playsinline', '');\n  videoEl.setAttribute('webkit-playsinline', '');\n  videoEl.autoplay = true;\n  videoEl.loop = true;\n  videoEl.crossOrigin = 'anonymous';\n  videoEl.addEventListener('error', function () {\n    warn('`$s` is not a valid video', src);\n  }, true);\n  videoEl.src = src;\n  return videoEl;\n}\n\n/**\n * Fixes a video element's attributes to prevent developers from accidentally passing the\n * wrong attribute values to commonly misused video attributes.\n *\n * <video> does not treat `autoplay`, `controls`, `crossorigin`, `loop`, and `preload` as\n * as booleans. Existence of those attributes will mean truthy.\n *\n * For example, translates <video loop=\"false\"> to <video>.\n *\n * @see https://developer.mozilla.org/docs/Web/HTML/Element/video#Attributes\n * @param {Element} videoEl - Video element.\n * @returns {Element} Video element with the correct properties updated.\n */\nfunction fixVideoAttributes (videoEl) {\n  videoEl.autoplay = videoEl.hasAttribute('autoplay') && videoEl.getAttribute('autoplay') !== 'false';\n  videoEl.controls = videoEl.hasAttribute('controls') && videoEl.getAttribute('controls') !== 'false';\n  if (videoEl.getAttribute('loop') === 'false') {\n    videoEl.removeAttribute('loop');\n  }\n  if (videoEl.getAttribute('preload') === 'false') {\n    videoEl.preload = 'none';\n  }\n  videoEl.crossOrigin = videoEl.crossOrigin || 'anonymous';\n  // To support inline videos in iOS webviews.\n  videoEl.setAttribute('playsinline', '');\n  videoEl.setAttribute('webkit-playsinline', '');\n  return videoEl;\n}\n"]},"metadata":{},"sourceType":"script"}