{"ast":null,"code":"var anime = require('super-animejs');\n\nvar components = require('../core/component').components;\n\nvar registerComponent = require('../core/component').registerComponent;\n\nvar THREE = require('../lib/three');\n\nvar utils = require('../utils');\n\nvar colorHelperFrom = new THREE.Color();\nvar colorHelperTo = new THREE.Color();\nvar getComponentProperty = utils.entity.getComponentProperty;\nvar setComponentProperty = utils.entity.setComponentProperty;\nvar splitCache = {};\nvar TYPE_COLOR = 'color';\nvar PROP_POSITION = 'position';\nvar PROP_ROTATION = 'rotation';\nvar PROP_SCALE = 'scale';\nvar STRING_COMPONENTS = 'components';\nvar STRING_OBJECT3D = 'object3D';\n/**\n * Animation component for A-Frame using anime.js.\n *\n * The component manually controls the tick by setting `autoplay: false` on anime.js and\n * manually * calling `animation.tick()` in the tick handler. To pause or resume, we toggle a\n * boolean * flag * `isAnimationPlaying`.\n *\n * anime.js animation config for tweenining Javascript objects and values works as:\n *\n *  config = {\n *    targets: {foo: 0.0, bar: '#000'},\n *    foo: 1.0,\n *    bar: '#FFF'\n *  }\n *\n * The above will tween each property in `targets`. The `to` values are set in the root of\n * the config.\n *\n * @member {object} animation - anime.js instance.\n * @member {boolean} animationIsPlaying - Control if animation is playing.\n */\n\nmodule.exports.Component = registerComponent('animation', {\n  schema: {\n    autoplay: {\n      default: true\n    },\n    delay: {\n      default: 0\n    },\n    dir: {\n      default: ''\n    },\n    dur: {\n      default: 1000\n    },\n    easing: {\n      default: 'easeInQuad'\n    },\n    elasticity: {\n      default: 400\n    },\n    enabled: {\n      default: true\n    },\n    from: {\n      default: ''\n    },\n    loop: {\n      default: 0,\n      parse: function (value) {\n        // Boolean or integer.\n        if (value === true || value === 'true') {\n          return true;\n        }\n\n        if (value === false || value === 'false') {\n          return false;\n        }\n\n        return parseInt(value, 10);\n      }\n    },\n    property: {\n      default: ''\n    },\n    startEvents: {\n      type: 'array'\n    },\n    pauseEvents: {\n      type: 'array'\n    },\n    resumeEvents: {\n      type: 'array'\n    },\n    round: {\n      default: false\n    },\n    to: {\n      default: ''\n    },\n    type: {\n      default: ''\n    },\n    isRawProperty: {\n      default: false\n    }\n  },\n  multiple: true,\n  init: function () {\n    var self = this;\n    this.eventDetail = {\n      name: this.attrName\n    };\n    this.time = 0;\n    this.animation = null;\n    this.animationIsPlaying = false;\n    this.onStartEvent = this.onStartEvent.bind(this);\n    this.beginAnimation = this.beginAnimation.bind(this);\n    this.pauseAnimation = this.pauseAnimation.bind(this);\n    this.resumeAnimation = this.resumeAnimation.bind(this);\n    this.fromColor = {};\n    this.toColor = {};\n    this.targets = {};\n    this.targetsArray = [];\n    this.updateConfigForDefault = this.updateConfigForDefault.bind(this);\n    this.updateConfigForRawColor = this.updateConfigForRawColor.bind(this);\n    this.config = {\n      complete: function () {\n        self.animationIsPlaying = false;\n        self.el.emit('animationcomplete', self.eventDetail, false);\n\n        if (self.id) {\n          self.el.emit('animationcomplete__' + self.id, self.eventDetail, false);\n        }\n      }\n    };\n  },\n  update: function (oldData) {\n    var config = this.config;\n    var data = this.data;\n    this.animationIsPlaying = false;\n\n    if (!this.data.enabled) {\n      return;\n    }\n\n    if (!data.property) {\n      return;\n    } // Base config.\n\n\n    config.autoplay = false;\n    config.direction = data.dir;\n    config.duration = data.dur;\n    config.easing = data.easing;\n    config.elasticity = data.elasticity;\n    config.loop = data.loop;\n    config.round = data.round; // Start new animation.\n\n    this.createAndStartAnimation();\n  },\n  tick: function (t, dt) {\n    if (!this.animationIsPlaying) {\n      return;\n    }\n\n    this.time += dt;\n    this.animation.tick(this.time);\n  },\n  remove: function () {\n    this.pauseAnimation();\n    this.removeEventListeners();\n  },\n  pause: function () {\n    this.paused = true;\n    this.pausedWasPlaying = this.animationIsPlaying;\n    this.pauseAnimation();\n    this.removeEventListeners();\n  },\n\n  /**\n   * `play` handler only for resuming scene.\n   */\n  play: function () {\n    if (!this.paused) {\n      return;\n    }\n\n    this.paused = false;\n    this.addEventListeners();\n\n    if (this.pausedWasPlaying) {\n      this.resumeAnimation();\n      this.pausedWasPlaying = false;\n    }\n  },\n\n  /**\n   * Start animation from scratch.\n   */\n  createAndStartAnimation: function () {\n    var data = this.data;\n    this.updateConfig();\n    this.animationIsPlaying = false;\n    this.animation = anime(this.config);\n    this.animation.began = true;\n    this.removeEventListeners();\n    this.addEventListeners(); // Wait for start events for animation.\n\n    if (!data.autoplay || data.startEvents && data.startEvents.length) {\n      return;\n    } // Delay animation.\n\n\n    if (data.delay) {\n      setTimeout(this.beginAnimation, data.delay);\n      return;\n    } // Play animation.\n\n\n    this.beginAnimation();\n  },\n\n  /**\n   * This is before animation start (including from startEvents).\n   * Set to initial state (config.from, time = 0, seekTime = 0).\n   */\n  beginAnimation: function () {\n    this.updateConfig();\n    this.animation.began = true;\n    this.time = 0;\n    this.animationIsPlaying = true;\n    this.stopRelatedAnimations();\n    this.el.emit('animationbegin', this.eventDetail, false);\n  },\n  pauseAnimation: function () {\n    this.animationIsPlaying = false;\n  },\n  resumeAnimation: function () {\n    this.animationIsPlaying = true;\n  },\n\n  /**\n   * startEvents callback.\n   */\n  onStartEvent: function () {\n    if (!this.data.enabled) {\n      return;\n    }\n\n    this.updateConfig();\n\n    if (this.animation) {\n      this.animation.pause();\n    }\n\n    this.animation = anime(this.config); // Include the delay before each start event.\n\n    if (this.data.delay) {\n      setTimeout(this.beginAnimation, this.data.delay);\n      return;\n    }\n\n    this.beginAnimation();\n  },\n\n  /**\n   * rawProperty: true and type: color;\n   */\n  updateConfigForRawColor: function () {\n    var config = this.config;\n    var data = this.data;\n    var el = this.el;\n    var from;\n    var key;\n    var to;\n\n    if (this.waitComponentInitRawProperty(this.updateConfigForRawColor)) {\n      return;\n    }\n\n    from = data.from === '' ? getRawProperty(el, data.property) : data.from;\n    to = data.to; // Use r/g/b vector for color type.\n\n    this.setColorConfig(from, to);\n    from = this.fromColor;\n    to = this.toColor;\n    this.targetsArray.length = 0;\n    this.targetsArray.push(from);\n    config.targets = this.targetsArray;\n\n    for (key in to) {\n      config[key] = to[key];\n    }\n\n    config.update = function () {\n      var lastValue = {};\n      return function (anim) {\n        var value;\n        value = anim.animatables[0].target; // For animation timeline.\n\n        if (value.r === lastValue.r && value.g === lastValue.g && value.b === lastValue.b) {\n          return;\n        }\n\n        setRawProperty(el, data.property, value, data.type);\n      };\n    }();\n  },\n\n  /**\n   * Stuff property into generic `property` key.\n   */\n  updateConfigForDefault: function () {\n    var config = this.config;\n    var data = this.data;\n    var el = this.el;\n    var from;\n    var isBoolean;\n    var isNumber;\n    var to;\n\n    if (this.waitComponentInitRawProperty(this.updateConfigForDefault)) {\n      return;\n    }\n\n    if (data.from === '') {\n      // Infer from.\n      from = isRawProperty(data) ? getRawProperty(el, data.property) : getComponentProperty(el, data.property);\n    } else {\n      // Explicit from.\n      from = data.from;\n    }\n\n    to = data.to;\n    isNumber = !isNaN(from || to);\n\n    if (isNumber) {\n      from = parseFloat(from);\n      to = parseFloat(to);\n    } else {\n      from = from ? from.toString() : from;\n      to = to ? to.toString() : to;\n    } // Convert booleans to integer to allow boolean flipping.\n\n\n    isBoolean = data.to === 'true' || data.to === 'false' || data.to === true || data.to === false;\n\n    if (isBoolean) {\n      from = data.from === 'true' || data.from === true ? 1 : 0;\n      to = data.to === 'true' || data.to === true ? 1 : 0;\n    }\n\n    this.targets.aframeProperty = from;\n    config.targets = this.targets;\n    config.aframeProperty = to;\n\n    config.update = function () {\n      var lastValue;\n      return function (anim) {\n        var value;\n        value = anim.animatables[0].target.aframeProperty; // Need to do a last value check for animation timeline since all the tweening\n        // begins simultaenously even if the value has not changed. Also better for perf\n        // anyways.\n\n        if (value === lastValue) {\n          return;\n        }\n\n        lastValue = value;\n\n        if (isBoolean) {\n          value = value >= 1;\n        }\n\n        if (isRawProperty(data)) {\n          setRawProperty(el, data.property, value, data.type);\n        } else {\n          setComponentProperty(el, data.property, value);\n        }\n      };\n    }();\n  },\n\n  /**\n   * Extend x/y/z/w onto the config.\n   * Update vector by modifying object3D.\n   */\n  updateConfigForVector: function () {\n    var config = this.config;\n    var data = this.data;\n    var el = this.el;\n    var key;\n    var from;\n    var to; // Parse coordinates.\n\n    from = data.from !== '' ? utils.coordinates.parse(data.from) // If data.from defined, use that.\n    : getComponentProperty(el, data.property); // If data.from not defined, get on the fly.\n\n    to = utils.coordinates.parse(data.to);\n\n    if (data.property === PROP_ROTATION) {\n      toRadians(from);\n      toRadians(to);\n    } // Set to and from.\n\n\n    this.targetsArray.length = 0;\n    this.targetsArray.push(from);\n    config.targets = this.targetsArray;\n\n    for (key in to) {\n      config[key] = to[key];\n    } // If animating object3D transformation, run more optimized updater.\n\n\n    if (data.property === PROP_POSITION || data.property === PROP_ROTATION || data.property === PROP_SCALE) {\n      config.update = function () {\n        var lastValue = {};\n        return function (anim) {\n          var value = anim.animatables[0].target;\n\n          if (data.property === PROP_SCALE) {\n            value.x = Math.max(0.0001, value.x);\n            value.y = Math.max(0.0001, value.y);\n            value.z = Math.max(0.0001, value.z);\n          } // For animation timeline.\n\n\n          if (value.x === lastValue.x && value.y === lastValue.y && value.z === lastValue.z) {\n            return;\n          }\n\n          lastValue.x = value.x;\n          lastValue.y = value.y;\n          lastValue.z = value.z;\n          el.object3D[data.property].set(value.x, value.y, value.z);\n        };\n      }();\n\n      return;\n    } // Animating some vector.\n\n\n    config.update = function () {\n      var lastValue = {};\n      return function (anim) {\n        var value = anim.animatables[0].target; // Animate rotation through radians.\n        // For animation timeline.\n\n        if (value.x === lastValue.x && value.y === lastValue.y && value.z === lastValue.z) {\n          return;\n        }\n\n        lastValue.x = value.x;\n        lastValue.y = value.y;\n        lastValue.z = value.z;\n        setComponentProperty(el, data.property, value);\n      };\n    }();\n  },\n\n  /**\n   * Update the config before each run.\n   */\n  updateConfig: function () {\n    var propType; // Route config type.\n\n    propType = getPropertyType(this.el, this.data.property);\n\n    if (isRawProperty(this.data) && this.data.type === TYPE_COLOR) {\n      this.updateConfigForRawColor();\n    } else if (propType === 'vec2' || propType === 'vec3' || propType === 'vec4') {\n      this.updateConfigForVector();\n    } else {\n      this.updateConfigForDefault();\n    }\n  },\n\n  /**\n   * Wait for component to initialize.\n   */\n  waitComponentInitRawProperty: function (cb) {\n    var componentName;\n    var data = this.data;\n    var el = this.el;\n    var self = this;\n\n    if (data.from !== '') {\n      return false;\n    }\n\n    if (!data.property.startsWith(STRING_COMPONENTS)) {\n      return false;\n    }\n\n    componentName = splitDot(data.property)[1];\n\n    if (el.components[componentName]) {\n      return false;\n    }\n\n    el.addEventListener('componentinitialized', function wait(evt) {\n      if (evt.detail.name !== componentName) {\n        return;\n      }\n\n      cb(); // Since the config was created async, create the animation now since we missed it\n      // earlier.\n\n      self.animation = anime(self.config);\n      el.removeEventListener('componentinitialized', wait);\n    });\n    return true;\n  },\n\n  /**\n   * Make sure two animations on the same property don't fight each other.\n   * e.g., animation__mouseenter=\"property: material.opacity\"\n   *       animation__mouseleave=\"property: material.opacity\"\n   */\n  stopRelatedAnimations: function () {\n    var component;\n    var componentName;\n\n    for (componentName in this.el.components) {\n      component = this.el.components[componentName];\n\n      if (componentName === this.attrName) {\n        continue;\n      }\n\n      if (component.name !== 'animation') {\n        continue;\n      }\n\n      if (!component.animationIsPlaying) {\n        continue;\n      }\n\n      if (component.data.property !== this.data.property) {\n        continue;\n      }\n\n      component.animationIsPlaying = false;\n    }\n  },\n  addEventListeners: function () {\n    var data = this.data;\n    var el = this.el;\n    addEventListeners(el, data.startEvents, this.onStartEvent);\n    addEventListeners(el, data.pauseEvents, this.pauseAnimation);\n    addEventListeners(el, data.resumeEvents, this.resumeAnimation);\n  },\n  removeEventListeners: function () {\n    var data = this.data;\n    var el = this.el;\n    removeEventListeners(el, data.startEvents, this.onStartEvent);\n    removeEventListeners(el, data.pauseEvents, this.pauseAnimation);\n    removeEventListeners(el, data.resumeEvents, this.resumeAnimation);\n  },\n  setColorConfig: function (from, to) {\n    colorHelperFrom.set(from);\n    colorHelperTo.set(to);\n    from = this.fromColor;\n    to = this.toColor;\n    from.r = colorHelperFrom.r;\n    from.g = colorHelperFrom.g;\n    from.b = colorHelperFrom.b;\n    to.r = colorHelperTo.r;\n    to.g = colorHelperTo.g;\n    to.b = colorHelperTo.b;\n  }\n});\n/**\n * Given property name, check schema to see what type we are animating.\n * We just care whether the property is a vector.\n */\n\nfunction getPropertyType(el, property) {\n  var component;\n  var componentName;\n  var split;\n  var propertyName;\n  split = property.split('.');\n  componentName = split[0];\n  propertyName = split[1];\n  component = el.components[componentName] || components[componentName]; // Primitives.\n\n  if (!component) {\n    return null;\n  } // Dynamic schema. We only care about vectors anyways.\n\n\n  if (propertyName && !component.schema[propertyName]) {\n    return null;\n  } // Multi-prop.\n\n\n  if (propertyName) {\n    return component.schema[propertyName].type;\n  } // Single-prop.\n\n\n  return component.schema.type;\n}\n/**\n * Convert object to radians.\n */\n\n\nfunction toRadians(obj) {\n  obj.x = THREE.Math.degToRad(obj.x);\n  obj.y = THREE.Math.degToRad(obj.y);\n  obj.z = THREE.Math.degToRad(obj.z);\n}\n\nfunction addEventListeners(el, eventNames, handler) {\n  var i;\n\n  for (i = 0; i < eventNames.length; i++) {\n    el.addEventListener(eventNames[i], handler);\n  }\n}\n\nfunction removeEventListeners(el, eventNames, handler) {\n  var i;\n\n  for (i = 0; i < eventNames.length; i++) {\n    el.removeEventListener(eventNames[i], handler);\n  }\n}\n\nfunction getRawProperty(el, path) {\n  var i;\n  var split;\n  var value;\n  split = splitDot(path);\n  value = el;\n\n  for (i = 0; i < split.length; i++) {\n    value = value[split[i]];\n  }\n\n  if (value === undefined) {\n    console.log(el);\n    throw new Error('[animation] property (' + path + ') could not be found');\n  }\n\n  return value;\n}\n\nfunction setRawProperty(el, path, value, type) {\n  var i;\n  var split;\n  var propertyName;\n  var targetValue;\n\n  if (path.startsWith('object3D.rotation')) {\n    value = THREE.Math.degToRad(value);\n  } // Walk.\n\n\n  split = splitDot(path);\n  targetValue = el;\n\n  for (i = 0; i < split.length - 1; i++) {\n    targetValue = targetValue[split[i]];\n  }\n\n  propertyName = split[split.length - 1]; // Raw color.\n\n  if (type === TYPE_COLOR) {\n    if ('r' in targetValue[propertyName]) {\n      targetValue[propertyName].r = value.r;\n      targetValue[propertyName].g = value.g;\n      targetValue[propertyName].b = value.b;\n    } else {\n      targetValue[propertyName].x = value.r;\n      targetValue[propertyName].y = value.g;\n      targetValue[propertyName].z = value.b;\n    }\n\n    return;\n  }\n\n  targetValue[propertyName] = value;\n}\n\nfunction splitDot(path) {\n  if (path in splitCache) {\n    return splitCache[path];\n  }\n\n  splitCache[path] = path.split('.');\n  return splitCache[path];\n}\n\nfunction isRawProperty(data) {\n  return data.isRawProperty || data.property.startsWith(STRING_COMPONENTS) || data.property.startsWith(STRING_OBJECT3D);\n}","map":{"version":3,"sources":["C:/Users/Hannuri/Desktop/RoyalCyber/my-first-app/node_modules/aframe/src/components/animation.js"],"names":["anime","require","components","registerComponent","THREE","utils","colorHelperFrom","Color","colorHelperTo","getComponentProperty","entity","setComponentProperty","splitCache","TYPE_COLOR","PROP_POSITION","PROP_ROTATION","PROP_SCALE","STRING_COMPONENTS","STRING_OBJECT3D","module","exports","Component","schema","autoplay","default","delay","dir","dur","easing","elasticity","enabled","from","loop","parse","value","parseInt","property","startEvents","type","pauseEvents","resumeEvents","round","to","isRawProperty","multiple","init","self","eventDetail","name","attrName","time","animation","animationIsPlaying","onStartEvent","bind","beginAnimation","pauseAnimation","resumeAnimation","fromColor","toColor","targets","targetsArray","updateConfigForDefault","updateConfigForRawColor","config","complete","el","emit","id","update","oldData","data","direction","duration","createAndStartAnimation","tick","t","dt","remove","removeEventListeners","pause","paused","pausedWasPlaying","play","addEventListeners","updateConfig","began","length","setTimeout","stopRelatedAnimations","key","waitComponentInitRawProperty","getRawProperty","setColorConfig","push","lastValue","anim","animatables","target","r","g","b","setRawProperty","isBoolean","isNumber","isNaN","parseFloat","toString","aframeProperty","updateConfigForVector","coordinates","toRadians","x","Math","max","y","z","object3D","set","propType","getPropertyType","cb","componentName","startsWith","splitDot","addEventListener","wait","evt","detail","removeEventListener","component","split","propertyName","obj","degToRad","eventNames","handler","i","path","undefined","console","log","Error","targetValue"],"mappings":"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","sourcesContent":["var anime = require('super-animejs');\nvar components = require('../core/component').components;\nvar registerComponent = require('../core/component').registerComponent;\nvar THREE = require('../lib/three');\nvar utils = require('../utils');\n\nvar colorHelperFrom = new THREE.Color();\nvar colorHelperTo = new THREE.Color();\n\nvar getComponentProperty = utils.entity.getComponentProperty;\nvar setComponentProperty = utils.entity.setComponentProperty;\nvar splitCache = {};\n\nvar TYPE_COLOR = 'color';\nvar PROP_POSITION = 'position';\nvar PROP_ROTATION = 'rotation';\nvar PROP_SCALE = 'scale';\nvar STRING_COMPONENTS = 'components';\nvar STRING_OBJECT3D = 'object3D';\n\n/**\n * Animation component for A-Frame using anime.js.\n *\n * The component manually controls the tick by setting `autoplay: false` on anime.js and\n * manually * calling `animation.tick()` in the tick handler. To pause or resume, we toggle a\n * boolean * flag * `isAnimationPlaying`.\n *\n * anime.js animation config for tweenining Javascript objects and values works as:\n *\n *  config = {\n *    targets: {foo: 0.0, bar: '#000'},\n *    foo: 1.0,\n *    bar: '#FFF'\n *  }\n *\n * The above will tween each property in `targets`. The `to` values are set in the root of\n * the config.\n *\n * @member {object} animation - anime.js instance.\n * @member {boolean} animationIsPlaying - Control if animation is playing.\n */\nmodule.exports.Component = registerComponent('animation', {\n  schema: {\n    autoplay: {default: true},\n    delay: {default: 0},\n    dir: {default: ''},\n    dur: {default: 1000},\n    easing: {default: 'easeInQuad'},\n    elasticity: {default: 400},\n    enabled: {default: true},\n    from: {default: ''},\n    loop: {\n      default: 0,\n      parse: function (value) {\n        // Boolean or integer.\n        if (value === true || value === 'true') { return true; }\n        if (value === false || value === 'false') { return false; }\n        return parseInt(value, 10);\n      }\n    },\n    property: {default: ''},\n    startEvents: {type: 'array'},\n    pauseEvents: {type: 'array'},\n    resumeEvents: {type: 'array'},\n    round: {default: false},\n    to: {default: ''},\n    type: {default: ''},\n    isRawProperty: {default: false}\n  },\n\n  multiple: true,\n\n  init: function () {\n    var self = this;\n\n    this.eventDetail = {name: this.attrName};\n    this.time = 0;\n\n    this.animation = null;\n    this.animationIsPlaying = false;\n    this.onStartEvent = this.onStartEvent.bind(this);\n    this.beginAnimation = this.beginAnimation.bind(this);\n    this.pauseAnimation = this.pauseAnimation.bind(this);\n    this.resumeAnimation = this.resumeAnimation.bind(this);\n\n    this.fromColor = {};\n    this.toColor = {};\n    this.targets = {};\n    this.targetsArray = [];\n\n    this.updateConfigForDefault = this.updateConfigForDefault.bind(this);\n    this.updateConfigForRawColor = this.updateConfigForRawColor.bind(this);\n\n    this.config = {\n      complete: function () {\n        self.animationIsPlaying = false;\n        self.el.emit('animationcomplete', self.eventDetail, false);\n        if (self.id) {\n          self.el.emit('animationcomplete__' + self.id, self.eventDetail, false);\n        }\n      }\n    };\n  },\n\n  update: function (oldData) {\n    var config = this.config;\n    var data = this.data;\n\n    this.animationIsPlaying = false;\n\n    if (!this.data.enabled) { return; }\n\n    if (!data.property) { return; }\n\n    // Base config.\n    config.autoplay = false;\n    config.direction = data.dir;\n    config.duration = data.dur;\n    config.easing = data.easing;\n    config.elasticity = data.elasticity;\n    config.loop = data.loop;\n    config.round = data.round;\n\n    // Start new animation.\n    this.createAndStartAnimation();\n  },\n\n  tick: function (t, dt) {\n    if (!this.animationIsPlaying) { return; }\n    this.time += dt;\n    this.animation.tick(this.time);\n  },\n\n  remove: function () {\n    this.pauseAnimation();\n    this.removeEventListeners();\n  },\n\n  pause: function () {\n    this.paused = true;\n    this.pausedWasPlaying = this.animationIsPlaying;\n    this.pauseAnimation();\n    this.removeEventListeners();\n  },\n\n  /**\n   * `play` handler only for resuming scene.\n   */\n  play: function () {\n    if (!this.paused) { return; }\n    this.paused = false;\n    this.addEventListeners();\n    if (this.pausedWasPlaying) {\n      this.resumeAnimation();\n      this.pausedWasPlaying = false;\n    }\n  },\n\n  /**\n   * Start animation from scratch.\n   */\n  createAndStartAnimation: function () {\n    var data = this.data;\n\n    this.updateConfig();\n    this.animationIsPlaying = false;\n    this.animation = anime(this.config);\n    this.animation.began = true;\n\n    this.removeEventListeners();\n    this.addEventListeners();\n\n    // Wait for start events for animation.\n    if (!data.autoplay || data.startEvents && data.startEvents.length) { return; }\n\n    // Delay animation.\n    if (data.delay) {\n      setTimeout(this.beginAnimation, data.delay);\n      return;\n    }\n\n    // Play animation.\n    this.beginAnimation();\n  },\n\n  /**\n   * This is before animation start (including from startEvents).\n   * Set to initial state (config.from, time = 0, seekTime = 0).\n   */\n  beginAnimation: function () {\n    this.updateConfig();\n    this.animation.began = true;\n    this.time = 0;\n    this.animationIsPlaying = true;\n    this.stopRelatedAnimations();\n    this.el.emit('animationbegin', this.eventDetail, false);\n  },\n\n  pauseAnimation: function () {\n    this.animationIsPlaying = false;\n  },\n\n  resumeAnimation: function () {\n    this.animationIsPlaying = true;\n  },\n\n  /**\n   * startEvents callback.\n   */\n  onStartEvent: function () {\n    if (!this.data.enabled) { return; }\n\n    this.updateConfig();\n    if (this.animation) {\n      this.animation.pause();\n    }\n    this.animation = anime(this.config);\n\n    // Include the delay before each start event.\n    if (this.data.delay) {\n      setTimeout(this.beginAnimation, this.data.delay);\n      return;\n    }\n    this.beginAnimation();\n  },\n\n  /**\n   * rawProperty: true and type: color;\n   */\n  updateConfigForRawColor: function () {\n    var config = this.config;\n    var data = this.data;\n    var el = this.el;\n    var from;\n    var key;\n    var to;\n\n    if (this.waitComponentInitRawProperty(this.updateConfigForRawColor)) {\n      return;\n    }\n\n    from = data.from === '' ? getRawProperty(el, data.property) : data.from;\n    to = data.to;\n\n    // Use r/g/b vector for color type.\n    this.setColorConfig(from, to);\n    from = this.fromColor;\n    to = this.toColor;\n\n    this.targetsArray.length = 0;\n    this.targetsArray.push(from);\n    config.targets = this.targetsArray;\n    for (key in to) { config[key] = to[key]; }\n\n    config.update = (function () {\n      var lastValue = {};\n      return function (anim) {\n        var value;\n        value = anim.animatables[0].target;\n        // For animation timeline.\n        if (value.r === lastValue.r &&\n            value.g === lastValue.g &&\n            value.b === lastValue.b) { return; }\n\n        setRawProperty(el, data.property, value, data.type);\n      };\n    })();\n  },\n\n  /**\n   * Stuff property into generic `property` key.\n   */\n  updateConfigForDefault: function () {\n    var config = this.config;\n    var data = this.data;\n    var el = this.el;\n    var from;\n    var isBoolean;\n    var isNumber;\n    var to;\n\n    if (this.waitComponentInitRawProperty(this.updateConfigForDefault)) {\n      return;\n    }\n\n    if (data.from === '') {\n      // Infer from.\n      from = isRawProperty(data)\n        ? getRawProperty(el, data.property)\n        : getComponentProperty(el, data.property);\n    } else {\n      // Explicit from.\n      from = data.from;\n    }\n\n    to = data.to;\n\n    isNumber = !isNaN(from || to);\n    if (isNumber) {\n      from = parseFloat(from);\n      to = parseFloat(to);\n    } else {\n      from = from ? from.toString() : from;\n      to = to ? to.toString() : to;\n    }\n\n    // Convert booleans to integer to allow boolean flipping.\n    isBoolean = data.to === 'true' || data.to === 'false' ||\n                data.to === true || data.to === false;\n    if (isBoolean) {\n      from = data.from === 'true' || data.from === true ? 1 : 0;\n      to = data.to === 'true' || data.to === true ? 1 : 0;\n    }\n\n    this.targets.aframeProperty = from;\n    config.targets = this.targets;\n    config.aframeProperty = to;\n    config.update = (function () {\n      var lastValue;\n\n      return function (anim) {\n        var value;\n        value = anim.animatables[0].target.aframeProperty;\n\n        // Need to do a last value check for animation timeline since all the tweening\n        // begins simultaenously even if the value has not changed. Also better for perf\n        // anyways.\n        if (value === lastValue) { return; }\n        lastValue = value;\n\n        if (isBoolean) { value = value >= 1; }\n\n        if (isRawProperty(data)) {\n          setRawProperty(el, data.property, value, data.type);\n        } else {\n          setComponentProperty(el, data.property, value);\n        }\n      };\n    })();\n  },\n\n  /**\n   * Extend x/y/z/w onto the config.\n   * Update vector by modifying object3D.\n   */\n  updateConfigForVector: function () {\n    var config = this.config;\n    var data = this.data;\n    var el = this.el;\n    var key;\n    var from;\n    var to;\n\n    // Parse coordinates.\n    from = data.from !== ''\n      ? utils.coordinates.parse(data.from)  // If data.from defined, use that.\n      : getComponentProperty(el, data.property);  // If data.from not defined, get on the fly.\n    to = utils.coordinates.parse(data.to);\n\n    if (data.property === PROP_ROTATION) {\n      toRadians(from);\n      toRadians(to);\n    }\n\n    // Set to and from.\n    this.targetsArray.length = 0;\n    this.targetsArray.push(from);\n    config.targets = this.targetsArray;\n    for (key in to) { config[key] = to[key]; }\n\n    // If animating object3D transformation, run more optimized updater.\n    if (data.property === PROP_POSITION || data.property === PROP_ROTATION ||\n        data.property === PROP_SCALE) {\n      config.update = (function () {\n        var lastValue = {};\n        return function (anim) {\n          var value = anim.animatables[0].target;\n\n          if (data.property === PROP_SCALE) {\n            value.x = Math.max(0.0001, value.x);\n            value.y = Math.max(0.0001, value.y);\n            value.z = Math.max(0.0001, value.z);\n          }\n\n          // For animation timeline.\n          if (value.x === lastValue.x &&\n              value.y === lastValue.y &&\n              value.z === lastValue.z) { return; }\n\n          lastValue.x = value.x;\n          lastValue.y = value.y;\n          lastValue.z = value.z;\n\n          el.object3D[data.property].set(value.x, value.y, value.z);\n        };\n      })();\n      return;\n    }\n\n    // Animating some vector.\n    config.update = (function () {\n      var lastValue = {};\n      return function (anim) {\n        var value = anim.animatables[0].target;\n\n        // Animate rotation through radians.\n        // For animation timeline.\n        if (value.x === lastValue.x &&\n            value.y === lastValue.y &&\n            value.z === lastValue.z) { return; }\n        lastValue.x = value.x;\n        lastValue.y = value.y;\n        lastValue.z = value.z;\n        setComponentProperty(el, data.property, value);\n      };\n    })();\n  },\n\n  /**\n   * Update the config before each run.\n   */\n  updateConfig: function () {\n    var propType;\n\n    // Route config type.\n    propType = getPropertyType(this.el, this.data.property);\n    if (isRawProperty(this.data) && this.data.type === TYPE_COLOR) {\n      this.updateConfigForRawColor();\n    } else if (propType === 'vec2' || propType === 'vec3' || propType === 'vec4') {\n      this.updateConfigForVector();\n    } else {\n      this.updateConfigForDefault();\n    }\n  },\n\n  /**\n   * Wait for component to initialize.\n   */\n  waitComponentInitRawProperty: function (cb) {\n    var componentName;\n    var data = this.data;\n    var el = this.el;\n    var self = this;\n\n    if (data.from !== '') { return false; }\n\n    if (!data.property.startsWith(STRING_COMPONENTS)) { return false; }\n\n    componentName = splitDot(data.property)[1];\n    if (el.components[componentName]) { return false; }\n\n    el.addEventListener('componentinitialized', function wait (evt) {\n      if (evt.detail.name !== componentName) { return; }\n      cb();\n      // Since the config was created async, create the animation now since we missed it\n      // earlier.\n      self.animation = anime(self.config);\n      el.removeEventListener('componentinitialized', wait);\n    });\n    return true;\n  },\n\n  /**\n   * Make sure two animations on the same property don't fight each other.\n   * e.g., animation__mouseenter=\"property: material.opacity\"\n   *       animation__mouseleave=\"property: material.opacity\"\n   */\n  stopRelatedAnimations: function () {\n    var component;\n    var componentName;\n    for (componentName in this.el.components) {\n      component = this.el.components[componentName];\n      if (componentName === this.attrName) { continue; }\n      if (component.name !== 'animation') { continue; }\n      if (!component.animationIsPlaying) { continue; }\n      if (component.data.property !== this.data.property) { continue; }\n      component.animationIsPlaying = false;\n    }\n  },\n\n  addEventListeners: function () {\n    var data = this.data;\n    var el = this.el;\n    addEventListeners(el, data.startEvents, this.onStartEvent);\n    addEventListeners(el, data.pauseEvents, this.pauseAnimation);\n    addEventListeners(el, data.resumeEvents, this.resumeAnimation);\n  },\n\n  removeEventListeners: function () {\n    var data = this.data;\n    var el = this.el;\n    removeEventListeners(el, data.startEvents, this.onStartEvent);\n    removeEventListeners(el, data.pauseEvents, this.pauseAnimation);\n    removeEventListeners(el, data.resumeEvents, this.resumeAnimation);\n  },\n\n  setColorConfig: function (from, to) {\n    colorHelperFrom.set(from);\n    colorHelperTo.set(to);\n    from = this.fromColor;\n    to = this.toColor;\n    from.r = colorHelperFrom.r;\n    from.g = colorHelperFrom.g;\n    from.b = colorHelperFrom.b;\n    to.r = colorHelperTo.r;\n    to.g = colorHelperTo.g;\n    to.b = colorHelperTo.b;\n  }\n});\n\n/**\n * Given property name, check schema to see what type we are animating.\n * We just care whether the property is a vector.\n */\nfunction getPropertyType (el, property) {\n  var component;\n  var componentName;\n  var split;\n  var propertyName;\n\n  split = property.split('.');\n  componentName = split[0];\n  propertyName = split[1];\n  component = el.components[componentName] || components[componentName];\n\n  // Primitives.\n  if (!component) { return null; }\n\n  // Dynamic schema. We only care about vectors anyways.\n  if (propertyName && !component.schema[propertyName]) { return null; }\n\n  // Multi-prop.\n  if (propertyName) { return component.schema[propertyName].type; }\n\n  // Single-prop.\n  return component.schema.type;\n}\n\n/**\n * Convert object to radians.\n */\nfunction toRadians (obj) {\n  obj.x = THREE.Math.degToRad(obj.x);\n  obj.y = THREE.Math.degToRad(obj.y);\n  obj.z = THREE.Math.degToRad(obj.z);\n}\n\nfunction addEventListeners (el, eventNames, handler) {\n  var i;\n  for (i = 0; i < eventNames.length; i++) {\n    el.addEventListener(eventNames[i], handler);\n  }\n}\n\nfunction removeEventListeners (el, eventNames, handler) {\n  var i;\n  for (i = 0; i < eventNames.length; i++) {\n    el.removeEventListener(eventNames[i], handler);\n  }\n}\n\nfunction getRawProperty (el, path) {\n  var i;\n  var split;\n  var value;\n  split = splitDot(path);\n  value = el;\n  for (i = 0; i < split.length; i++) {\n    value = value[split[i]];\n  }\n  if (value === undefined) {\n    console.log(el);\n    throw new Error('[animation] property (' + path + ') could not be found');\n  }\n  return value;\n}\n\nfunction setRawProperty (el, path, value, type) {\n  var i;\n  var split;\n  var propertyName;\n  var targetValue;\n\n  if (path.startsWith('object3D.rotation')) {\n    value = THREE.Math.degToRad(value);\n  }\n\n  // Walk.\n  split = splitDot(path);\n  targetValue = el;\n  for (i = 0; i < split.length - 1; i++) { targetValue = targetValue[split[i]]; }\n  propertyName = split[split.length - 1];\n\n  // Raw color.\n  if (type === TYPE_COLOR) {\n    if ('r' in targetValue[propertyName]) {\n      targetValue[propertyName].r = value.r;\n      targetValue[propertyName].g = value.g;\n      targetValue[propertyName].b = value.b;\n    } else {\n      targetValue[propertyName].x = value.r;\n      targetValue[propertyName].y = value.g;\n      targetValue[propertyName].z = value.b;\n    }\n    return;\n  }\n\n  targetValue[propertyName] = value;\n}\n\nfunction splitDot (path) {\n  if (path in splitCache) { return splitCache[path]; }\n  splitCache[path] = path.split('.');\n  return splitCache[path];\n}\n\nfunction isRawProperty (data) {\n  return data.isRawProperty || data.property.startsWith(STRING_COMPONENTS) ||\n         data.property.startsWith(STRING_OBJECT3D);\n}\n"]},"metadata":{},"sourceType":"script"}