{"ast":null,"code":"/* global ImageData, URL */\nvar registerComponent = require('../../core/component').registerComponent;\n\nvar THREE = require('../../lib/three');\n\nvar VERTEX_SHADER = ['attribute vec3 position;', 'attribute vec2 uv;', 'uniform mat4 projectionMatrix;', 'uniform mat4 modelViewMatrix;', 'varying vec2 vUv;', 'void main()  {', '  vUv = vec2( 1.- uv.x, uv.y );', '  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\\n');\nvar FRAGMENT_SHADER = ['precision mediump float;', 'uniform samplerCube map;', 'varying vec2 vUv;', '#define M_PI 3.141592653589793238462643383279', 'void main() {', '  vec2 uv = vUv;', '  float longitude = uv.x * 2. * M_PI - M_PI + M_PI / 2.;', '  float latitude = uv.y * M_PI;', '  vec3 dir = vec3(', '    - sin( longitude ) * sin( latitude ),', '    cos( latitude ),', '    - cos( longitude ) * sin( latitude )', '  );', '  normalize( dir );', '  gl_FragColor = vec4( textureCube( map, dir ).rgb, 1.0 );', '}'].join('\\n');\n/**\n * Component to take screenshots of the scene using a keboard shortcut (alt+s).\n * It can be configured to either take 360&deg; captures (`equirectangular`)\n * or regular screenshots (`projection`)\n *\n * This is based on https://github.com/spite/THREE.CubemapToEquirectangular\n * To capture an equirectangular projection of the scene a THREE.CubeCamera is used\n * The cube map produced by the CubeCamera is projected on a quad and then rendered to\n * WebGLRenderTarget with an ortographic camera.\n */\n\nmodule.exports.Component = registerComponent('screenshot', {\n  schema: {\n    width: {\n      default: 4096\n    },\n    height: {\n      default: 2048\n    },\n    camera: {\n      type: 'selector'\n    }\n  },\n  init: function () {\n    var el = this.el;\n    var self = this;\n\n    if (el.renderer) {\n      setup();\n    } else {\n      el.addEventListener('render-target-loaded', setup);\n    }\n\n    function setup() {\n      var gl = el.renderer.getContext();\n\n      if (!gl) {\n        return;\n      }\n\n      self.cubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);\n      self.material = new THREE.RawShaderMaterial({\n        uniforms: {\n          map: {\n            type: 't',\n            value: null\n          }\n        },\n        vertexShader: VERTEX_SHADER,\n        fragmentShader: FRAGMENT_SHADER,\n        side: THREE.DoubleSide\n      });\n      self.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(1, 1), self.material);\n      self.quad.visible = false;\n      self.camera = new THREE.OrthographicCamera(-1 / 2, 1 / 2, 1 / 2, -1 / 2, -10000, 10000);\n      self.canvas = document.createElement('canvas');\n      self.ctx = self.canvas.getContext('2d');\n      el.object3D.add(self.quad);\n      self.onKeyDown = self.onKeyDown.bind(self);\n    }\n  },\n  getRenderTarget: function (width, height) {\n    return new THREE.WebGLRenderTarget(width, height, {\n      minFilter: THREE.LinearFilter,\n      magFilter: THREE.LinearFilter,\n      wrapS: THREE.ClampToEdgeWrapping,\n      wrapT: THREE.ClampToEdgeWrapping,\n      format: THREE.RGBAFormat,\n      type: THREE.UnsignedByteType\n    });\n  },\n  resize: function (width, height) {\n    // Resize quad.\n    this.quad.scale.set(width, height, 1); // Resize camera.\n\n    this.camera.left = -1 * width / 2;\n    this.camera.right = width / 2;\n    this.camera.top = height / 2;\n    this.camera.bottom = -1 * height / 2;\n    this.camera.updateProjectionMatrix(); // Resize canvas.\n\n    this.canvas.width = width;\n    this.canvas.height = height;\n  },\n  play: function () {\n    window.addEventListener('keydown', this.onKeyDown);\n  },\n\n  /**\n   * <ctrl> + <alt> + s = Regular screenshot.\n   * <ctrl> + <alt> + <shift> + s = Equirectangular screenshot.\n  */\n  onKeyDown: function (evt) {\n    var shortcutPressed = evt.keyCode === 83 && evt.ctrlKey && evt.altKey;\n\n    if (!this.data || !shortcutPressed) {\n      return;\n    }\n\n    var projection = evt.shiftKey ? 'equirectangular' : 'perspective';\n    this.capture(projection);\n  },\n\n  /**\n   * Capture a screenshot of the scene.\n   *\n   * @param {string} projection - Screenshot projection (equirectangular or perspective).\n   */\n  setCapture: function (projection) {\n    var el = this.el;\n    var size;\n    var camera;\n    var cubeCamera; // Configure camera.\n\n    if (projection === 'perspective') {\n      // Quad is only used in equirectangular mode. Hide it in this case.\n      this.quad.visible = false; // Use scene camera.\n\n      camera = this.data.camera && this.data.camera.components.camera.camera || el.camera;\n      size = {\n        width: this.data.width,\n        height: this.data.height\n      };\n    } else {\n      // Use ortho camera.\n      camera = this.camera; // Create cube camera and copy position from scene camera.\n\n      cubeCamera = new THREE.CubeCamera(el.camera.near, el.camera.far, Math.min(this.cubeMapSize, 2048)); // Copy camera position into cube camera;\n\n      el.camera.getWorldPosition(cubeCamera.position);\n      el.camera.getWorldQuaternion(cubeCamera.quaternion); // Render scene with cube camera.\n\n      cubeCamera.update(el.renderer, el.object3D);\n      this.quad.material.uniforms.map.value = cubeCamera.renderTarget.texture;\n      size = {\n        width: this.data.width,\n        height: this.data.height\n      }; // Use quad to project image taken by the cube camera.\n\n      this.quad.visible = true;\n    }\n\n    return {\n      camera: camera,\n      size: size,\n      projection: projection\n    };\n  },\n\n  /**\n   * Maintained for backwards compatibility.\n   */\n  capture: function (projection) {\n    var isVREnabled = this.el.renderer.xr.enabled;\n    var renderer = this.el.renderer;\n    var params; // Disable VR.\n\n    renderer.xr.enabled = false;\n    params = this.setCapture(projection);\n    this.renderCapture(params.camera, params.size, params.projection); // Trigger file download.\n\n    this.saveCapture(); // Restore VR.\n\n    renderer.xr.enabled = isVREnabled;\n  },\n\n  /**\n   * Return canvas instead of triggering download (e.g., for uploading blob to server).\n   */\n  getCanvas: function (projection) {\n    var isVREnabled = this.el.renderer.xr.enabled;\n    var renderer = this.el.renderer; // Disable VR.\n\n    var params = this.setCapture(projection);\n    renderer.xr.enabled = false;\n    this.renderCapture(params.camera, params.size, params.projection); // Restore VR.\n\n    renderer.xr.enabled = isVREnabled;\n    return this.canvas;\n  },\n  renderCapture: function (camera, size, projection) {\n    var autoClear = this.el.renderer.autoClear;\n    var el = this.el;\n    var imageData;\n    var output;\n    var pixels;\n    var renderer = el.renderer; // Create rendering target and buffer to store the read pixels.\n\n    output = this.getRenderTarget(size.width, size.height);\n    pixels = new Uint8Array(4 * size.width * size.height); // Resize quad, camera, and canvas.\n\n    this.resize(size.width, size.height); // Render scene to render target.\n\n    renderer.autoClear = true;\n    renderer.clear();\n    renderer.setRenderTarget(output);\n    renderer.render(el.object3D, camera);\n    renderer.autoClear = autoClear; // Read image pizels back.\n\n    renderer.readRenderTargetPixels(output, 0, 0, size.width, size.height, pixels);\n    renderer.setRenderTarget(null);\n\n    if (projection === 'perspective') {\n      pixels = this.flipPixelsVertically(pixels, size.width, size.height);\n    }\n\n    imageData = new ImageData(new Uint8ClampedArray(pixels), size.width, size.height); // Hide quad after projecting the image.\n\n    this.quad.visible = false; // Copy pixels into canvas.\n\n    this.ctx.putImageData(imageData, 0, 0);\n  },\n  flipPixelsVertically: function (pixels, width, height) {\n    var flippedPixels = pixels.slice(0);\n\n    for (var x = 0; x < width; ++x) {\n      for (var y = 0; y < height; ++y) {\n        flippedPixels[x * 4 + y * width * 4] = pixels[x * 4 + (height - y) * width * 4];\n        flippedPixels[x * 4 + 1 + y * width * 4] = pixels[x * 4 + 1 + (height - y) * width * 4];\n        flippedPixels[x * 4 + 2 + y * width * 4] = pixels[x * 4 + 2 + (height - y) * width * 4];\n        flippedPixels[x * 4 + 3 + y * width * 4] = pixels[x * 4 + 3 + (height - y) * width * 4];\n      }\n    }\n\n    return flippedPixels;\n  },\n\n  /**\n   * Download capture to file.\n   */\n  saveCapture: function () {\n    this.canvas.toBlob(function (blob) {\n      var fileName = 'screenshot-' + document.title.toLowerCase() + '-' + Date.now() + '.png';\n      var linkEl = document.createElement('a');\n      var url = URL.createObjectURL(blob);\n      linkEl.href = url;\n      linkEl.setAttribute('download', fileName);\n      linkEl.innerHTML = 'downloading...';\n      linkEl.style.display = 'none';\n      document.body.appendChild(linkEl);\n      setTimeout(function () {\n        linkEl.click();\n        document.body.removeChild(linkEl);\n      }, 1);\n    }, 'image/png');\n  }\n});","map":{"version":3,"sources":["C:/Users/Hannuri/Desktop/RoyalCyber/my-first-app/node_modules/aframe/src/components/scene/screenshot.js"],"names":["registerComponent","require","THREE","VERTEX_SHADER","join","FRAGMENT_SHADER","module","exports","Component","schema","width","default","height","camera","type","init","el","self","renderer","setup","addEventListener","gl","getContext","cubeMapSize","getParameter","MAX_CUBE_MAP_TEXTURE_SIZE","material","RawShaderMaterial","uniforms","map","value","vertexShader","fragmentShader","side","DoubleSide","quad","Mesh","PlaneBufferGeometry","visible","OrthographicCamera","canvas","document","createElement","ctx","object3D","add","onKeyDown","bind","getRenderTarget","WebGLRenderTarget","minFilter","LinearFilter","magFilter","wrapS","ClampToEdgeWrapping","wrapT","format","RGBAFormat","UnsignedByteType","resize","scale","set","left","right","top","bottom","updateProjectionMatrix","play","window","evt","shortcutPressed","keyCode","ctrlKey","altKey","data","projection","shiftKey","capture","setCapture","size","cubeCamera","components","CubeCamera","near","far","Math","min","getWorldPosition","position","getWorldQuaternion","quaternion","update","renderTarget","texture","isVREnabled","xr","enabled","params","renderCapture","saveCapture","getCanvas","autoClear","imageData","output","pixels","Uint8Array","clear","setRenderTarget","render","readRenderTargetPixels","flipPixelsVertically","ImageData","Uint8ClampedArray","putImageData","flippedPixels","slice","x","y","toBlob","blob","fileName","title","toLowerCase","Date","now","linkEl","url","URL","createObjectURL","href","setAttribute","innerHTML","style","display","body","appendChild","setTimeout","click","removeChild"],"mappings":"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","sourcesContent":["/* global ImageData, URL */\nvar registerComponent = require('../../core/component').registerComponent;\nvar THREE = require('../../lib/three');\n\nvar VERTEX_SHADER = [\n  'attribute vec3 position;',\n  'attribute vec2 uv;',\n  'uniform mat4 projectionMatrix;',\n  'uniform mat4 modelViewMatrix;',\n  'varying vec2 vUv;',\n  'void main()  {',\n  '  vUv = vec2( 1.- uv.x, uv.y );',\n  '  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n  '}'\n].join('\\n');\n\nvar FRAGMENT_SHADER = [\n  'precision mediump float;',\n  'uniform samplerCube map;',\n  'varying vec2 vUv;',\n  '#define M_PI 3.141592653589793238462643383279',\n  'void main() {',\n  '  vec2 uv = vUv;',\n  '  float longitude = uv.x * 2. * M_PI - M_PI + M_PI / 2.;',\n  '  float latitude = uv.y * M_PI;',\n  '  vec3 dir = vec3(',\n  '    - sin( longitude ) * sin( latitude ),',\n  '    cos( latitude ),',\n  '    - cos( longitude ) * sin( latitude )',\n  '  );',\n  '  normalize( dir );',\n  '  gl_FragColor = vec4( textureCube( map, dir ).rgb, 1.0 );',\n  '}'\n].join('\\n');\n\n/**\n * Component to take screenshots of the scene using a keboard shortcut (alt+s).\n * It can be configured to either take 360&deg; captures (`equirectangular`)\n * or regular screenshots (`projection`)\n *\n * This is based on https://github.com/spite/THREE.CubemapToEquirectangular\n * To capture an equirectangular projection of the scene a THREE.CubeCamera is used\n * The cube map produced by the CubeCamera is projected on a quad and then rendered to\n * WebGLRenderTarget with an ortographic camera.\n */\nmodule.exports.Component = registerComponent('screenshot', {\n  schema: {\n    width: {default: 4096},\n    height: {default: 2048},\n    camera: {type: 'selector'}\n  },\n\n  init: function () {\n    var el = this.el;\n    var self = this;\n\n    if (el.renderer) {\n      setup();\n    } else {\n      el.addEventListener('render-target-loaded', setup);\n    }\n\n    function setup () {\n      var gl = el.renderer.getContext();\n      if (!gl) { return; }\n      self.cubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);\n      self.material = new THREE.RawShaderMaterial({\n        uniforms: {map: {type: 't', value: null}},\n        vertexShader: VERTEX_SHADER,\n        fragmentShader: FRAGMENT_SHADER,\n        side: THREE.DoubleSide\n      });\n      self.quad = new THREE.Mesh(\n        new THREE.PlaneBufferGeometry(1, 1),\n        self.material\n      );\n      self.quad.visible = false;\n      self.camera = new THREE.OrthographicCamera(-1 / 2, 1 / 2, 1 / 2, -1 / 2, -10000, 10000);\n      self.canvas = document.createElement('canvas');\n      self.ctx = self.canvas.getContext('2d');\n      el.object3D.add(self.quad);\n      self.onKeyDown = self.onKeyDown.bind(self);\n    }\n  },\n\n  getRenderTarget: function (width, height) {\n    return new THREE.WebGLRenderTarget(width, height, {\n      minFilter: THREE.LinearFilter,\n      magFilter: THREE.LinearFilter,\n      wrapS: THREE.ClampToEdgeWrapping,\n      wrapT: THREE.ClampToEdgeWrapping,\n      format: THREE.RGBAFormat,\n      type: THREE.UnsignedByteType\n    });\n  },\n\n  resize: function (width, height) {\n    // Resize quad.\n    this.quad.scale.set(width, height, 1);\n\n    // Resize camera.\n    this.camera.left = -1 * width / 2;\n    this.camera.right = width / 2;\n    this.camera.top = height / 2;\n    this.camera.bottom = -1 * height / 2;\n    this.camera.updateProjectionMatrix();\n\n    // Resize canvas.\n    this.canvas.width = width;\n    this.canvas.height = height;\n  },\n\n  play: function () {\n    window.addEventListener('keydown', this.onKeyDown);\n  },\n\n  /**\n   * <ctrl> + <alt> + s = Regular screenshot.\n   * <ctrl> + <alt> + <shift> + s = Equirectangular screenshot.\n  */\n  onKeyDown: function (evt) {\n    var shortcutPressed = evt.keyCode === 83 && evt.ctrlKey && evt.altKey;\n    if (!this.data || !shortcutPressed) { return; }\n    var projection = evt.shiftKey ? 'equirectangular' : 'perspective';\n    this.capture(projection);\n  },\n\n  /**\n   * Capture a screenshot of the scene.\n   *\n   * @param {string} projection - Screenshot projection (equirectangular or perspective).\n   */\n  setCapture: function (projection) {\n    var el = this.el;\n    var size;\n    var camera;\n    var cubeCamera;\n    // Configure camera.\n    if (projection === 'perspective') {\n      // Quad is only used in equirectangular mode. Hide it in this case.\n      this.quad.visible = false;\n      // Use scene camera.\n      camera = (this.data.camera && this.data.camera.components.camera.camera) || el.camera;\n      size = {width: this.data.width, height: this.data.height};\n    } else {\n      // Use ortho camera.\n      camera = this.camera;\n      // Create cube camera and copy position from scene camera.\n      cubeCamera = new THREE.CubeCamera(el.camera.near, el.camera.far,\n                                        Math.min(this.cubeMapSize, 2048));\n      // Copy camera position into cube camera;\n      el.camera.getWorldPosition(cubeCamera.position);\n      el.camera.getWorldQuaternion(cubeCamera.quaternion);\n      // Render scene with cube camera.\n      cubeCamera.update(el.renderer, el.object3D);\n      this.quad.material.uniforms.map.value = cubeCamera.renderTarget.texture;\n      size = {width: this.data.width, height: this.data.height};\n      // Use quad to project image taken by the cube camera.\n      this.quad.visible = true;\n    }\n    return {\n      camera: camera,\n      size: size,\n      projection: projection\n    };\n  },\n\n  /**\n   * Maintained for backwards compatibility.\n   */\n  capture: function (projection) {\n    var isVREnabled = this.el.renderer.xr.enabled;\n    var renderer = this.el.renderer;\n    var params;\n    // Disable VR.\n    renderer.xr.enabled = false;\n    params = this.setCapture(projection);\n    this.renderCapture(params.camera, params.size, params.projection);\n    // Trigger file download.\n    this.saveCapture();\n    // Restore VR.\n    renderer.xr.enabled = isVREnabled;\n  },\n\n  /**\n   * Return canvas instead of triggering download (e.g., for uploading blob to server).\n   */\n  getCanvas: function (projection) {\n    var isVREnabled = this.el.renderer.xr.enabled;\n    var renderer = this.el.renderer;\n    // Disable VR.\n    var params = this.setCapture(projection);\n    renderer.xr.enabled = false;\n    this.renderCapture(params.camera, params.size, params.projection);\n    // Restore VR.\n    renderer.xr.enabled = isVREnabled;\n    return this.canvas;\n  },\n\n  renderCapture: function (camera, size, projection) {\n    var autoClear = this.el.renderer.autoClear;\n    var el = this.el;\n    var imageData;\n    var output;\n    var pixels;\n    var renderer = el.renderer;\n    // Create rendering target and buffer to store the read pixels.\n    output = this.getRenderTarget(size.width, size.height);\n    pixels = new Uint8Array(4 * size.width * size.height);\n    // Resize quad, camera, and canvas.\n    this.resize(size.width, size.height);\n    // Render scene to render target.\n    renderer.autoClear = true;\n    renderer.clear();\n    renderer.setRenderTarget(output);\n    renderer.render(el.object3D, camera);\n    renderer.autoClear = autoClear;\n    // Read image pizels back.\n    renderer.readRenderTargetPixels(output, 0, 0, size.width, size.height, pixels);\n    renderer.setRenderTarget(null);\n    if (projection === 'perspective') {\n      pixels = this.flipPixelsVertically(pixels, size.width, size.height);\n    }\n    imageData = new ImageData(new Uint8ClampedArray(pixels), size.width, size.height);\n    // Hide quad after projecting the image.\n    this.quad.visible = false;\n    // Copy pixels into canvas.\n    this.ctx.putImageData(imageData, 0, 0);\n  },\n\n  flipPixelsVertically: function (pixels, width, height) {\n    var flippedPixels = pixels.slice(0);\n    for (var x = 0; x < width; ++x) {\n      for (var y = 0; y < height; ++y) {\n        flippedPixels[x * 4 + y * width * 4] = pixels[x * 4 + (height - y) * width * 4];\n        flippedPixels[x * 4 + 1 + y * width * 4] = pixels[x * 4 + 1 + (height - y) * width * 4];\n        flippedPixels[x * 4 + 2 + y * width * 4] = pixels[x * 4 + 2 + (height - y) * width * 4];\n        flippedPixels[x * 4 + 3 + y * width * 4] = pixels[x * 4 + 3 + (height - y) * width * 4];\n      }\n    }\n    return flippedPixels;\n  },\n\n  /**\n   * Download capture to file.\n   */\n  saveCapture: function () {\n    this.canvas.toBlob(function (blob) {\n      var fileName = 'screenshot-' + document.title.toLowerCase() + '-' + Date.now() + '.png';\n      var linkEl = document.createElement('a');\n      var url = URL.createObjectURL(blob);\n      linkEl.href = url;\n      linkEl.setAttribute('download', fileName);\n      linkEl.innerHTML = 'downloading...';\n      linkEl.style.display = 'none';\n      document.body.appendChild(linkEl);\n      setTimeout(function () {\n        linkEl.click();\n        document.body.removeChild(linkEl);\n      }, 1);\n    }, 'image/png');\n  }\n});\n"]},"metadata":{},"sourceType":"script"}