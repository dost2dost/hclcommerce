{"ast":null,"code":"var createTextGeometry = require('three-bmfont-text');\n\nvar loadBMFont = require('load-bmfont');\n\nvar registerComponent = require('../core/component').registerComponent;\n\nvar coreShader = require('../core/shader');\n\nvar THREE = require('../lib/three');\n\nvar utils = require('../utils/');\n\nvar error = utils.debug('components:text:error');\nvar shaders = coreShader.shaders;\nvar warn = utils.debug('components:text:warn'); // 1 to match other A-Frame default widths.\n\nvar DEFAULT_WIDTH = 1; // @bryik set anisotropy to 16. Improves look of large amounts of text when viewed from angle.\n\nvar MAX_ANISOTROPY = 16;\nvar FONT_BASE_URL = 'https://cdn.aframe.io/fonts/';\nvar FONTS = {\n  aileronsemibold: FONT_BASE_URL + 'Aileron-Semibold.fnt',\n  dejavu: FONT_BASE_URL + 'DejaVu-sdf.fnt',\n  exo2bold: FONT_BASE_URL + 'Exo2Bold.fnt',\n  exo2semibold: FONT_BASE_URL + 'Exo2SemiBold.fnt',\n  kelsonsans: FONT_BASE_URL + 'KelsonSans.fnt',\n  monoid: FONT_BASE_URL + 'Monoid.fnt',\n  mozillavr: FONT_BASE_URL + 'mozillavr.fnt',\n  roboto: FONT_BASE_URL + 'Roboto-msdf.json',\n  sourcecodepro: FONT_BASE_URL + 'SourceCodePro.fnt'\n};\nvar MSDF_FONTS = ['roboto'];\nvar DEFAULT_FONT = 'roboto';\nmodule.exports.FONTS = FONTS;\nvar cache = new PromiseCache();\nvar fontWidthFactors = {};\nvar textures = {}; // Regular expression for detecting a URLs with a protocol prefix.\n\nvar protocolRe = /^\\w+:/;\n/**\n * SDF-based text component.\n * Based on https://github.com/Jam3/three-bmfont-text.\n *\n * All the stock fonts are for the `sdf` registered shader, an improved version of jam3's\n * original `sdf` shader.\n */\n\nmodule.exports.Component = registerComponent('text', {\n  multiple: true,\n  schema: {\n    align: {\n      type: 'string',\n      default: 'left',\n      oneOf: ['left', 'right', 'center']\n    },\n    alphaTest: {\n      default: 0.5\n    },\n    // `anchor` defaults to center to match geometries.\n    anchor: {\n      default: 'center',\n      oneOf: ['left', 'right', 'center', 'align']\n    },\n    baseline: {\n      default: 'center',\n      oneOf: ['top', 'center', 'bottom']\n    },\n    color: {\n      type: 'color',\n      default: '#FFF'\n    },\n    font: {\n      type: 'string',\n      default: DEFAULT_FONT\n    },\n    // `fontImage` defaults to the font name as a .png (e.g., mozillavr.fnt -> mozillavr.png).\n    fontImage: {\n      type: 'string'\n    },\n    // `height` has no default, will be populated at layout.\n    height: {\n      type: 'number'\n    },\n    letterSpacing: {\n      type: 'number',\n      default: 0\n    },\n    // `lineHeight` defaults to font's `lineHeight` value.\n    lineHeight: {\n      type: 'number'\n    },\n    // `negate` must be true for fonts generated with older versions of msdfgen (white background).\n    negate: {\n      type: 'boolean',\n      default: true\n    },\n    opacity: {\n      type: 'number',\n      default: 1.0\n    },\n    shader: {\n      default: 'sdf',\n      oneOf: shaders\n    },\n    side: {\n      default: 'front',\n      oneOf: ['front', 'back', 'double']\n    },\n    tabSize: {\n      default: 4\n    },\n    transparent: {\n      default: true\n    },\n    value: {\n      type: 'string'\n    },\n    whiteSpace: {\n      default: 'normal',\n      oneOf: ['normal', 'pre', 'nowrap']\n    },\n    // `width` defaults to geometry width if present, else `DEFAULT_WIDTH`.\n    width: {\n      type: 'number'\n    },\n    // `wrapCount` units are about one default font character. Wrap roughly at this number.\n    wrapCount: {\n      type: 'number',\n      default: 40\n    },\n    // `wrapPixels` will wrap using bmfont pixel units (e.g., dejavu's is 32 pixels).\n    wrapPixels: {\n      type: 'number'\n    },\n    // `xOffset` to add padding.\n    xOffset: {\n      type: 'number',\n      default: 0\n    },\n    // `yOffset` to adjust generated fonts from tools that may have incorrect metrics.\n    yOffset: {\n      type: 'number',\n      default: 0\n    },\n    // `zOffset` will provide a small z offset to avoid z-fighting.\n    zOffset: {\n      type: 'number',\n      default: 0.001\n    }\n  },\n  init: function () {\n    this.shaderData = {};\n    this.geometry = createTextGeometry();\n    this.createOrUpdateMaterial();\n    this.mesh = new THREE.Mesh(this.geometry, this.material);\n    this.el.setObject3D(this.attrName, this.mesh);\n  },\n  update: function (oldData) {\n    var data = this.data;\n    var font = this.currentFont;\n\n    if (textures[data.font]) {\n      this.texture = textures[data.font];\n    } else {\n      // Create texture per font.\n      this.texture = textures[data.font] = new THREE.Texture();\n      this.texture.anisotropy = MAX_ANISOTROPY;\n    } // Update material.\n\n\n    this.createOrUpdateMaterial(); // New font. `updateFont` will later change data and layout.\n\n    if (oldData.font !== data.font) {\n      this.updateFont();\n      return;\n    } // Update geometry and layout.\n\n\n    if (font) {\n      this.updateGeometry(this.geometry, font);\n      this.updateLayout();\n    }\n  },\n\n  /**\n   * Clean up geometry, material, texture, mesh, objects.\n   */\n  remove: function () {\n    this.geometry.dispose();\n    this.geometry = null;\n    this.el.removeObject3D(this.attrName);\n    this.material.dispose();\n    this.material = null;\n    this.texture.dispose();\n    this.texture = null;\n\n    if (this.shaderObject) {\n      delete this.shaderObject;\n    }\n  },\n\n  /**\n   * Update the shader of the material.\n   */\n  createOrUpdateMaterial: function () {\n    var data = this.data;\n    var hasChangedShader;\n    var material = this.material;\n    var NewShader;\n    var shaderData = this.shaderData;\n    var shaderName; // Infer shader if using a stock font (or from `-msdf` filename convention).\n\n    shaderName = data.shader;\n\n    if (MSDF_FONTS.indexOf(data.font) !== -1 || data.font.indexOf('-msdf.') >= 0) {\n      shaderName = 'msdf';\n    } else if (data.font in FONTS && MSDF_FONTS.indexOf(data.font) === -1) {\n      shaderName = 'sdf';\n    }\n\n    hasChangedShader = (this.shaderObject && this.shaderObject.name) !== shaderName;\n    shaderData.alphaTest = data.alphaTest;\n    shaderData.color = data.color;\n    shaderData.map = this.texture;\n    shaderData.opacity = data.opacity;\n    shaderData.side = parseSide(data.side);\n    shaderData.transparent = data.transparent;\n    shaderData.negate = data.negate; // Shader has not changed, do an update.\n\n    if (!hasChangedShader) {\n      // Update shader material.\n      this.shaderObject.update(shaderData); // Apparently, was not set on `init` nor `update`.\n\n      material.transparent = shaderData.transparent;\n      material.side = shaderData.side;\n      return;\n    } // Shader has changed. Create a shader material.\n\n\n    NewShader = createShader(this.el, shaderName, shaderData);\n    this.material = NewShader.material;\n    this.shaderObject = NewShader.shader; // Set new shader material.\n\n    this.material.side = shaderData.side;\n\n    if (this.mesh) {\n      this.mesh.material = this.material;\n    }\n  },\n\n  /**\n   * Load font for geometry, load font image for material, and apply.\n   */\n  updateFont: function () {\n    var data = this.data;\n    var el = this.el;\n    var fontSrc;\n    var geometry = this.geometry;\n    var self = this;\n\n    if (!data.font) {\n      warn('No font specified. Using the default font.');\n    } // Make invisible during font swap.\n\n\n    this.mesh.visible = false; // Look up font URL to use, and perform cached load.\n\n    fontSrc = this.lookupFont(data.font || DEFAULT_FONT) || data.font;\n    cache.get(fontSrc, function doLoadFont() {\n      return loadFont(fontSrc, data.yOffset);\n    }).then(function setFont(font) {\n      var fontImgSrc;\n\n      if (font.pages.length !== 1) {\n        throw new Error('Currently only single-page bitmap fonts are supported.');\n      }\n\n      if (!fontWidthFactors[fontSrc]) {\n        font.widthFactor = fontWidthFactors[font] = computeFontWidthFactor(font);\n      } // Update geometry given font metrics.\n\n\n      self.updateGeometry(geometry, font); // Set font and update layout.\n\n      self.currentFont = font;\n      self.updateLayout(); // Look up font image URL to use, and perform cached load.\n\n      fontImgSrc = self.getFontImageSrc();\n      cache.get(fontImgSrc, function () {\n        return loadTexture(fontImgSrc);\n      }).then(function (image) {\n        // Make mesh visible and apply font image as texture.\n        var texture = self.texture;\n        texture.image = image;\n        texture.needsUpdate = true;\n        textures[data.font] = texture;\n        self.texture = texture;\n        self.mesh.visible = true;\n        el.emit('textfontset', {\n          font: data.font,\n          fontObj: font\n        });\n      }).catch(function (err) {\n        error(err.message);\n        error(err.stack);\n      });\n    }).catch(function (err) {\n      error(err.message);\n      error(err.stack);\n    });\n  },\n  getFontImageSrc: function () {\n    if (this.data.fontImage) {\n      return this.data.fontImage;\n    }\n\n    var fontSrc = this.lookupFont(this.data.font || DEFAULT_FONT) || this.data.font;\n    var imageSrc = this.currentFont.pages[0]; // If the image URL contains a non-HTTP(S) protocol, assume it's an absolute\n    // path on disk and try to infer the path from the font source instead.\n\n    if (imageSrc.match(protocolRe) && imageSrc.indexOf('http') !== 0) {\n      return fontSrc.replace(/(\\.fnt)|(\\.json)/, '.png');\n    }\n\n    return THREE.LoaderUtils.extractUrlBase(fontSrc) + imageSrc;\n  },\n\n  /**\n   * Update layout with anchor, alignment, baseline, and considering any meshes.\n   */\n  updateLayout: function () {\n    var anchor;\n    var baseline;\n    var el = this.el;\n    var data = this.data;\n    var geometry = this.geometry;\n    var geometryComponent;\n    var height;\n    var layout;\n    var mesh = this.mesh;\n    var textRenderWidth;\n    var textScale;\n    var width;\n    var x;\n    var y;\n\n    if (!geometry.layout) {\n      return;\n    } // Determine width to use (defined width, geometry's width, or default width).\n\n\n    geometryComponent = el.getAttribute('geometry');\n    width = data.width || geometryComponent && geometryComponent.width || DEFAULT_WIDTH; // Determine wrap pixel count. Either specified or by experimental fudge factor.\n    // Note that experimental factor will never be correct for variable width fonts.\n\n    textRenderWidth = computeWidth(data.wrapPixels, data.wrapCount, this.currentFont.widthFactor);\n    textScale = width / textRenderWidth; // Determine height to use.\n\n    layout = geometry.layout;\n    height = textScale * (layout.height + layout.descender); // Update geometry dimensions to match text layout if width and height are set to 0.\n    // For example, scales a plane to fit text.\n\n    if (geometryComponent && geometryComponent.primitive === 'plane') {\n      if (!geometryComponent.width) {\n        el.setAttribute('geometry', 'width', width);\n      }\n\n      if (!geometryComponent.height) {\n        el.setAttribute('geometry', 'height', height);\n      }\n    } // Calculate X position to anchor text left, center, or right.\n\n\n    anchor = data.anchor === 'align' ? data.align : data.anchor;\n\n    if (anchor === 'left') {\n      x = 0;\n    } else if (anchor === 'right') {\n      x = -1 * layout.width;\n    } else if (anchor === 'center') {\n      x = -1 * layout.width / 2;\n    } else {\n      throw new TypeError('Invalid text.anchor property value', anchor);\n    } // Calculate Y position to anchor text top, center, or bottom.\n\n\n    baseline = data.baseline;\n\n    if (baseline === 'bottom') {\n      y = 0;\n    } else if (baseline === 'top') {\n      y = -1 * layout.height + layout.ascender;\n    } else if (baseline === 'center') {\n      y = -1 * layout.height / 2;\n    } else {\n      throw new TypeError('Invalid text.baseline property value', baseline);\n    } // Position and scale mesh to apply layout.\n\n\n    mesh.position.x = x * textScale + data.xOffset;\n    mesh.position.y = y * textScale; // Place text slightly in front to avoid Z-fighting.\n\n    mesh.position.z = data.zOffset;\n    mesh.scale.set(textScale, -1 * textScale, textScale);\n  },\n\n  /**\n   * Grab font from the constant.\n   * Set as a method for test stubbing purposes.\n   */\n  lookupFont: function (key) {\n    return FONTS[key];\n  },\n\n  /**\n   * Update the text geometry using `three-bmfont-text.update`.\n   */\n  updateGeometry: function () {\n    var geometryUpdateBase = {};\n    var geometryUpdateData = {};\n    var newLineRegex = /\\\\n/g;\n    var tabRegex = /\\\\t/g;\n    return function (geometry, font) {\n      var data = this.data;\n      geometryUpdateData.font = font;\n      geometryUpdateData.lineHeight = data.lineHeight && isFinite(data.lineHeight) ? data.lineHeight : font.common.lineHeight;\n      geometryUpdateData.text = data.value.toString().replace(newLineRegex, '\\n').replace(tabRegex, '\\t');\n      geometryUpdateData.width = computeWidth(data.wrapPixels, data.wrapCount, font.widthFactor);\n      geometry.update(utils.extend(geometryUpdateBase, data, geometryUpdateData));\n    };\n  }()\n});\n/**\n * Due to using negative scale, we return the opposite side specified.\n * https://github.com/mrdoob/three.js/pull/12787/\n */\n\nfunction parseSide(side) {\n  switch (side) {\n    case 'back':\n      {\n        return THREE.FrontSide;\n      }\n\n    case 'double':\n      {\n        return THREE.DoubleSide;\n      }\n\n    default:\n      {\n        return THREE.BackSide;\n      }\n  }\n}\n/**\n * @returns {Promise}\n */\n\n\nfunction loadFont(src, yOffset) {\n  return new Promise(function (resolve, reject) {\n    loadBMFont(src, function (err, font) {\n      if (err) {\n        error('Error loading font', src);\n        reject(err);\n        return;\n      } // Fix negative Y offsets for Roboto MSDF font from tool. Experimentally determined.\n\n\n      if (src.indexOf('/Roboto-msdf.json') >= 0) {\n        yOffset = 30;\n      }\n\n      if (yOffset) {\n        font.chars.map(function doOffset(ch) {\n          ch.yoffset += yOffset;\n        });\n      }\n\n      resolve(font);\n    });\n  });\n}\n/**\n * @returns {Promise}\n */\n\n\nfunction loadTexture(src) {\n  return new Promise(function (resolve, reject) {\n    new THREE.ImageLoader().load(src, function (image) {\n      resolve(image);\n    }, undefined, function () {\n      error('Error loading font image', src);\n      reject(null);\n    });\n  });\n}\n\nfunction createShader(el, shaderName, data) {\n  var shader;\n  var shaderObject; // Set up Shader.\n\n  shaderObject = new shaders[shaderName].Shader();\n  shaderObject.el = el;\n  shaderObject.init(data);\n  shaderObject.update(data); // Get material.\n\n  shader = shaderObject.material; // Apparently, was not set on `init` nor `update`.\n\n  shader.transparent = data.transparent;\n  return {\n    material: shader,\n    shader: shaderObject\n  };\n}\n/**\n * Determine wrap pixel count. Either specified or by experimental fudge factor.\n * Note that experimental factor will never be correct for variable width fonts.\n */\n\n\nfunction computeWidth(wrapPixels, wrapCount, widthFactor) {\n  return wrapPixels || (0.5 + wrapCount) * widthFactor;\n}\n/**\n * Compute default font width factor to use.\n */\n\n\nfunction computeFontWidthFactor(font) {\n  var sum = 0;\n  var digitsum = 0;\n  var digits = 0;\n  font.chars.map(function (ch) {\n    sum += ch.xadvance;\n\n    if (ch.id >= 48 && ch.id <= 57) {\n      digits++;\n      digitsum += ch.xadvance;\n    }\n  });\n  return digits ? digitsum / digits : sum / font.chars.length;\n}\n/**\n * Get or create a promise given a key and promise generator.\n * @todo Move to a utility and use in other parts of A-Frame.\n */\n\n\nfunction PromiseCache() {\n  var cache = this.cache = {};\n\n  this.get = function (key, promiseGenerator) {\n    if (key in cache) {\n      return cache[key];\n    }\n\n    cache[key] = promiseGenerator();\n    return cache[key];\n  };\n}","map":{"version":3,"sources":["C:/Users/Hannuri/Desktop/RoyalCyber/my-first-app/node_modules/aframe/src/components/text.js"],"names":["createTextGeometry","require","loadBMFont","registerComponent","coreShader","THREE","utils","error","debug","shaders","warn","DEFAULT_WIDTH","MAX_ANISOTROPY","FONT_BASE_URL","FONTS","aileronsemibold","dejavu","exo2bold","exo2semibold","kelsonsans","monoid","mozillavr","roboto","sourcecodepro","MSDF_FONTS","DEFAULT_FONT","module","exports","cache","PromiseCache","fontWidthFactors","textures","protocolRe","Component","multiple","schema","align","type","default","oneOf","alphaTest","anchor","baseline","color","font","fontImage","height","letterSpacing","lineHeight","negate","opacity","shader","side","tabSize","transparent","value","whiteSpace","width","wrapCount","wrapPixels","xOffset","yOffset","zOffset","init","shaderData","geometry","createOrUpdateMaterial","mesh","Mesh","material","el","setObject3D","attrName","update","oldData","data","currentFont","texture","Texture","anisotropy","updateFont","updateGeometry","updateLayout","remove","dispose","removeObject3D","shaderObject","hasChangedShader","NewShader","shaderName","indexOf","name","map","parseSide","createShader","fontSrc","self","visible","lookupFont","get","doLoadFont","loadFont","then","setFont","fontImgSrc","pages","length","Error","widthFactor","computeFontWidthFactor","getFontImageSrc","loadTexture","image","needsUpdate","emit","fontObj","catch","err","message","stack","imageSrc","match","replace","LoaderUtils","extractUrlBase","geometryComponent","layout","textRenderWidth","textScale","x","y","getAttribute","computeWidth","descender","primitive","setAttribute","TypeError","ascender","position","z","scale","set","key","geometryUpdateBase","geometryUpdateData","newLineRegex","tabRegex","isFinite","common","text","toString","extend","FrontSide","DoubleSide","BackSide","src","Promise","resolve","reject","chars","doOffset","ch","yoffset","ImageLoader","load","undefined","Shader","sum","digitsum","digits","xadvance","id","promiseGenerator"],"mappings":"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","sourcesContent":["var createTextGeometry = require('three-bmfont-text');\nvar loadBMFont = require('load-bmfont');\n\nvar registerComponent = require('../core/component').registerComponent;\nvar coreShader = require('../core/shader');\nvar THREE = require('../lib/three');\nvar utils = require('../utils/');\n\nvar error = utils.debug('components:text:error');\nvar shaders = coreShader.shaders;\nvar warn = utils.debug('components:text:warn');\n\n// 1 to match other A-Frame default widths.\nvar DEFAULT_WIDTH = 1;\n\n// @bryik set anisotropy to 16. Improves look of large amounts of text when viewed from angle.\nvar MAX_ANISOTROPY = 16;\n\nvar FONT_BASE_URL = 'https://cdn.aframe.io/fonts/';\nvar FONTS = {\n  aileronsemibold: FONT_BASE_URL + 'Aileron-Semibold.fnt',\n  dejavu: FONT_BASE_URL + 'DejaVu-sdf.fnt',\n  exo2bold: FONT_BASE_URL + 'Exo2Bold.fnt',\n  exo2semibold: FONT_BASE_URL + 'Exo2SemiBold.fnt',\n  kelsonsans: FONT_BASE_URL + 'KelsonSans.fnt',\n  monoid: FONT_BASE_URL + 'Monoid.fnt',\n  mozillavr: FONT_BASE_URL + 'mozillavr.fnt',\n  roboto: FONT_BASE_URL + 'Roboto-msdf.json',\n  sourcecodepro: FONT_BASE_URL + 'SourceCodePro.fnt'\n};\nvar MSDF_FONTS = ['roboto'];\nvar DEFAULT_FONT = 'roboto';\nmodule.exports.FONTS = FONTS;\n\nvar cache = new PromiseCache();\nvar fontWidthFactors = {};\nvar textures = {};\n\n// Regular expression for detecting a URLs with a protocol prefix.\nvar protocolRe = /^\\w+:/;\n\n/**\n * SDF-based text component.\n * Based on https://github.com/Jam3/three-bmfont-text.\n *\n * All the stock fonts are for the `sdf` registered shader, an improved version of jam3's\n * original `sdf` shader.\n */\nmodule.exports.Component = registerComponent('text', {\n  multiple: true,\n\n  schema: {\n    align: {type: 'string', default: 'left', oneOf: ['left', 'right', 'center']},\n    alphaTest: {default: 0.5},\n    // `anchor` defaults to center to match geometries.\n    anchor: {default: 'center', oneOf: ['left', 'right', 'center', 'align']},\n    baseline: {default: 'center', oneOf: ['top', 'center', 'bottom']},\n    color: {type: 'color', default: '#FFF'},\n    font: {type: 'string', default: DEFAULT_FONT},\n    // `fontImage` defaults to the font name as a .png (e.g., mozillavr.fnt -> mozillavr.png).\n    fontImage: {type: 'string'},\n    // `height` has no default, will be populated at layout.\n    height: {type: 'number'},\n    letterSpacing: {type: 'number', default: 0},\n    // `lineHeight` defaults to font's `lineHeight` value.\n    lineHeight: {type: 'number'},\n    // `negate` must be true for fonts generated with older versions of msdfgen (white background).\n    negate: {type: 'boolean', default: true},\n    opacity: {type: 'number', default: 1.0},\n    shader: {default: 'sdf', oneOf: shaders},\n    side: {default: 'front', oneOf: ['front', 'back', 'double']},\n    tabSize: {default: 4},\n    transparent: {default: true},\n    value: {type: 'string'},\n    whiteSpace: {default: 'normal', oneOf: ['normal', 'pre', 'nowrap']},\n    // `width` defaults to geometry width if present, else `DEFAULT_WIDTH`.\n    width: {type: 'number'},\n    // `wrapCount` units are about one default font character. Wrap roughly at this number.\n    wrapCount: {type: 'number', default: 40},\n    // `wrapPixels` will wrap using bmfont pixel units (e.g., dejavu's is 32 pixels).\n    wrapPixels: {type: 'number'},\n    // `xOffset` to add padding.\n    xOffset: {type: 'number', default: 0},\n    // `yOffset` to adjust generated fonts from tools that may have incorrect metrics.\n    yOffset: {type: 'number', default: 0},\n    // `zOffset` will provide a small z offset to avoid z-fighting.\n    zOffset: {type: 'number', default: 0.001}\n  },\n\n  init: function () {\n    this.shaderData = {};\n    this.geometry = createTextGeometry();\n    this.createOrUpdateMaterial();\n    this.mesh = new THREE.Mesh(this.geometry, this.material);\n    this.el.setObject3D(this.attrName, this.mesh);\n  },\n\n  update: function (oldData) {\n    var data = this.data;\n    var font = this.currentFont;\n\n    if (textures[data.font]) {\n      this.texture = textures[data.font];\n    } else {\n      // Create texture per font.\n      this.texture = textures[data.font] = new THREE.Texture();\n      this.texture.anisotropy = MAX_ANISOTROPY;\n    }\n\n    // Update material.\n    this.createOrUpdateMaterial();\n\n    // New font. `updateFont` will later change data and layout.\n    if (oldData.font !== data.font) {\n      this.updateFont();\n      return;\n    }\n\n    // Update geometry and layout.\n    if (font) {\n      this.updateGeometry(this.geometry, font);\n      this.updateLayout();\n    }\n  },\n\n  /**\n   * Clean up geometry, material, texture, mesh, objects.\n   */\n  remove: function () {\n    this.geometry.dispose();\n    this.geometry = null;\n    this.el.removeObject3D(this.attrName);\n    this.material.dispose();\n    this.material = null;\n    this.texture.dispose();\n    this.texture = null;\n    if (this.shaderObject) {\n      delete this.shaderObject;\n    }\n  },\n\n  /**\n   * Update the shader of the material.\n   */\n  createOrUpdateMaterial: function () {\n    var data = this.data;\n    var hasChangedShader;\n    var material = this.material;\n    var NewShader;\n    var shaderData = this.shaderData;\n    var shaderName;\n\n    // Infer shader if using a stock font (or from `-msdf` filename convention).\n    shaderName = data.shader;\n    if (MSDF_FONTS.indexOf(data.font) !== -1 || data.font.indexOf('-msdf.') >= 0) {\n      shaderName = 'msdf';\n    } else if (data.font in FONTS && MSDF_FONTS.indexOf(data.font) === -1) {\n      shaderName = 'sdf';\n    }\n\n    hasChangedShader = (this.shaderObject && this.shaderObject.name) !== shaderName;\n\n    shaderData.alphaTest = data.alphaTest;\n    shaderData.color = data.color;\n    shaderData.map = this.texture;\n    shaderData.opacity = data.opacity;\n    shaderData.side = parseSide(data.side);\n    shaderData.transparent = data.transparent;\n    shaderData.negate = data.negate;\n\n    // Shader has not changed, do an update.\n    if (!hasChangedShader) {\n      // Update shader material.\n      this.shaderObject.update(shaderData);\n      // Apparently, was not set on `init` nor `update`.\n      material.transparent = shaderData.transparent;\n      material.side = shaderData.side;\n      return;\n    }\n\n    // Shader has changed. Create a shader material.\n    NewShader = createShader(this.el, shaderName, shaderData);\n    this.material = NewShader.material;\n    this.shaderObject = NewShader.shader;\n\n    // Set new shader material.\n    this.material.side = shaderData.side;\n    if (this.mesh) { this.mesh.material = this.material; }\n  },\n\n  /**\n   * Load font for geometry, load font image for material, and apply.\n   */\n  updateFont: function () {\n    var data = this.data;\n    var el = this.el;\n    var fontSrc;\n    var geometry = this.geometry;\n    var self = this;\n\n    if (!data.font) { warn('No font specified. Using the default font.'); }\n\n    // Make invisible during font swap.\n    this.mesh.visible = false;\n\n    // Look up font URL to use, and perform cached load.\n    fontSrc = this.lookupFont(data.font || DEFAULT_FONT) || data.font;\n    cache.get(fontSrc, function doLoadFont () {\n      return loadFont(fontSrc, data.yOffset);\n    }).then(function setFont (font) {\n      var fontImgSrc;\n\n      if (font.pages.length !== 1) {\n        throw new Error('Currently only single-page bitmap fonts are supported.');\n      }\n\n      if (!fontWidthFactors[fontSrc]) {\n        font.widthFactor = fontWidthFactors[font] = computeFontWidthFactor(font);\n      }\n\n      // Update geometry given font metrics.\n      self.updateGeometry(geometry, font);\n\n      // Set font and update layout.\n      self.currentFont = font;\n      self.updateLayout();\n\n      // Look up font image URL to use, and perform cached load.\n      fontImgSrc = self.getFontImageSrc();\n      cache.get(fontImgSrc, function () {\n        return loadTexture(fontImgSrc);\n      }).then(function (image) {\n        // Make mesh visible and apply font image as texture.\n        var texture = self.texture;\n        texture.image = image;\n        texture.needsUpdate = true;\n        textures[data.font] = texture;\n        self.texture = texture;\n        self.mesh.visible = true;\n        el.emit('textfontset', {font: data.font, fontObj: font});\n      }).catch(function (err) {\n        error(err.message);\n        error(err.stack);\n      });\n    }).catch(function (err) {\n      error(err.message);\n      error(err.stack);\n    });\n  },\n\n  getFontImageSrc: function () {\n    if (this.data.fontImage) { return this.data.fontImage; }\n    var fontSrc = this.lookupFont(this.data.font || DEFAULT_FONT) || this.data.font;\n    var imageSrc = this.currentFont.pages[0];\n    // If the image URL contains a non-HTTP(S) protocol, assume it's an absolute\n    // path on disk and try to infer the path from the font source instead.\n    if (imageSrc.match(protocolRe) && imageSrc.indexOf('http') !== 0) {\n      return fontSrc.replace(/(\\.fnt)|(\\.json)/, '.png');\n    }\n    return THREE.LoaderUtils.extractUrlBase(fontSrc) + imageSrc;\n  },\n\n  /**\n   * Update layout with anchor, alignment, baseline, and considering any meshes.\n   */\n  updateLayout: function () {\n    var anchor;\n    var baseline;\n    var el = this.el;\n    var data = this.data;\n    var geometry = this.geometry;\n    var geometryComponent;\n    var height;\n    var layout;\n    var mesh = this.mesh;\n    var textRenderWidth;\n    var textScale;\n    var width;\n    var x;\n    var y;\n\n    if (!geometry.layout) { return; }\n\n    // Determine width to use (defined width, geometry's width, or default width).\n    geometryComponent = el.getAttribute('geometry');\n    width = data.width || (geometryComponent && geometryComponent.width) || DEFAULT_WIDTH;\n\n    // Determine wrap pixel count. Either specified or by experimental fudge factor.\n    // Note that experimental factor will never be correct for variable width fonts.\n    textRenderWidth = computeWidth(data.wrapPixels, data.wrapCount,\n                                   this.currentFont.widthFactor);\n    textScale = width / textRenderWidth;\n\n    // Determine height to use.\n    layout = geometry.layout;\n    height = textScale * (layout.height + layout.descender);\n\n    // Update geometry dimensions to match text layout if width and height are set to 0.\n    // For example, scales a plane to fit text.\n    if (geometryComponent && geometryComponent.primitive === 'plane') {\n      if (!geometryComponent.width) { el.setAttribute('geometry', 'width', width); }\n      if (!geometryComponent.height) { el.setAttribute('geometry', 'height', height); }\n    }\n\n    // Calculate X position to anchor text left, center, or right.\n    anchor = data.anchor === 'align' ? data.align : data.anchor;\n    if (anchor === 'left') {\n      x = 0;\n    } else if (anchor === 'right') {\n      x = -1 * layout.width;\n    } else if (anchor === 'center') {\n      x = -1 * layout.width / 2;\n    } else {\n      throw new TypeError('Invalid text.anchor property value', anchor);\n    }\n\n    // Calculate Y position to anchor text top, center, or bottom.\n    baseline = data.baseline;\n    if (baseline === 'bottom') {\n      y = 0;\n    } else if (baseline === 'top') {\n      y = -1 * layout.height + layout.ascender;\n    } else if (baseline === 'center') {\n      y = -1 * layout.height / 2;\n    } else {\n      throw new TypeError('Invalid text.baseline property value', baseline);\n    }\n\n    // Position and scale mesh to apply layout.\n    mesh.position.x = x * textScale + data.xOffset;\n    mesh.position.y = y * textScale;\n    // Place text slightly in front to avoid Z-fighting.\n    mesh.position.z = data.zOffset;\n    mesh.scale.set(textScale, -1 * textScale, textScale);\n  },\n\n  /**\n   * Grab font from the constant.\n   * Set as a method for test stubbing purposes.\n   */\n  lookupFont: function (key) {\n    return FONTS[key];\n  },\n\n  /**\n   * Update the text geometry using `three-bmfont-text.update`.\n   */\n  updateGeometry: (function () {\n    var geometryUpdateBase = {};\n    var geometryUpdateData = {};\n    var newLineRegex = /\\\\n/g;\n    var tabRegex = /\\\\t/g;\n\n    return function (geometry, font) {\n      var data = this.data;\n\n      geometryUpdateData.font = font;\n      geometryUpdateData.lineHeight = data.lineHeight && isFinite(data.lineHeight)\n        ? data.lineHeight\n        : font.common.lineHeight;\n      geometryUpdateData.text = data.value.toString().replace(newLineRegex, '\\n')\n                                                     .replace(tabRegex, '\\t');\n      geometryUpdateData.width = computeWidth(data.wrapPixels, data.wrapCount,\n                                              font.widthFactor);\n      geometry.update(utils.extend(geometryUpdateBase, data, geometryUpdateData));\n    };\n  })()\n});\n\n/**\n * Due to using negative scale, we return the opposite side specified.\n * https://github.com/mrdoob/three.js/pull/12787/\n */\nfunction parseSide (side) {\n  switch (side) {\n    case 'back': {\n      return THREE.FrontSide;\n    }\n    case 'double': {\n      return THREE.DoubleSide;\n    }\n    default: {\n      return THREE.BackSide;\n    }\n  }\n}\n\n/**\n * @returns {Promise}\n */\nfunction loadFont (src, yOffset) {\n  return new Promise(function (resolve, reject) {\n    loadBMFont(src, function (err, font) {\n      if (err) {\n        error('Error loading font', src);\n        reject(err);\n        return;\n      }\n\n      // Fix negative Y offsets for Roboto MSDF font from tool. Experimentally determined.\n      if (src.indexOf('/Roboto-msdf.json') >= 0) { yOffset = 30; }\n      if (yOffset) { font.chars.map(function doOffset (ch) { ch.yoffset += yOffset; }); }\n\n      resolve(font);\n    });\n  });\n}\n\n/**\n * @returns {Promise}\n */\nfunction loadTexture (src) {\n  return new Promise(function (resolve, reject) {\n    new THREE.ImageLoader().load(src, function (image) {\n      resolve(image);\n    }, undefined, function () {\n      error('Error loading font image', src);\n      reject(null);\n    });\n  });\n}\n\nfunction createShader (el, shaderName, data) {\n  var shader;\n  var shaderObject;\n\n  // Set up Shader.\n  shaderObject = new shaders[shaderName].Shader();\n  shaderObject.el = el;\n  shaderObject.init(data);\n  shaderObject.update(data);\n\n  // Get material.\n  shader = shaderObject.material;\n  // Apparently, was not set on `init` nor `update`.\n  shader.transparent = data.transparent;\n\n  return {\n    material: shader,\n    shader: shaderObject\n  };\n}\n\n/**\n * Determine wrap pixel count. Either specified or by experimental fudge factor.\n * Note that experimental factor will never be correct for variable width fonts.\n */\nfunction computeWidth (wrapPixels, wrapCount, widthFactor) {\n  return wrapPixels || ((0.5 + wrapCount) * widthFactor);\n}\n\n/**\n * Compute default font width factor to use.\n */\nfunction computeFontWidthFactor (font) {\n  var sum = 0;\n  var digitsum = 0;\n  var digits = 0;\n  font.chars.map(function (ch) {\n    sum += ch.xadvance;\n    if (ch.id >= 48 && ch.id <= 57) {\n      digits++;\n      digitsum += ch.xadvance;\n    }\n  });\n  return digits ? digitsum / digits : sum / font.chars.length;\n}\n\n/**\n * Get or create a promise given a key and promise generator.\n * @todo Move to a utility and use in other parts of A-Frame.\n */\nfunction PromiseCache () {\n  var cache = this.cache = {};\n\n  this.get = function (key, promiseGenerator) {\n    if (key in cache) {\n      return cache[key];\n    }\n    cache[key] = promiseGenerator();\n    return cache[key];\n  };\n}\n"]},"metadata":{},"sourceType":"script"}