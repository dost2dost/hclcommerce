{"ast":null,"code":"/*\n  ------------------------------------------------------------\n  ------------- WARNING WARNING WARNING WARNING --------------\n  ------------------------------------------------------------\n\n  This module wraps registerElement to deal with components that inherit from\n  `ANode` and `AEntity`.  It's a pass through in any other case.\n\n  It wraps some of the prototype methods of the created element to make sure\n  that the corresponding functions in the base prototypes (`AEntity` and `ANode`)\n  are also invoked. The method in the base prototype is always called before the one\n  in the derived prototype.\n*/\n// Polyfill `document.registerElement`.\nrequire('document-register-element');\n\nvar ANode; // Must declare before AEntity. Initialized at the bottom.\n\nvar AEntity;\nvar knownTags = module.exports.knownTags = {};\n\nfunction addTagName(tagName) {\n  knownTags[tagName.toLowerCase()] = true;\n}\n/**\n * Return whether the element type is one of our known registered ones.\n *\n * @param {string} node - The name of the tag to register.\n * @returns {boolean} Whether the tag name matches that of our registered custom elements.\n */\n\n\nmodule.exports.isNode = function (node) {\n  return node.tagName.toLowerCase() in knownTags || node.isNode;\n};\n/**\n * @param {string} tagName - The name of the tag to register.\n * @param {object} obj - The prototype of the new element.\n * @returns {object} The prototype of the new element.\n */\n\n\nmodule.exports.registerElement = function (tagName, obj) {\n  var proto = Object.getPrototypeOf(obj.prototype);\n  var newObj = obj;\n  var isANode = ANode && proto === ANode.prototype;\n  var isAEntity = AEntity && proto === AEntity.prototype;\n\n  if (isANode || isAEntity) {\n    addTagName(tagName);\n  } // Wrap if element inherits from `ANode`.\n\n\n  if (isANode) {\n    newObj = wrapANodeMethods(obj.prototype);\n    newObj = {\n      prototype: Object.create(proto, newObj)\n    };\n  } // Wrap if element inherits from `AEntity`.\n\n\n  if (isAEntity) {\n    newObj = wrapAEntityMethods(obj.prototype);\n    newObj = {\n      prototype: Object.create(proto, newObj)\n    };\n  } // Give all functions their proper name.\n\n\n  Object.getOwnPropertyNames(newObj.prototype).forEach(function (propName) {\n    var propVal = newObj.prototype[propName];\n\n    if (typeof propVal === 'function') {\n      propVal.displayName = propName;\n    }\n  });\n  return document.registerElement(tagName, newObj);\n};\n/**\n * Wrap some obj methods to call those on `ANode` base prototype.\n *\n * @param {object} obj - Object that contains the methods that will be wrapped.\n * @return {object} An object with the same properties as the input parameter but\n * with some of methods wrapped.\n */\n\n\nfunction wrapANodeMethods(obj) {\n  var newObj = {};\n  var ANodeMethods = ['attachedCallback', 'attributeChangedCallback', 'createdCallback', 'detachedCallback'];\n  wrapMethods(newObj, ANodeMethods, obj, ANode.prototype);\n  copyProperties(obj, newObj);\n  return newObj;\n}\n/**\n * This wraps some of the obj methods to call those on `AEntity` base prototype.\n *\n * @param {object} obj - The objects that contains the methods that will be wrapped.\n * @return {object} - An object with the same properties as the input parameter but\n * with some of methods wrapped.\n */\n\n\nfunction wrapAEntityMethods(obj) {\n  var newObj = {};\n  var ANodeMethods = ['attachedCallback', 'attributeChangedCallback', 'createdCallback', 'detachedCallback'];\n  var AEntityMethods = ['attachedCallback', 'attributeChangedCallback', 'createdCallback', 'detachedCallback'];\n  wrapMethods(newObj, ANodeMethods, obj, ANode.prototype);\n  wrapMethods(newObj, AEntityMethods, obj, AEntity.prototype); // Copies the remaining properties into the new object.\n\n  copyProperties(obj, newObj);\n  return newObj;\n}\n/**\n * Wrap a list a methods to ensure that those in the base prototype are called\n * before the derived one.\n *\n * @param {object} targetObj - Object that will contain the wrapped methods.\n * @param {array} methodList - List of methods from the derivedObj that will be wrapped.\n * @param {object} derivedObject - Object that inherits from the baseObj.\n * @param {object} baseObj - Object that derivedObj inherits from.\n */\n\n\nfunction wrapMethods(targetObj, methodList, derivedObj, baseObj) {\n  methodList.forEach(function (methodName) {\n    wrapMethod(targetObj, methodName, derivedObj, baseObj);\n  });\n}\n\nmodule.exports.wrapMethods = wrapMethods;\n/**\n * Wrap one method to ensure that the one in the base prototype is called before\n * the one in the derived one.\n *\n * @param {object} obj - Object that will contain the wrapped method.\n * @param {string} methodName - The name of the method that will be wrapped.\n * @param {object} derivedObject - Object that inherits from the baseObj.\n * @param {object} baseObj - Object that derivedObj inherits from.\n */\n\nfunction wrapMethod(obj, methodName, derivedObj, baseObj) {\n  var derivedMethod = derivedObj[methodName];\n  var baseMethod = baseObj[methodName]; // Derived prototype does not define method, no need to wrap.\n\n  if (!derivedMethod || !baseMethod) {\n    return;\n  } // Derived prototype doesn't override the one in the base one, no need to wrap.\n\n\n  if (derivedMethod === baseMethod) {\n    return;\n  } // Wrap to ensure the base method is called before the one in the derived prototype.\n\n\n  obj[methodName] = {\n    value: function wrappedMethod() {\n      baseMethod.apply(this, arguments);\n      return derivedMethod.apply(this, arguments);\n    },\n    writable: window.debug\n  };\n}\n/**\n * It copies the properties from source to destination object if they don't\n * exist already.\n *\n * @param {object} source - The object where properties are copied from.\n * @param {type} destination - The object where properties are copied to.\n */\n\n\nfunction copyProperties(source, destination) {\n  var props = Object.getOwnPropertyNames(source);\n  props.forEach(function (prop) {\n    var desc;\n\n    if (!destination[prop]) {\n      desc = Object.getOwnPropertyDescriptor(source, prop);\n      destination[prop] = {\n        value: source[prop],\n        writable: desc.writable\n      };\n    }\n  });\n}\n\nANode = require('./a-node');\nAEntity = require('./a-entity');","map":{"version":3,"sources":["C:/Users/Hannuri/Desktop/RoyalCyber/my-first-app/node_modules/aframe/src/core/a-register-element.js"],"names":["require","ANode","AEntity","knownTags","module","exports","addTagName","tagName","toLowerCase","isNode","node","registerElement","obj","proto","Object","getPrototypeOf","prototype","newObj","isANode","isAEntity","wrapANodeMethods","create","wrapAEntityMethods","getOwnPropertyNames","forEach","propName","propVal","displayName","document","ANodeMethods","wrapMethods","copyProperties","AEntityMethods","targetObj","methodList","derivedObj","baseObj","methodName","wrapMethod","derivedMethod","baseMethod","value","wrappedMethod","apply","arguments","writable","window","debug","source","destination","props","prop","desc","getOwnPropertyDescriptor"],"mappings":"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","sourcesContent":["/*\n  ------------------------------------------------------------\n  ------------- WARNING WARNING WARNING WARNING --------------\n  ------------------------------------------------------------\n\n  This module wraps registerElement to deal with components that inherit from\n  `ANode` and `AEntity`.  It's a pass through in any other case.\n\n  It wraps some of the prototype methods of the created element to make sure\n  that the corresponding functions in the base prototypes (`AEntity` and `ANode`)\n  are also invoked. The method in the base prototype is always called before the one\n  in the derived prototype.\n*/\n\n// Polyfill `document.registerElement`.\nrequire('document-register-element');\n\nvar ANode;  // Must declare before AEntity. Initialized at the bottom.\nvar AEntity;\nvar knownTags = module.exports.knownTags = {};\n\nfunction addTagName (tagName) {\n  knownTags[tagName.toLowerCase()] = true;\n}\n\n/**\n * Return whether the element type is one of our known registered ones.\n *\n * @param {string} node - The name of the tag to register.\n * @returns {boolean} Whether the tag name matches that of our registered custom elements.\n */\nmodule.exports.isNode = function (node) {\n  return node.tagName.toLowerCase() in knownTags || node.isNode;\n};\n\n/**\n * @param {string} tagName - The name of the tag to register.\n * @param {object} obj - The prototype of the new element.\n * @returns {object} The prototype of the new element.\n */\nmodule.exports.registerElement = function (tagName, obj) {\n  var proto = Object.getPrototypeOf(obj.prototype);\n  var newObj = obj;\n  var isANode = ANode && proto === ANode.prototype;\n  var isAEntity = AEntity && proto === AEntity.prototype;\n\n  if (isANode || isAEntity) { addTagName(tagName); }\n\n  // Wrap if element inherits from `ANode`.\n  if (isANode) {\n    newObj = wrapANodeMethods(obj.prototype);\n    newObj = {prototype: Object.create(proto, newObj)};\n  }\n\n  // Wrap if element inherits from `AEntity`.\n  if (isAEntity) {\n    newObj = wrapAEntityMethods(obj.prototype);\n    newObj = {prototype: Object.create(proto, newObj)};\n  }\n\n  // Give all functions their proper name.\n  Object.getOwnPropertyNames(newObj.prototype).forEach(function (propName) {\n    var propVal = newObj.prototype[propName];\n    if (typeof propVal === 'function') {\n      propVal.displayName = propName;\n    }\n  });\n\n  return document.registerElement(tagName, newObj);\n};\n\n/**\n * Wrap some obj methods to call those on `ANode` base prototype.\n *\n * @param {object} obj - Object that contains the methods that will be wrapped.\n * @return {object} An object with the same properties as the input parameter but\n * with some of methods wrapped.\n */\nfunction wrapANodeMethods (obj) {\n  var newObj = {};\n  var ANodeMethods = [\n    'attachedCallback',\n    'attributeChangedCallback',\n    'createdCallback',\n    'detachedCallback'\n  ];\n  wrapMethods(newObj, ANodeMethods, obj, ANode.prototype);\n  copyProperties(obj, newObj);\n  return newObj;\n}\n\n/**\n * This wraps some of the obj methods to call those on `AEntity` base prototype.\n *\n * @param {object} obj - The objects that contains the methods that will be wrapped.\n * @return {object} - An object with the same properties as the input parameter but\n * with some of methods wrapped.\n */\nfunction wrapAEntityMethods (obj) {\n  var newObj = {};\n  var ANodeMethods = [\n    'attachedCallback',\n    'attributeChangedCallback',\n    'createdCallback',\n    'detachedCallback'\n  ];\n  var AEntityMethods = [\n    'attachedCallback',\n    'attributeChangedCallback',\n    'createdCallback',\n    'detachedCallback'\n  ];\n\n  wrapMethods(newObj, ANodeMethods, obj, ANode.prototype);\n  wrapMethods(newObj, AEntityMethods, obj, AEntity.prototype);\n  // Copies the remaining properties into the new object.\n  copyProperties(obj, newObj);\n  return newObj;\n}\n\n/**\n * Wrap a list a methods to ensure that those in the base prototype are called\n * before the derived one.\n *\n * @param {object} targetObj - Object that will contain the wrapped methods.\n * @param {array} methodList - List of methods from the derivedObj that will be wrapped.\n * @param {object} derivedObject - Object that inherits from the baseObj.\n * @param {object} baseObj - Object that derivedObj inherits from.\n */\nfunction wrapMethods (targetObj, methodList, derivedObj, baseObj) {\n  methodList.forEach(function (methodName) {\n    wrapMethod(targetObj, methodName, derivedObj, baseObj);\n  });\n}\nmodule.exports.wrapMethods = wrapMethods;\n\n/**\n * Wrap one method to ensure that the one in the base prototype is called before\n * the one in the derived one.\n *\n * @param {object} obj - Object that will contain the wrapped method.\n * @param {string} methodName - The name of the method that will be wrapped.\n * @param {object} derivedObject - Object that inherits from the baseObj.\n * @param {object} baseObj - Object that derivedObj inherits from.\n */\nfunction wrapMethod (obj, methodName, derivedObj, baseObj) {\n  var derivedMethod = derivedObj[methodName];\n  var baseMethod = baseObj[methodName];\n\n  // Derived prototype does not define method, no need to wrap.\n  if (!derivedMethod || !baseMethod) { return; }\n\n  // Derived prototype doesn't override the one in the base one, no need to wrap.\n  if (derivedMethod === baseMethod) { return; }\n\n  // Wrap to ensure the base method is called before the one in the derived prototype.\n  obj[methodName] = {\n    value: function wrappedMethod () {\n      baseMethod.apply(this, arguments);\n      return derivedMethod.apply(this, arguments);\n    },\n    writable: window.debug\n  };\n}\n\n/**\n * It copies the properties from source to destination object if they don't\n * exist already.\n *\n * @param {object} source - The object where properties are copied from.\n * @param {type} destination - The object where properties are copied to.\n */\nfunction copyProperties (source, destination) {\n  var props = Object.getOwnPropertyNames(source);\n  props.forEach(function (prop) {\n    var desc;\n    if (!destination[prop]) {\n      desc = Object.getOwnPropertyDescriptor(source, prop);\n      destination[prop] = {value: source[prop], writable: desc.writable};\n    }\n  });\n}\n\nANode = require('./a-node');\nAEntity = require('./a-entity');\n"]},"metadata":{},"sourceType":"script"}