{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n\nimport { property } from 'lit-element';\nimport { UpdatingElement } from 'lit-element/lib/updating-element';\nimport { HAS_INTERSECTION_OBSERVER, HAS_RESIZE_OBSERVER } from './constants.js';\nimport { makeTemplate } from './template.js';\nimport { $evictionPolicy, CachingGLTFLoader } from './three-components/CachingGLTFLoader.js';\nimport { ModelScene } from './three-components/ModelScene.js';\nimport { Renderer } from './three-components/Renderer.js';\nimport { debounce, deserializeUrl, resolveDpr } from './utilities.js';\nimport { dataUrlToBlob } from './utilities/data-conversion.js';\nimport { ProgressTracker } from './utilities/progress-tracker.js';\nconst CLEAR_MODEL_TIMEOUT_MS = 1000;\nconst FALLBACK_SIZE_UPDATE_THRESHOLD_MS = 50;\nconst ANNOUNCE_MODEL_VISIBILITY_DEBOUNCE_THRESHOLD = 0;\nconst UNSIZED_MEDIA_WIDTH = 300;\nconst UNSIZED_MEDIA_HEIGHT = 150;\nconst blobCanvas = document.createElement('canvas');\nlet blobContext = null;\nconst $selectCanvas = Symbol('selectCanvas');\nconst $updateSize = Symbol('updateSize');\nconst $loaded = Symbol('loaded');\nconst $template = Symbol('template');\nconst $fallbackResizeHandler = Symbol('fallbackResizeHandler');\nconst $defaultAriaLabel = Symbol('defaultAriaLabel');\nconst $resizeObserver = Symbol('resizeObserver');\nconst $intersectionObserver = Symbol('intersectionObserver');\nconst $lastDpr = Symbol('lastDpr');\nconst $clearModelTimeout = Symbol('clearModelTimeout');\nconst $onContextLost = Symbol('onContextLost');\nconst $contextLostHandler = Symbol('contextLostHandler');\nexport const $isElementInViewport = Symbol('isElementInViewport');\nexport const $announceModelVisibility = Symbol('announceModelVisibility');\nexport const $ariaLabel = Symbol('ariaLabel');\nexport const $loadedTime = Symbol('loadedTime');\nexport const $updateSource = Symbol('updateSource');\nexport const $markLoaded = Symbol('markLoaded');\nexport const $container = Symbol('container');\nexport const $userInputElement = Symbol('input');\nexport const $canvas = Symbol('canvas');\nexport const $displayCanvas = Symbol('displayCanvas');\nexport const $scene = Symbol('scene');\nexport const $needsRender = Symbol('needsRender');\nexport const $tick = Symbol('tick');\nexport const $onModelLoad = Symbol('onModelLoad');\nexport const $onResize = Symbol('onResize');\nexport const $renderer = Symbol('renderer');\nexport const $progressTracker = Symbol('progressTracker');\nexport const $getLoaded = Symbol('getLoaded');\nexport const $getModelIsVisible = Symbol('getModelIsVisible');\nexport const toVector3D = v => {\n  return {\n    x: v.x,\n    y: v.y,\n    z: v.z,\n\n    toString() {\n      return `${this.x}m ${this.y}m ${this.z}m`;\n    }\n\n  };\n};\n/**\n * Definition for a basic <model-viewer> element.\n */\n\nexport default class ModelViewerElementBase extends UpdatingElement {\n  /**\n   * Creates a new ModelViewerElement.\n   */\n  constructor() {\n    super();\n    this.alt = null;\n    this.src = null;\n    this[_a] = false;\n    this[_b] = false;\n    this[_c] = 0;\n    this[_d] = resolveDpr();\n    this[_e] = null;\n    this[_f] = debounce(() => {\n      const boundingRect = this.getBoundingClientRect();\n      this[$updateSize](boundingRect);\n    }, FALLBACK_SIZE_UPDATE_THRESHOLD_MS);\n    this[_g] = debounce(oldVisibility => {\n      const newVisibility = this.modelIsVisible;\n\n      if (newVisibility !== oldVisibility) {\n        this.dispatchEvent(new CustomEvent('model-visibility', {\n          detail: {\n            visible: newVisibility\n          }\n        }));\n      }\n    }, ANNOUNCE_MODEL_VISIBILITY_DEBOUNCE_THRESHOLD);\n    this[_h] = null;\n    this[_j] = null;\n    this[_k] = new ProgressTracker();\n\n    this[_l] = event => this[$onContextLost](event); // NOTE(cdata): It is *very important* to access this template first so that\n    // the ShadyCSS template preparation steps happen before element styling in\n    // IE11:\n\n\n    const template = this.constructor.template;\n\n    if (window.ShadyCSS) {\n      window.ShadyCSS.styleElement(this, {});\n    } // NOTE(cdata): The canonical ShadyCSS examples suggest that the Shadow Root\n    // should be created after the invocation of ShadyCSS.styleElement\n\n\n    this.attachShadow({\n      mode: 'open'\n    });\n    const shadowRoot = this.shadowRoot;\n    shadowRoot.appendChild(template.content.cloneNode(true));\n    this[$container] = shadowRoot.querySelector('.container');\n    this[$userInputElement] = shadowRoot.querySelector('.userInput');\n    this[$canvas] = shadowRoot.querySelector('canvas');\n    this[$defaultAriaLabel] = this[$userInputElement].getAttribute('aria-label'); // Because of potential race conditions related to invoking the constructor\n    // we only use the bounding rect to set the initial size if the element is\n    // already connected to the document:\n\n    let width, height;\n\n    if (this.isConnected) {\n      const rect = this.getBoundingClientRect();\n      width = rect.width;\n      height = rect.height;\n    } else {\n      width = UNSIZED_MEDIA_WIDTH;\n      height = UNSIZED_MEDIA_HEIGHT;\n    } // Create the underlying ModelScene.\n\n\n    this[$scene] = new ModelScene({\n      canvas: this[$canvas],\n      element: this,\n      width,\n      height\n    });\n    this[$scene].addEventListener('model-load', event => {\n      this[$markLoaded]();\n      this[$onModelLoad](event);\n      this.dispatchEvent(new CustomEvent('load', {\n        detail: {\n          url: event.url\n        }\n      }));\n    }); // Update initial size on microtask timing so that subclasses have a\n    // chance to initialize\n\n    Promise.resolve().then(() => {\n      this[$updateSize](this.getBoundingClientRect(), true);\n    });\n\n    if (HAS_RESIZE_OBSERVER) {\n      // Set up a resize observer so we can scale our canvas\n      // if our <model-viewer> changes\n      this[$resizeObserver] = new ResizeObserver(entries => {\n        // Don't resize anything if in AR mode; otherwise the canvas\n        // scaling to fullscreen on entering AR will clobber the flat/2d\n        // dimensions of the element.\n        if (this[$renderer].isPresenting) {\n          return;\n        }\n\n        for (let entry of entries) {\n          if (entry.target === this) {\n            this[$updateSize](entry.contentRect);\n          }\n        }\n      });\n    }\n\n    if (HAS_INTERSECTION_OBSERVER) {\n      const enterRenderTreeProgress = this[$progressTracker].beginActivity();\n      this[$intersectionObserver] = new IntersectionObserver(entries => {\n        for (let entry of entries) {\n          if (entry.target === this) {\n            const oldVisibility = this.modelIsVisible;\n            const oldValue = this[$isElementInViewport];\n            this[$isElementInViewport] = this[$scene].visible = entry.isIntersecting;\n            this.requestUpdate($isElementInViewport, oldValue);\n            this[$announceModelVisibility](oldVisibility);\n\n            if (this[$isElementInViewport]) {\n              // Wait a microtask to give other properties a chance to respond\n              // to the state change, then resolve progress on entering the\n              // render tree:\n              Promise.resolve().then(() => {\n                enterRenderTreeProgress(1);\n              });\n            }\n          }\n        }\n      }, {\n        root: null,\n        rootMargin: '10px',\n        threshold: 0\n      });\n    } else {\n      // If there is no intersection obsever, then all models should be visible\n      // at all times:\n      this[$isElementInViewport] = this[$scene].visible = true;\n      this.requestUpdate($isElementInViewport, false);\n    }\n  }\n\n  static get is() {\n    return 'model-viewer';\n  }\n  /** @nocollapse */\n\n\n  static get template() {\n    if (!this.hasOwnProperty($template)) {\n      this[$template] = makeTemplate(this.is);\n    }\n\n    return this[$template];\n  }\n  /** @export */\n\n\n  static set modelCacheSize(value) {\n    CachingGLTFLoader[$evictionPolicy].evictionThreshold = value;\n  }\n  /** @export */\n\n\n  static get modelCacheSize() {\n    return CachingGLTFLoader[$evictionPolicy].evictionThreshold;\n  }\n  /** @export */\n\n\n  get loaded() {\n    return this[$getLoaded]();\n  }\n\n  get [(_a = $isElementInViewport, _b = $loaded, _c = $loadedTime, _d = $lastDpr, _e = $clearModelTimeout, _f = $fallbackResizeHandler, _g = $announceModelVisibility, _h = $resizeObserver, _j = $intersectionObserver, _k = $progressTracker, _l = $contextLostHandler, $renderer)]() {\n    return Renderer.singleton;\n  }\n  /** @export */\n\n\n  get modelIsVisible() {\n    return this[$getModelIsVisible]();\n  }\n\n  connectedCallback() {\n    super.connectedCallback && super.connectedCallback();\n\n    if (HAS_RESIZE_OBSERVER) {\n      this[$resizeObserver].observe(this);\n    } else {\n      self.addEventListener('resize', this[$fallbackResizeHandler]);\n    }\n\n    if (HAS_INTERSECTION_OBSERVER) {\n      this[$intersectionObserver].observe(this);\n    }\n\n    this[$renderer].addEventListener('contextlost', this[$contextLostHandler]);\n    this[$renderer].registerScene(this[$scene]);\n    this[$selectCanvas]();\n    this[$scene].isDirty = true;\n\n    if (this[$clearModelTimeout] != null) {\n      self.clearTimeout(this[$clearModelTimeout]);\n      this[$clearModelTimeout] = null; // Force an update in case the model has been evicted from our GLTF cache\n      // @see https://lit-element.polymer-project.org/guide/lifecycle#requestupdate\n\n      this.requestUpdate('src', null);\n    }\n  }\n\n  disconnectedCallback() {\n    super.disconnectedCallback && super.disconnectedCallback();\n\n    if (HAS_RESIZE_OBSERVER) {\n      this[$resizeObserver].unobserve(this);\n    } else {\n      self.removeEventListener('resize', this[$fallbackResizeHandler]);\n    }\n\n    if (HAS_INTERSECTION_OBSERVER) {\n      this[$intersectionObserver].unobserve(this);\n    }\n\n    this[$renderer].removeEventListener('contextlost', this[$contextLostHandler]);\n    this[$renderer].unregisterScene(this[$scene]);\n    this[$selectCanvas]();\n    this[$clearModelTimeout] = self.setTimeout(() => {\n      this[$scene].model.clear();\n    }, CLEAR_MODEL_TIMEOUT_MS);\n  }\n\n  updated(changedProperties) {\n    super.updated(changedProperties); // NOTE(cdata): If a property changes from values A -> B -> A in the space\n    // of a microtask, LitElement/UpdatingElement will notify of a change even\n    // though the value has effectively not changed, so we need to check to make\n    // sure that the value has actually changed before changing the loaded flag.\n\n    if (changedProperties.has('src') && (this.src == null || this.src !== this[$scene].model.url)) {\n      this[$loaded] = false;\n      this[$loadedTime] = 0;\n      this[$updateSource]();\n    }\n\n    if (changedProperties.has('alt')) {\n      const ariaLabel = this.alt == null ? this[$defaultAriaLabel] : this.alt;\n      this[$userInputElement].setAttribute('aria-label', ariaLabel);\n    }\n  }\n  /** @export */\n\n\n  toDataURL(type, encoderOptions) {\n    return this[$displayCanvas].toDataURL(type, encoderOptions);\n  }\n  /** @export */\n\n\n  async toBlob(options) {\n    const mimeType = options ? options.mimeType : undefined;\n    const qualityArgument = options ? options.qualityArgument : undefined;\n    const idealAspect = options ? options.idealAspect : undefined;\n    const _this$$scene = this[$scene],\n          width = _this$$scene.width,\n          height = _this$$scene.height,\n          model = _this$$scene.model,\n          aspect = _this$$scene.aspect;\n    const dpr = resolveDpr();\n    let outputWidth = width * dpr;\n    let outputHeight = height * dpr;\n    let offsetX = 0;\n    let offsetY = 0;\n\n    if (idealAspect === true) {\n      if (model.fieldOfViewAspect > aspect) {\n        const oldHeight = outputHeight;\n        outputHeight = Math.round(outputWidth / model.fieldOfViewAspect);\n        offsetY = (oldHeight - outputHeight) / 2;\n      } else {\n        const oldWidth = outputWidth;\n        outputWidth = Math.round(outputHeight * model.fieldOfViewAspect);\n        offsetX = (oldWidth - outputWidth) / 2;\n      }\n    }\n\n    blobCanvas.width = outputWidth;\n    blobCanvas.height = outputHeight;\n\n    try {\n      return new Promise(async (resolve, reject) => {\n        if (blobContext == null) {\n          blobContext = blobCanvas.getContext('2d');\n        }\n\n        blobContext.drawImage(this[$displayCanvas], offsetX, offsetY, outputWidth, outputHeight, 0, 0, outputWidth, outputHeight);\n\n        if (blobCanvas.msToBlob) {\n          // NOTE: msToBlob only returns image/png\n          // so ensure mimeType is not specified (defaults to image/png)\n          // or is image/png, otherwise fallback to using toDataURL on IE.\n          if (!mimeType || mimeType === 'image/png') {\n            return resolve(blobCanvas.msToBlob());\n          }\n        }\n\n        if (!blobCanvas.toBlob) {\n          return resolve((await dataUrlToBlob(blobCanvas.toDataURL(mimeType, qualityArgument))));\n        }\n\n        blobCanvas.toBlob(blob => {\n          if (!blob) {\n            return reject(new Error('Unable to retrieve canvas blob'));\n          }\n\n          resolve(blob);\n        }, mimeType, qualityArgument);\n      });\n    } finally {\n      this[$updateSize]({\n        width,\n        height\n      });\n    }\n\n    ;\n  }\n\n  get [$ariaLabel]() {\n    return this.alt == null || this.alt === 'null' ? this[$defaultAriaLabel] : this.alt;\n  } // NOTE(cdata): Although this may seem extremely redundant, it is required in\n  // order to support overloading when TypeScript is compiled to ES5\n  // @see https://github.com/Polymer/lit-element/pull/745\n  // @see https://github.com/microsoft/TypeScript/issues/338\n\n\n  [$getLoaded]() {\n    return this[$loaded];\n  } // @see [$getLoaded]\n\n\n  [$getModelIsVisible]() {\n    return this[$isElementInViewport];\n  }\n  /**\n   * The function enables an optimization, where when there is only a single\n   * <model-viewer> element, we can use the renderer's 3D canvas directly for\n   * display. Otherwise we need to use the element's 2D canvas and copy the\n   * renderer's result into it.\n   */\n\n\n  [$selectCanvas]() {\n    if (this[$renderer].hasOnlyOneScene) {\n      this[$userInputElement].appendChild(this[$renderer].canvasElement);\n      this[$canvas].classList.remove('show');\n    } else {\n      this[$renderer].canvasElement.classList.remove('show');\n    }\n  }\n\n  get [$displayCanvas]() {\n    return this[$renderer].hasOnlyOneScene ? this[$renderer].canvasElement : this[$canvas];\n  }\n  /**\n   * Called on initialization and when the resize observer fires.\n   */\n\n\n  [$updateSize]({\n    width,\n    height\n  }, forceApply = false) {\n    const _this$$scene$getSize = this[$scene].getSize(),\n          prevWidth = _this$$scene$getSize.width,\n          prevHeight = _this$$scene$getSize.height; // Round off the pixel size\n\n\n    const intWidth = parseInt(width, 10);\n    const intHeight = parseInt(height, 10);\n    this[$container].style.width = `${width}px`;\n    this[$container].style.height = `${height}px`;\n\n    if (forceApply || prevWidth !== intWidth || prevHeight !== intHeight) {\n      this[$onResize]({\n        width: intWidth,\n        height: intHeight\n      });\n    }\n  }\n\n  [$tick](_time, _delta) {\n    const dpr = resolveDpr(); // There is no standard way to detect when DPR changes on account of zoom.\n    // Here we keep a local copy of DPR updated, and when it changes we invoke\n    // the fallback resize handler. It might be better to invoke the resize\n    // handler directly in this case, but the fallback is debounced which will\n    // save us from doing too much work when DPR and window size changes at the\n    // same time.\n\n    if (dpr !== this[$lastDpr]) {\n      this[$lastDpr] = dpr;\n      this[$fallbackResizeHandler]();\n    }\n  }\n\n  [$markLoaded]() {\n    if (this[$loaded]) {\n      return;\n    }\n\n    this[$loaded] = true;\n    this[$loadedTime] = performance.now(); // Asynchronously invoke `update`:\n\n    this.requestUpdate();\n  }\n\n  [$needsRender]() {\n    this[$scene].isDirty = true;\n  }\n\n  [$onModelLoad](_event) {\n    this[$needsRender]();\n  }\n\n  [$onResize](e) {\n    this[$scene].setSize(e.width, e.height);\n    this[$needsRender]();\n  }\n\n  [$onContextLost](event) {\n    this.dispatchEvent(new CustomEvent('error', {\n      detail: {\n        type: 'webglcontextlost',\n        sourceError: event.sourceEvent\n      }\n    }));\n  }\n  /**\n   * Parses the element for an appropriate source URL and\n   * sets the views to use the new model based off of the `preload`\n   * attribute.\n   */\n\n\n  async [$updateSource]() {\n    const updateSourceProgress = this[$progressTracker].beginActivity();\n    const source = this.src;\n    const canvas = this[$displayCanvas];\n\n    try {\n      canvas.classList.add('show');\n      await this[$scene].setModelSource(source, progress => updateSourceProgress(progress * 0.9));\n    } catch (error) {\n      canvas.classList.remove('show');\n      this.dispatchEvent(new CustomEvent('error', {\n        detail: error\n      }));\n    } finally {\n      updateSourceProgress(1.0);\n    }\n  }\n\n}\n\n__decorate([property({\n  type: String\n})], ModelViewerElementBase.prototype, \"alt\", void 0);\n\n__decorate([property({\n  converter: {\n    fromAttribute: deserializeUrl\n  }\n})], ModelViewerElementBase.prototype, \"src\", void 0);","map":{"version":3,"sources":["../src/model-viewer-base.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {property} from 'lit-element';\nimport {UpdatingElement} from 'lit-element/lib/updating-element';\nimport {Event as ThreeEvent, Vector3} from 'three';\n\nimport {HAS_INTERSECTION_OBSERVER, HAS_RESIZE_OBSERVER} from './constants.js';\nimport {makeTemplate} from './template.js';\nimport {$evictionPolicy, CachingGLTFLoader} from './three-components/CachingGLTFLoader.js';\nimport {ModelScene} from './three-components/ModelScene.js';\nimport {ContextLostEvent, Renderer} from './three-components/Renderer.js';\nimport {debounce, deserializeUrl, resolveDpr} from './utilities.js';\nimport {dataUrlToBlob} from './utilities/data-conversion.js';\nimport {ProgressTracker} from './utilities/progress-tracker.js';\n\nconst CLEAR_MODEL_TIMEOUT_MS = 1000;\nconst FALLBACK_SIZE_UPDATE_THRESHOLD_MS = 50;\nconst ANNOUNCE_MODEL_VISIBILITY_DEBOUNCE_THRESHOLD = 0;\nconst UNSIZED_MEDIA_WIDTH = 300;\nconst UNSIZED_MEDIA_HEIGHT = 150;\n\nconst blobCanvas = document.createElement('canvas');\nlet blobContext: CanvasRenderingContext2D|null = null;\n\nconst $selectCanvas = Symbol('selectCanvas');\nconst $updateSize = Symbol('updateSize');\nconst $loaded = Symbol('loaded');\nconst $template = Symbol('template');\nconst $fallbackResizeHandler = Symbol('fallbackResizeHandler');\nconst $defaultAriaLabel = Symbol('defaultAriaLabel');\nconst $resizeObserver = Symbol('resizeObserver');\nconst $intersectionObserver = Symbol('intersectionObserver');\nconst $lastDpr = Symbol('lastDpr');\nconst $clearModelTimeout = Symbol('clearModelTimeout');\nconst $onContextLost = Symbol('onContextLost');\nconst $contextLostHandler = Symbol('contextLostHandler');\n\nexport const $isElementInViewport = Symbol('isElementInViewport');\nexport const $announceModelVisibility = Symbol('announceModelVisibility');\nexport const $ariaLabel = Symbol('ariaLabel');\nexport const $loadedTime = Symbol('loadedTime');\nexport const $updateSource = Symbol('updateSource');\nexport const $markLoaded = Symbol('markLoaded');\nexport const $container = Symbol('container');\nexport const $userInputElement = Symbol('input');\nexport const $canvas = Symbol('canvas');\nexport const $displayCanvas = Symbol('displayCanvas');\nexport const $scene = Symbol('scene');\nexport const $needsRender = Symbol('needsRender');\nexport const $tick = Symbol('tick');\nexport const $onModelLoad = Symbol('onModelLoad');\nexport const $onResize = Symbol('onResize');\nexport const $renderer = Symbol('renderer');\nexport const $progressTracker = Symbol('progressTracker');\nexport const $getLoaded = Symbol('getLoaded');\nexport const $getModelIsVisible = Symbol('getModelIsVisible');\n\nexport interface Vector3D {\n  x: number\n  y: number\n  z: number\n  toString(): string\n}\n\nexport const toVector3D = (v: Vector3) => {\n  return {\n    x: v.x,\n    y: v.y,\n    z: v.z,\n    toString() {\n      return `${this.x}m ${this.y}m ${this.z}m`;\n    }\n  };\n};\n\ninterface ToBlobOptions {\n  mimeType?: string, qualityArgument?: number, idealAspect?: boolean\n}\n\n/**\n * Definition for a basic <model-viewer> element.\n */\nexport default class ModelViewerElementBase extends UpdatingElement {\n  protected static[$template]: HTMLTemplateElement|void;\n\n  static get is() {\n    return 'model-viewer';\n  }\n\n  /** @nocollapse */\n  static get template() {\n    if (!this.hasOwnProperty($template)) {\n      this[$template] = makeTemplate(this.is);\n    }\n\n    return this[$template];\n  }\n\n  /** @export */\n  static set modelCacheSize(value: number) {\n    CachingGLTFLoader[$evictionPolicy].evictionThreshold = value;\n  }\n\n  /** @export */\n  static get modelCacheSize(): number {\n    return CachingGLTFLoader[$evictionPolicy].evictionThreshold\n  }\n\n  @property({type: String}) alt: string|null = null;\n\n  @property({converter: {fromAttribute: deserializeUrl}})\n  src: string|null = null;\n\n  protected[$isElementInViewport] = false;\n  protected[$loaded] = false;\n  protected[$loadedTime] = 0;\n  protected[$scene]: ModelScene;\n  protected[$container]: HTMLDivElement;\n  protected[$userInputElement]: HTMLDivElement;\n  protected[$canvas]: HTMLCanvasElement;\n  protected[$defaultAriaLabel]: string;\n  protected[$lastDpr]: number = resolveDpr();\n  protected[$clearModelTimeout]: number|null = null;\n\n  protected[$fallbackResizeHandler] = debounce(() => {\n    const boundingRect = this.getBoundingClientRect();\n    this[$updateSize](boundingRect);\n  }, FALLBACK_SIZE_UPDATE_THRESHOLD_MS);\n\n  protected[$announceModelVisibility] = debounce((oldVisibility: boolean) => {\n    const newVisibility = this.modelIsVisible;\n    if (newVisibility !== oldVisibility) {\n      this.dispatchEvent(new CustomEvent(\n          'model-visibility', {detail: {visible: newVisibility}}));\n    }\n  }, ANNOUNCE_MODEL_VISIBILITY_DEBOUNCE_THRESHOLD);\n\n  protected[$resizeObserver]: ResizeObserver|null = null;\n  protected[$intersectionObserver]: IntersectionObserver|null = null;\n\n  protected[$progressTracker]: ProgressTracker = new ProgressTracker();\n\n  protected[$contextLostHandler] = (event: ContextLostEvent) =>\n      this[$onContextLost](event);\n\n  /** @export */\n  get loaded() {\n    return this[$getLoaded]();\n  }\n\n  get[$renderer]() {\n    return Renderer.singleton;\n  }\n\n  /** @export */\n  get modelIsVisible() {\n    return this[$getModelIsVisible]();\n  }\n\n  /**\n   * Creates a new ModelViewerElement.\n   */\n  constructor() {\n    super();\n\n    // NOTE(cdata): It is *very important* to access this template first so that\n    // the ShadyCSS template preparation steps happen before element styling in\n    // IE11:\n    const template = (this.constructor as any).template as HTMLTemplateElement;\n\n    if ((window as any).ShadyCSS) {\n      (window as any).ShadyCSS.styleElement(this, {});\n    }\n\n    // NOTE(cdata): The canonical ShadyCSS examples suggest that the Shadow Root\n    // should be created after the invocation of ShadyCSS.styleElement\n    this.attachShadow({mode: 'open'});\n\n    const shadowRoot = this.shadowRoot!;\n\n    shadowRoot.appendChild(template.content.cloneNode(true));\n\n    this[$container] = shadowRoot.querySelector('.container') as HTMLDivElement;\n    this[$userInputElement] =\n        shadowRoot.querySelector('.userInput') as HTMLDivElement;\n    this[$canvas] = shadowRoot.querySelector('canvas') as HTMLCanvasElement;\n    this[$defaultAriaLabel] =\n        this[$userInputElement].getAttribute('aria-label')!;\n\n    // Because of potential race conditions related to invoking the constructor\n    // we only use the bounding rect to set the initial size if the element is\n    // already connected to the document:\n    let width, height;\n    if (this.isConnected) {\n      const rect = this.getBoundingClientRect();\n      width = rect.width;\n      height = rect.height;\n    } else {\n      width = UNSIZED_MEDIA_WIDTH;\n      height = UNSIZED_MEDIA_HEIGHT;\n    }\n\n    // Create the underlying ModelScene.\n    this[$scene] =\n        new ModelScene({canvas: this[$canvas], element: this, width, height});\n\n    this[$scene].addEventListener('model-load', (event) => {\n      this[$markLoaded]();\n      this[$onModelLoad](event);\n\n      this.dispatchEvent(\n          new CustomEvent('load', {detail: {url: (event as any).url}}));\n    });\n\n    // Update initial size on microtask timing so that subclasses have a\n    // chance to initialize\n    Promise.resolve().then(() => {\n      this[$updateSize](this.getBoundingClientRect(), true);\n    });\n\n    if (HAS_RESIZE_OBSERVER) {\n      // Set up a resize observer so we can scale our canvas\n      // if our <model-viewer> changes\n      this[$resizeObserver] = new ResizeObserver((entries) => {\n        // Don't resize anything if in AR mode; otherwise the canvas\n        // scaling to fullscreen on entering AR will clobber the flat/2d\n        // dimensions of the element.\n        if (this[$renderer].isPresenting) {\n          return;\n        }\n\n        for (let entry of entries) {\n          if (entry.target === this) {\n            this[$updateSize](entry.contentRect);\n          }\n        }\n      });\n    }\n\n    if (HAS_INTERSECTION_OBSERVER) {\n      const enterRenderTreeProgress = this[$progressTracker].beginActivity();\n\n      this[$intersectionObserver] = new IntersectionObserver(entries => {\n        for (let entry of entries) {\n          if (entry.target === this) {\n            const oldVisibility = this.modelIsVisible;\n            const oldValue = this[$isElementInViewport];\n            this[$isElementInViewport] = this[$scene].visible =\n                entry.isIntersecting;\n            this.requestUpdate($isElementInViewport, oldValue);\n            this[$announceModelVisibility](oldVisibility);\n\n            if (this[$isElementInViewport]) {\n              // Wait a microtask to give other properties a chance to respond\n              // to the state change, then resolve progress on entering the\n              // render tree:\n              Promise.resolve().then(() => {\n                enterRenderTreeProgress(1);\n              });\n            }\n          }\n        }\n      }, {\n        root: null,\n        rootMargin: '10px',\n        threshold: 0,\n      });\n    } else {\n      // If there is no intersection obsever, then all models should be visible\n      // at all times:\n      this[$isElementInViewport] = this[$scene].visible = true;\n      this.requestUpdate($isElementInViewport, false);\n    }\n  }\n\n  connectedCallback() {\n    super.connectedCallback && super.connectedCallback();\n    if (HAS_RESIZE_OBSERVER) {\n      this[$resizeObserver]!.observe(this);\n    } else {\n      self.addEventListener('resize', this[$fallbackResizeHandler]);\n    }\n\n    if (HAS_INTERSECTION_OBSERVER) {\n      this[$intersectionObserver]!.observe(this);\n    }\n\n    this[$renderer].addEventListener(\n        'contextlost',\n        this[$contextLostHandler] as (event: ThreeEvent) => void);\n\n    this[$renderer].registerScene(this[$scene]);\n    this[$selectCanvas]();\n    this[$scene].isDirty = true;\n\n    if (this[$clearModelTimeout] != null) {\n      self.clearTimeout(this[$clearModelTimeout]!);\n      this[$clearModelTimeout] = null;\n      // Force an update in case the model has been evicted from our GLTF cache\n      // @see https://lit-element.polymer-project.org/guide/lifecycle#requestupdate\n      this.requestUpdate('src', null);\n    }\n  }\n\n  disconnectedCallback() {\n    super.disconnectedCallback && super.disconnectedCallback();\n    if (HAS_RESIZE_OBSERVER) {\n      this[$resizeObserver]!.unobserve(this);\n    } else {\n      self.removeEventListener('resize', this[$fallbackResizeHandler]);\n    }\n\n    if (HAS_INTERSECTION_OBSERVER) {\n      this[$intersectionObserver]!.unobserve(this);\n    }\n\n    this[$renderer].removeEventListener(\n        'contextlost',\n        this[$contextLostHandler] as (event: ThreeEvent) => void);\n\n    this[$renderer].unregisterScene(this[$scene]);\n    this[$selectCanvas]();\n\n    this[$clearModelTimeout] = self.setTimeout(() => {\n      this[$scene].model.clear();\n    }, CLEAR_MODEL_TIMEOUT_MS);\n  }\n\n  updated(changedProperties: Map<string|number|symbol, any>) {\n    super.updated(changedProperties);\n\n    // NOTE(cdata): If a property changes from values A -> B -> A in the space\n    // of a microtask, LitElement/UpdatingElement will notify of a change even\n    // though the value has effectively not changed, so we need to check to make\n    // sure that the value has actually changed before changing the loaded flag.\n    if (changedProperties.has('src') &&\n        (this.src == null || this.src !== this[$scene].model.url)) {\n      this[$loaded] = false;\n      this[$loadedTime] = 0;\n      this[$updateSource]();\n    }\n\n    if (changedProperties.has('alt')) {\n      const ariaLabel = this.alt == null ? this[$defaultAriaLabel] : this.alt;\n      this[$userInputElement].setAttribute('aria-label', ariaLabel);\n    }\n  }\n\n  /** @export */\n  toDataURL(type?: string, encoderOptions?: number): string {\n    return this[$displayCanvas].toDataURL(type, encoderOptions);\n  }\n\n  /** @export */\n  async toBlob(options?: ToBlobOptions): Promise<Blob> {\n    const mimeType = options ? options.mimeType : undefined;\n    const qualityArgument = options ? options.qualityArgument : undefined;\n    const idealAspect = options ? options.idealAspect : undefined;\n\n    const {width, height, model, aspect} = this[$scene];\n    const dpr = resolveDpr();\n    let outputWidth = width * dpr;\n    let outputHeight = height * dpr;\n    let offsetX = 0;\n    let offsetY = 0;\n    if (idealAspect === true) {\n      if (model.fieldOfViewAspect > aspect) {\n        const oldHeight = outputHeight;\n        outputHeight = Math.round(outputWidth / model.fieldOfViewAspect);\n        offsetY = (oldHeight - outputHeight) / 2;\n      } else {\n        const oldWidth = outputWidth;\n        outputWidth = Math.round(outputHeight * model.fieldOfViewAspect);\n        offsetX = (oldWidth - outputWidth) / 2;\n      }\n    }\n    blobCanvas.width = outputWidth;\n    blobCanvas.height = outputHeight;\n    try {\n      return new Promise<Blob>(async (resolve, reject) => {\n        if (blobContext == null) {\n          blobContext = blobCanvas.getContext('2d');\n        }\n        blobContext!.drawImage(\n            this[$displayCanvas],\n            offsetX,\n            offsetY,\n            outputWidth,\n            outputHeight,\n            0,\n            0,\n            outputWidth,\n            outputHeight);\n        if ((blobCanvas as any).msToBlob) {\n          // NOTE: msToBlob only returns image/png\n          // so ensure mimeType is not specified (defaults to image/png)\n          // or is image/png, otherwise fallback to using toDataURL on IE.\n          if (!mimeType || mimeType === 'image/png') {\n            return resolve((blobCanvas as any).msToBlob());\n          }\n        }\n\n        if (!blobCanvas.toBlob) {\n          return resolve(await dataUrlToBlob(\n              blobCanvas.toDataURL(mimeType, qualityArgument)));\n        }\n\n        blobCanvas.toBlob((blob) => {\n          if (!blob) {\n            return reject(new Error('Unable to retrieve canvas blob'));\n          }\n\n          resolve(blob);\n        }, mimeType, qualityArgument);\n      })\n    } finally {\n      this[$updateSize]({width, height});\n    };\n  }\n\n  get[$ariaLabel]() {\n    return (this.alt == null || this.alt === 'null') ? this[$defaultAriaLabel] :\n                                                       this.alt;\n  }\n\n  // NOTE(cdata): Although this may seem extremely redundant, it is required in\n  // order to support overloading when TypeScript is compiled to ES5\n  // @see https://github.com/Polymer/lit-element/pull/745\n  // @see https://github.com/microsoft/TypeScript/issues/338\n  [$getLoaded](): boolean {\n    return this[$loaded];\n  }\n\n  // @see [$getLoaded]\n  [$getModelIsVisible](): boolean {\n    return this[$isElementInViewport];\n  }\n\n  /**\n   * The function enables an optimization, where when there is only a single\n   * <model-viewer> element, we can use the renderer's 3D canvas directly for\n   * display. Otherwise we need to use the element's 2D canvas and copy the\n   * renderer's result into it.\n   */\n  [$selectCanvas]() {\n    if (this[$renderer].hasOnlyOneScene) {\n      this[$userInputElement].appendChild(this[$renderer].canvasElement);\n      this[$canvas].classList.remove('show');\n    } else {\n      this[$renderer].canvasElement.classList.remove('show');\n    }\n  }\n\n  get[$displayCanvas]() {\n    return this[$renderer].hasOnlyOneScene ? this[$renderer].canvasElement :\n                                             this[$canvas];\n  }\n\n  /**\n   * Called on initialization and when the resize observer fires.\n   */\n  [$updateSize](\n      {width, height}: {width: any, height: any}, forceApply = false) {\n    const {width: prevWidth, height: prevHeight} = this[$scene].getSize();\n    // Round off the pixel size\n    const intWidth = parseInt(width, 10);\n    const intHeight = parseInt(height, 10);\n\n    this[$container].style.width = `${width}px`;\n    this[$container].style.height = `${height}px`;\n\n    if (forceApply || (prevWidth !== intWidth || prevHeight !== intHeight)) {\n      this[$onResize]({width: intWidth, height: intHeight});\n    }\n  }\n\n  [$tick](_time: number, _delta: number) {\n    const dpr = resolveDpr();\n    // There is no standard way to detect when DPR changes on account of zoom.\n    // Here we keep a local copy of DPR updated, and when it changes we invoke\n    // the fallback resize handler. It might be better to invoke the resize\n    // handler directly in this case, but the fallback is debounced which will\n    // save us from doing too much work when DPR and window size changes at the\n    // same time.\n    if (dpr !== this[$lastDpr]) {\n      this[$lastDpr] = dpr;\n      this[$fallbackResizeHandler]();\n    }\n  }\n\n  [$markLoaded]() {\n    if (this[$loaded]) {\n      return;\n    }\n\n    this[$loaded] = true;\n    this[$loadedTime] = performance.now();\n    // Asynchronously invoke `update`:\n    this.requestUpdate();\n  }\n\n  [$needsRender]() {\n    this[$scene].isDirty = true;\n  }\n\n  [$onModelLoad](_event: any) {\n    this[$needsRender]();\n  }\n\n  [$onResize](e: {width: number, height: number}) {\n    this[$scene].setSize(e.width, e.height);\n    this[$needsRender]();\n  }\n\n  [$onContextLost](event: ContextLostEvent) {\n    this.dispatchEvent(new CustomEvent(\n        'error',\n        {detail: {type: 'webglcontextlost', sourceError: event.sourceEvent}}));\n  }\n\n  /**\n   * Parses the element for an appropriate source URL and\n   * sets the views to use the new model based off of the `preload`\n   * attribute.\n   */\n  async[$updateSource]() {\n    const updateSourceProgress = this[$progressTracker].beginActivity();\n    const source = this.src;\n\n    const canvas = this[$displayCanvas];\n    try {\n      canvas.classList.add('show');\n      await this[$scene].setModelSource(\n          source, (progress: number) => updateSourceProgress(progress * 0.9));\n    } catch (error) {\n      canvas.classList.remove('show');\n      this.dispatchEvent(new CustomEvent('error', {detail: error}));\n    } finally {\n      updateSourceProgress(1.0);\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}