{"ast":null,"code":"var geometries = require('../core/geometry').geometries;\n\nvar registerSystem = require('../core/system').registerSystem;\n\nvar THREE = require('../lib/three');\n/**\n * System for geometry component.\n * Handle geometry caching.\n *\n * @member {object} cache - Mapping of stringified component data to THREE.Geometry objects.\n * @member {object} cacheCount - Keep track of number of entities using a geometry to\n *         know whether to dispose on removal.\n */\n\n\nmodule.exports.System = registerSystem('geometry', {\n  init: function () {\n    this.cache = {};\n    this.cacheCount = {};\n  },\n\n  /**\n   * Reset cache. Mainly for testing.\n   */\n  clearCache: function () {\n    this.cache = {};\n    this.cacheCount = {};\n  },\n\n  /**\n   * Attempt to retrieve from cache.\n   *\n   * @returns {Object|null} A geometry if it exists, else null.\n   */\n  getOrCreateGeometry: function (data) {\n    var cache = this.cache;\n    var cachedGeometry;\n    var hash; // Skip all caching logic.\n\n    if (data.skipCache) {\n      return createGeometry(data);\n    } // Try to retrieve from cache first.\n\n\n    hash = this.hash(data);\n    cachedGeometry = cache[hash];\n    incrementCacheCount(this.cacheCount, hash);\n\n    if (cachedGeometry) {\n      return cachedGeometry;\n    } // Create geometry.\n\n\n    cachedGeometry = createGeometry(data); // Cache and return geometry.\n\n    cache[hash] = cachedGeometry;\n    return cachedGeometry;\n  },\n\n  /**\n   * Let system know that an entity is no longer using a geometry.\n   */\n  unuseGeometry: function (data) {\n    var cache = this.cache;\n    var cacheCount = this.cacheCount;\n    var geometry;\n    var hash;\n\n    if (data.skipCache) {\n      return;\n    }\n\n    hash = this.hash(data);\n\n    if (!cache[hash]) {\n      return;\n    }\n\n    decrementCacheCount(cacheCount, hash); // Another entity is still using this geometry. No need to do anything.\n\n    if (cacheCount[hash] > 0) {\n      return;\n    } // No more entities are using this geometry. Dispose.\n\n\n    geometry = cache[hash];\n    geometry.dispose();\n    delete cache[hash];\n    delete cacheCount[hash];\n  },\n\n  /**\n   * Use JSON.stringify to turn component data into hash.\n   * Should be deterministic within a single browser engine.\n   * If not, then look into json-stable-stringify.\n   */\n  hash: function (data) {\n    return JSON.stringify(data);\n  }\n});\n/**\n * Create geometry using component data.\n *\n * @param {object} data - Component data.\n * @returns {object} Geometry.\n */\n\nfunction createGeometry(data) {\n  var geometryType = data.primitive;\n  var GeometryClass = geometries[geometryType] && geometries[geometryType].Geometry;\n  var geometryInstance = new GeometryClass();\n\n  if (!GeometryClass) {\n    throw new Error('Unknown geometry `' + geometryType + '`');\n  }\n\n  geometryInstance.init(data);\n  return toBufferGeometry(geometryInstance.geometry, data.buffer);\n}\n/**\n * Decreate count of entity using a geometry.\n */\n\n\nfunction decrementCacheCount(cacheCount, hash) {\n  cacheCount[hash]--;\n}\n/**\n * Increase count of entity using a geometry.\n */\n\n\nfunction incrementCacheCount(cacheCount, hash) {\n  cacheCount[hash] = cacheCount[hash] === undefined ? 1 : cacheCount[hash] + 1;\n}\n/**\n * Transform geometry to BufferGeometry if `doBuffer`.\n *\n * @param {object} geometry\n * @param {boolean} doBuffer\n * @returns {object} Geometry.\n */\n\n\nfunction toBufferGeometry(geometry, doBuffer) {\n  var bufferGeometry;\n\n  if (!doBuffer) {\n    return geometry;\n  }\n\n  bufferGeometry = new THREE.BufferGeometry().fromGeometry(geometry);\n  bufferGeometry.metadata = {\n    type: geometry.type,\n    parameters: geometry.parameters || {}\n  };\n  geometry.dispose(); // Dispose no longer needed non-buffer geometry.\n\n  return bufferGeometry;\n}","map":{"version":3,"sources":["C:/Users/Hannuri/Desktop/RoyalCyber/my-first-app/node_modules/aframe/src/systems/geometry.js"],"names":["geometries","require","registerSystem","THREE","module","exports","System","init","cache","cacheCount","clearCache","getOrCreateGeometry","data","cachedGeometry","hash","skipCache","createGeometry","incrementCacheCount","unuseGeometry","geometry","decrementCacheCount","dispose","JSON","stringify","geometryType","primitive","GeometryClass","Geometry","geometryInstance","Error","toBufferGeometry","buffer","undefined","doBuffer","bufferGeometry","BufferGeometry","fromGeometry","metadata","type","parameters"],"mappings":"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","sourcesContent":["var geometries = require('../core/geometry').geometries;\nvar registerSystem = require('../core/system').registerSystem;\nvar THREE = require('../lib/three');\n\n/**\n * System for geometry component.\n * Handle geometry caching.\n *\n * @member {object} cache - Mapping of stringified component data to THREE.Geometry objects.\n * @member {object} cacheCount - Keep track of number of entities using a geometry to\n *         know whether to dispose on removal.\n */\nmodule.exports.System = registerSystem('geometry', {\n  init: function () {\n    this.cache = {};\n    this.cacheCount = {};\n  },\n\n  /**\n   * Reset cache. Mainly for testing.\n   */\n  clearCache: function () {\n    this.cache = {};\n    this.cacheCount = {};\n  },\n\n  /**\n   * Attempt to retrieve from cache.\n   *\n   * @returns {Object|null} A geometry if it exists, else null.\n   */\n  getOrCreateGeometry: function (data) {\n    var cache = this.cache;\n    var cachedGeometry;\n    var hash;\n\n    // Skip all caching logic.\n    if (data.skipCache) { return createGeometry(data); }\n\n    // Try to retrieve from cache first.\n    hash = this.hash(data);\n    cachedGeometry = cache[hash];\n    incrementCacheCount(this.cacheCount, hash);\n\n    if (cachedGeometry) { return cachedGeometry; }\n\n    // Create geometry.\n    cachedGeometry = createGeometry(data);\n\n    // Cache and return geometry.\n    cache[hash] = cachedGeometry;\n    return cachedGeometry;\n  },\n\n  /**\n   * Let system know that an entity is no longer using a geometry.\n   */\n  unuseGeometry: function (data) {\n    var cache = this.cache;\n    var cacheCount = this.cacheCount;\n    var geometry;\n    var hash;\n\n    if (data.skipCache) { return; }\n\n    hash = this.hash(data);\n\n    if (!cache[hash]) { return; }\n\n    decrementCacheCount(cacheCount, hash);\n\n    // Another entity is still using this geometry. No need to do anything.\n    if (cacheCount[hash] > 0) { return; }\n\n    // No more entities are using this geometry. Dispose.\n    geometry = cache[hash];\n    geometry.dispose();\n    delete cache[hash];\n    delete cacheCount[hash];\n  },\n\n  /**\n   * Use JSON.stringify to turn component data into hash.\n   * Should be deterministic within a single browser engine.\n   * If not, then look into json-stable-stringify.\n   */\n  hash: function (data) {\n    return JSON.stringify(data);\n  }\n});\n\n/**\n * Create geometry using component data.\n *\n * @param {object} data - Component data.\n * @returns {object} Geometry.\n */\nfunction createGeometry (data) {\n  var geometryType = data.primitive;\n  var GeometryClass = geometries[geometryType] && geometries[geometryType].Geometry;\n  var geometryInstance = new GeometryClass();\n\n  if (!GeometryClass) { throw new Error('Unknown geometry `' + geometryType + '`'); }\n\n  geometryInstance.init(data);\n  return toBufferGeometry(geometryInstance.geometry, data.buffer);\n}\n\n/**\n * Decreate count of entity using a geometry.\n */\nfunction decrementCacheCount (cacheCount, hash) {\n  cacheCount[hash]--;\n}\n\n/**\n * Increase count of entity using a geometry.\n */\nfunction incrementCacheCount (cacheCount, hash) {\n  cacheCount[hash] = cacheCount[hash] === undefined ? 1 : cacheCount[hash] + 1;\n}\n\n/**\n * Transform geometry to BufferGeometry if `doBuffer`.\n *\n * @param {object} geometry\n * @param {boolean} doBuffer\n * @returns {object} Geometry.\n */\nfunction toBufferGeometry (geometry, doBuffer) {\n  var bufferGeometry;\n  if (!doBuffer) { return geometry; }\n\n  bufferGeometry = new THREE.BufferGeometry().fromGeometry(geometry);\n  bufferGeometry.metadata = {type: geometry.type, parameters: geometry.parameters || {}};\n  geometry.dispose();  // Dispose no longer needed non-buffer geometry.\n  return bufferGeometry;\n}\n"]},"metadata":{},"sourceType":"script"}