{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ZERO } from './parsers';\n/**\n * Ensures that a given number is expressed in radians. If the number is already\n * in radians, does nothing. If the value is in degrees, converts it to radians.\n * If the value has no specified unit, the unit is assumed to be radians. If the\n * value is not in radians or degrees, the value is resolved as 0 radians.\n *\n * Also accepts a second argument that is a default value to use if the input\n * numberNode number is NaN or Infinity.\n */\n\nexport const degreesToRadians = (numberNode, fallbackRadianValue = 0) => {\n  let number = numberNode.number,\n      unit = numberNode.unit;\n\n  if (!isFinite(number)) {\n    number = fallbackRadianValue;\n    unit = 'rad';\n  } else if (numberNode.unit === 'rad' || numberNode.unit == null) {\n    return numberNode;\n  }\n\n  const valueIsDegrees = unit === 'deg' && number != null;\n  const value = valueIsDegrees ? number : 0;\n  const radians = value * Math.PI / 180;\n  return {\n    type: 'number',\n    number: radians,\n    unit: 'rad'\n  };\n};\n/**\n * Ensures that a given number is expressed in degrees. If the number is alrady\n * in degrees, does nothing. If the value is in radians or has no specified\n * unit, converts it to degrees. If the value is not in radians or degrees, the\n * value is resolved as 0 degrees.\n *\n * Also accepts a second argument that is a default value to use if the input\n * numberNode number is NaN or Infinity.\n */\n\nexport const radiansToDegrees = (numberNode, fallbackDegreeValue = 0) => {\n  let number = numberNode.number,\n      unit = numberNode.unit;\n\n  if (!isFinite(number)) {\n    number = fallbackDegreeValue;\n    unit = 'deg';\n  } else if (numberNode.unit === 'deg') {\n    return numberNode;\n  }\n\n  const valueIsRadians = (unit === null || unit === 'rad') && number != null;\n  const value = valueIsRadians ? number : 0;\n  const degrees = value * 180 / Math.PI;\n  return {\n    type: 'number',\n    number: degrees,\n    unit: 'deg'\n  };\n};\n/**\n * Converts a given length to meters. Currently supported input units are\n * meters, centimeters and millimeters.\n *\n * Also accepts a second argument that is a default value to use if the input\n * numberNode number is NaN or Infinity.\n */\n\nexport const lengthToBaseMeters = (numberNode, fallbackMeterValue = 0) => {\n  let number = numberNode.number,\n      unit = numberNode.unit;\n\n  if (!isFinite(number)) {\n    number = fallbackMeterValue;\n    unit = 'm';\n  } else if (numberNode.unit === 'm') {\n    return numberNode;\n  }\n\n  let scale;\n\n  switch (unit) {\n    default:\n      scale = 1;\n      break;\n\n    case 'cm':\n      scale = 1 / 100;\n      break;\n\n    case 'mm':\n      scale = 1 / 1000;\n      break;\n  }\n\n  const value = scale * number;\n  return {\n    type: 'number',\n    number: value,\n    unit: 'm'\n  };\n};\n/**\n * Normalizes the unit of a given input number so that it is expressed in a\n * preferred unit. For length nodes, the return value will be expressed in\n * meters. For angle nodes, the return value will be expressed in radians.\n *\n * Also takes a fallback number that is used when the number value is not a\n * valid number or when the unit of the given number cannot be normalized.\n */\n\nexport const normalizeUnit = (() => {\n  const identity = node => node;\n\n  const unitNormalizers = {\n    'rad': identity,\n    'deg': degreesToRadians,\n    'm': identity,\n    'mm': lengthToBaseMeters,\n    'cm': lengthToBaseMeters\n  };\n  return (node, fallback = ZERO) => {\n    let number = node.number,\n        unit = node.unit;\n\n    if (!isFinite(number)) {\n      number = fallback.number;\n      unit = fallback.unit;\n    }\n\n    if (unit == null) {\n      return node;\n    }\n\n    const normalize = unitNormalizers[unit];\n\n    if (normalize == null) {\n      return fallback;\n    }\n\n    return normalize(node);\n  };\n})();","map":{"version":3,"sources":["../../src/styles/conversions.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {NumberNode, ZERO} from './parsers';\n\n/**\n * Ensures that a given number is expressed in radians. If the number is already\n * in radians, does nothing. If the value is in degrees, converts it to radians.\n * If the value has no specified unit, the unit is assumed to be radians. If the\n * value is not in radians or degrees, the value is resolved as 0 radians.\n *\n * Also accepts a second argument that is a default value to use if the input\n * numberNode number is NaN or Infinity.\n */\nexport const degreesToRadians =\n    (numberNode: NumberNode, fallbackRadianValue: number = 0): NumberNode => {\n      let {number, unit} = numberNode;\n      if (!isFinite(number)) {\n        number = fallbackRadianValue;\n        unit = 'rad';\n      } else if (numberNode.unit === 'rad' || numberNode.unit == null) {\n        return numberNode;\n      }\n\n      const valueIsDegrees = unit === 'deg' && number != null;\n      const value = valueIsDegrees ? number : 0;\n      const radians = value * Math.PI / 180;\n\n      return {type: 'number', number: radians, unit: 'rad'};\n    };\n\n/**\n * Ensures that a given number is expressed in degrees. If the number is alrady\n * in degrees, does nothing. If the value is in radians or has no specified\n * unit, converts it to degrees. If the value is not in radians or degrees, the\n * value is resolved as 0 degrees.\n *\n * Also accepts a second argument that is a default value to use if the input\n * numberNode number is NaN or Infinity.\n */\nexport const radiansToDegrees =\n    (numberNode: NumberNode, fallbackDegreeValue: number = 0): NumberNode => {\n      let {number, unit} = numberNode;\n\n      if (!isFinite(number)) {\n        number = fallbackDegreeValue;\n        unit = 'deg';\n      } else if (numberNode.unit === 'deg') {\n        return numberNode;\n      }\n\n      const valueIsRadians =\n          (unit === null || unit === 'rad') && number != null;\n\n      const value = valueIsRadians ? number : 0;\n      const degrees = value * 180 / Math.PI;\n\n      return {type: 'number', number: degrees, unit: 'deg'};\n    };\n\n/**\n * Converts a given length to meters. Currently supported input units are\n * meters, centimeters and millimeters.\n *\n * Also accepts a second argument that is a default value to use if the input\n * numberNode number is NaN or Infinity.\n */\nexport const lengthToBaseMeters =\n    (numberNode: NumberNode, fallbackMeterValue: number = 0): NumberNode => {\n      let {number, unit} = numberNode;\n\n      if (!isFinite(number)) {\n        number = fallbackMeterValue;\n        unit = 'm';\n      } else if (numberNode.unit === 'm') {\n        return numberNode;\n      }\n\n      let scale;\n\n      switch (unit) {\n        default:\n          scale = 1;\n          break;\n        case 'cm':\n          scale = 1 / 100;\n          break;\n        case 'mm':\n          scale = 1 / 1000;\n          break;\n      }\n\n      const value = scale * number;\n      return {type: 'number', number: value, unit: 'm'};\n    };\n\n/**\n * Normalizes the unit of a given input number so that it is expressed in a\n * preferred unit. For length nodes, the return value will be expressed in\n * meters. For angle nodes, the return value will be expressed in radians.\n *\n * Also takes a fallback number that is used when the number value is not a\n * valid number or when the unit of the given number cannot be normalized.\n */\nexport const normalizeUnit = (() => {\n  const identity = (node: NumberNode) => node;\n  const unitNormalizers: {[index: string]: (node: NumberNode) => NumberNode} = {\n    'rad': identity,\n    'deg': degreesToRadians,\n    'm': identity,\n    'mm': lengthToBaseMeters,\n    'cm': lengthToBaseMeters\n  };\n\n  return (node: NumberNode, fallback: NumberNode = ZERO) => {\n    let {number, unit} = node;\n\n    if (!isFinite(number)) {\n      number = fallback.number;\n      unit = fallback.unit;\n    }\n\n    if (unit == null) {\n      return node;\n    }\n\n    const normalize = unitNormalizers[unit];\n\n    if (normalize == null) {\n      return fallback;\n    }\n\n    return normalize(node);\n  };\n})();"],"sourceRoot":""},"metadata":{},"sourceType":"module"}