{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9;\n\nimport { EventDispatcher, Matrix4, PerspectiveCamera, Ray, Vector3 } from 'three';\nimport { $needsRender, $onResize } from '../model-viewer-base.js';\nimport { assertIsArCandidate } from '../utilities.js';\nimport { Damper } from './Damper.js';\nimport { PlacementBox } from './PlacementBox.js';\nimport { assertContext } from './WebGLUtils.js'; // AR shadow is not user-configurable. This is to pave the way for AR lighting\n// estimation, which will be used once available in WebXR.\n\nconst AR_SHADOW_INTENSITY = 0.3;\nconst ROTATION_RATE = 1.5; // Angle down (towards bottom of screen) from camera center ray to use for hit\n// testing against the floor. This makes placement faster and more intuitive\n// assuming the phone is in portrait mode. This seems to be a reasonable\n// assumption for the start of the session and UI will lack landscape mode to\n// encourage upright use.\n\nconst HIT_ANGLE_DEG = 20; // Slow down the dampers for initial placement.\n\nconst INTRO_DAMPER_RATE = 0.4;\nconst SCALE_SNAP_HIGH = 1.2;\nconst SCALE_SNAP_LOW = 1 / SCALE_SNAP_HIGH;\nconst $presentedScene = Symbol('presentedScene');\nconst $placementBox = Symbol('placementBox');\nconst $lastTick = Symbol('lastTick');\nconst $turntableRotation = Symbol('turntableRotation');\nconst $oldShadowIntensity = Symbol('oldShadowIntensity');\nconst $oldBackground = Symbol('oldBackground');\nconst $rafId = Symbol('rafId');\nexport const $currentSession = Symbol('currentSession');\nconst $tick = Symbol('tick');\nconst $refSpace = Symbol('refSpace');\nconst $viewerRefSpace = Symbol('viewerRefSpace');\nconst $frame = Symbol('frame');\nconst $initialized = Symbol('initialized');\nconst $initialModelToWorld = Symbol('initialModelToWorld');\nconst $placementComplete = Symbol('placementComplete');\nconst $initialHitSource = Symbol('hitTestSource');\nconst $transientHitTestSource = Symbol('transiertHitTestSource');\nconst $inputSource = Symbol('inputSource');\nconst $isTranslating = Symbol('isTranslating');\nconst $isRotating = Symbol('isRotating');\nconst $isScaling = Symbol('isScaling');\nconst $lastDragPosition = Symbol('lastDragPosition');\nconst $lastScalar = Symbol('lastScalar');\nconst $goalPosition = Symbol('goalPosition');\nconst $goalYaw = Symbol('goalYaw');\nconst $goalScale = Symbol('goalScale');\nconst $xDamper = Symbol('xDamper');\nconst $yDamper = Symbol('yDamper');\nconst $zDamper = Symbol('zDamper');\nconst $yawDamper = Symbol('yawDamper');\nconst $scaleDamper = Symbol('scaleDamper');\nconst $damperRate = Symbol('damperRate');\nconst $resolveCleanup = Symbol('resolveCleanup');\nexport const $onWebXRFrame = Symbol('onWebXRFrame');\nconst $postSessionCleanup = Symbol('postSessionCleanup');\nconst $updateCamera = Symbol('updateCamera');\nconst $placeInitially = Symbol('placeInitially');\nconst $getHitPoint = Symbol('getHitPoint');\nconst $selectStartHandler = Symbol('selectStartHandler');\nconst $onSelectStart = Symbol('onSelectStart');\nconst $selectEndHandler = Symbol('selectHandler');\nconst $onSelectEnd = Symbol('onSelect');\nconst $fingerSeparation = Symbol('fingerSeparation');\nconst $processInput = Symbol('processInput');\nconst $moveScene = Symbol('moveScene');\nconst vector3 = new Vector3();\nconst matrix4 = new Matrix4();\nconst hitPosition = new Vector3();\nexport class ARRenderer extends EventDispatcher {\n  constructor(renderer) {\n    super();\n    this.renderer = renderer;\n    this.camera = new PerspectiveCamera();\n    this[_a] = null;\n    this[_b] = null;\n    this[_c] = null;\n    this[_d] = null;\n    this[_e] = null;\n    this[_f] = null;\n    this[_g] = null;\n    this[_h] = null;\n    this[_j] = null;\n    this[_k] = null;\n    this[_l] = null;\n    this[_m] = null;\n    this[_o] = null;\n    this[_p] = null;\n    this[_q] = null;\n    this[_r] = false;\n    this[_s] = new Matrix4();\n    this[_t] = false;\n    this[_u] = false;\n    this[_v] = false;\n    this[_w] = false;\n    this[_x] = new Vector3();\n    this[_y] = 0;\n    this[_z] = new Vector3();\n    this[_0] = 0;\n    this[_1] = 1;\n    this[_2] = new Damper();\n    this[_3] = new Damper();\n    this[_4] = new Damper();\n    this[_5] = new Damper();\n    this[_6] = new Damper();\n    this[_7] = 1;\n\n    this[_8] = event => this[$onSelectStart](event);\n\n    this[_9] = event => this[$onSelectEnd](event);\n\n    this.threeRenderer = renderer.threeRenderer; // Turn this off, as the matrix is set directly from webXR rather than using\n    // postion, rotation, scale.\n\n    this.camera.matrixAutoUpdate = false;\n  }\n\n  async resolveARSession(scene) {\n    assertIsArCandidate();\n    const session = await navigator.xr.requestSession('immersive-ar', {\n      requiredFeatures: ['hit-test'],\n      optionalFeatures: ['dom-overlay'],\n      domOverlay: {\n        root: document.querySelector('model-viewer').shadowRoot.querySelector('div.annotation-container')\n      }\n    });\n    const gl = assertContext(this.renderer.context3D); // `makeXRCompatible` replaced `setCompatibleXRDevice` in Chrome M73 @TODO\n    // #293, handle WebXR API changes. WARNING: this can cause a GL context\n    // loss according to the spec, though current implementations don't do so.\n\n    await gl.makeXRCompatible();\n    session.updateRenderState({\n      baseLayer: new XRWebGLLayer(session, gl, {\n        alpha: true\n      })\n    }); // The render state update takes effect on the next animation frame. Wait\n    // for it so that we get a framebuffer.\n\n    let waitForAnimationFrame = new Promise((resolve, _reject) => {\n      session.requestAnimationFrame(() => resolve());\n    });\n    await waitForAnimationFrame; // Redirect rendering to the WebXR offscreen framebuffer.\n    // TODO: this method should be added to three.js's exported interface.\n\n    this.threeRenderer.setFramebuffer(session.renderState.baseLayer.framebuffer);\n    scene.element[$onResize](window.screen);\n    return session;\n  }\n  /**\n   * The currently presented scene, if any\n   */\n\n\n  get presentedScene() {\n    return this[$presentedScene];\n  }\n  /**\n   * Resolves to true if the renderer has detected all the necessary qualities\n   * to support presentation in AR.\n   */\n\n\n  async supportsPresentation() {\n    try {\n      assertIsArCandidate();\n      return await navigator.xr.isSessionSupported('immersive-ar');\n    } catch (error) {\n      return false;\n    }\n  }\n  /**\n   * Present a scene in AR\n   */\n\n\n  async present(scene) {\n    if (this.isPresenting) {\n      console.warn('Cannot present while a model is already presenting');\n    }\n\n    const currentSession = await this.resolveARSession(scene);\n    currentSession.addEventListener('end', () => {\n      this[$postSessionCleanup]();\n    }, {\n      once: true\n    });\n    this[$refSpace] = await currentSession.requestReferenceSpace('local');\n    this[$viewerRefSpace] = await currentSession.requestReferenceSpace('viewer');\n    const placementBox = new PlacementBox(scene.model);\n    this[$placementComplete] = false;\n    scene.setCamera(this.camera);\n    this[$initialized] = false;\n    this[$damperRate] = INTRO_DAMPER_RATE;\n    this[$turntableRotation] = scene.yaw;\n    scene.yaw = 0;\n    this[$goalYaw] = 0;\n    this[$goalScale] = 1;\n    this[$oldBackground] = scene.background;\n    scene.background = null;\n    this[$oldShadowIntensity] = scene.shadowIntensity;\n    scene.setShadowIntensity(0);\n    const radians = HIT_ANGLE_DEG * Math.PI / 180;\n    const ray = new XRRay(new DOMPoint(0, 0, 0), new DOMPoint(0, -Math.sin(radians), -Math.cos(radians)));\n    currentSession.requestHitTestSource({\n      space: this[$viewerRefSpace],\n      offsetRay: ray\n    }).then(hitTestSource => {\n      this[$initialHitSource] = hitTestSource;\n    });\n    this[$currentSession] = currentSession;\n    this[$presentedScene] = scene;\n    this[$placementBox] = placementBox;\n    this[$lastTick] = performance.now(); // Start the event loop.\n\n    this[$tick]();\n  }\n  /**\n   * If currently presenting a scene in AR, stops presentation and exits AR.\n   */\n\n\n  async stopPresenting() {\n    if (!this.isPresenting) {\n      return;\n    }\n\n    const cleanupPromise = new Promise(resolve => {\n      this[$resolveCleanup] = resolve;\n    });\n\n    try {\n      const session = this[$currentSession];\n      session.removeEventListener('selectstart', this[$selectStartHandler]);\n      session.removeEventListener('selectend', this[$selectEndHandler]);\n      this[$currentSession] = null;\n      session.cancelAnimationFrame(this[$rafId]);\n      await session.end();\n      await cleanupPromise;\n    } catch (error) {\n      console.warn('Error while trying to end AR session');\n      console.warn(error);\n      this[$postSessionCleanup]();\n    }\n  }\n\n  [(_a = $placementBox, _b = $lastTick, _c = $turntableRotation, _d = $oldShadowIntensity, _e = $oldBackground, _f = $rafId, _g = $currentSession, _h = $refSpace, _j = $viewerRefSpace, _k = $frame, _l = $initialHitSource, _m = $transientHitTestSource, _o = $inputSource, _p = $presentedScene, _q = $resolveCleanup, _r = $initialized, _s = $initialModelToWorld, _t = $placementComplete, _u = $isTranslating, _v = $isRotating, _w = $isScaling, _x = $lastDragPosition, _y = $lastScalar, _z = $goalPosition, _0 = $goalYaw, _1 = $goalScale, _2 = $xDamper, _3 = $yDamper, _4 = $zDamper, _5 = $yawDamper, _6 = $scaleDamper, _7 = $damperRate, _8 = $selectStartHandler, _9 = $selectEndHandler, $postSessionCleanup)]() {\n    // The offscreen WebXR framebuffer is now invalid, switch\n    // back to the default framebuffer for canvas output.\n    // TODO: this method should be added to three.js's exported interface.\n    this.threeRenderer.setFramebuffer(null);\n    const scene = this[$presentedScene];\n\n    if (scene != null) {\n      const model = scene.model,\n            element = scene.element;\n      scene.setCamera(scene.camera);\n      model.remove(this[$placementBox]);\n      scene.position.set(0, 0, 0);\n      scene.scale.set(1, 1, 1);\n      model.setShadowScaleAndOffset(1, 0);\n      scene.yaw = this[$turntableRotation];\n      scene.setShadowIntensity(this[$oldShadowIntensity]);\n      scene.background = this[$oldBackground];\n      model.orientHotspots(0);\n      element.requestUpdate('cameraTarget');\n      element[$needsRender]();\n      this.renderer.expandTo(scene.width, scene.height);\n    }\n\n    if (this[$placementBox] != null) {\n      this[$placementBox].dispose();\n      this[$placementBox] = null;\n    }\n\n    this[$refSpace] = null;\n    this[$presentedScene] = null;\n\n    if (this[$resolveCleanup] != null) {\n      this[$resolveCleanup]();\n    }\n  }\n  /**\n   * True if a scene is currently in the process of being presented in AR\n   */\n\n\n  get isPresenting() {\n    return this[$presentedScene] != null;\n  }\n\n  [$updateCamera](view) {\n    const camera = this.camera;\n    const cameraMatrix = camera.matrix;\n    cameraMatrix.fromArray(view.transform.matrix);\n    camera.updateMatrixWorld(true); // position is not updated when matrix is updated.\n\n    camera.position.setFromMatrixPosition(cameraMatrix);\n\n    if (this[$initialHitSource] != null) {\n      // Target locked to screen center\n      const _this$$presentedScene = this[$presentedScene],\n            position = _this$$presentedScene.position,\n            model = _this$$presentedScene.model;\n      const radius = model.idealCameraDistance;\n      camera.getWorldDirection(position);\n      position.multiplyScalar(radius);\n      position.add(camera.position);\n    }\n\n    if (!this[$initialized]) {\n      camera.projectionMatrix.fromArray(view.projectionMatrix); // Have to set the inverse manually when setting matrix directly. This is\n      // needed for raycasting.\n\n      camera.projectionMatrixInverse.getInverse(camera.projectionMatrix); // Orient model toward camera on first frame.\n\n      const _camera$position = camera.position,\n            x = _camera$position.x,\n            z = _camera$position.z;\n      const scene = this[$presentedScene];\n      scene.pointTowards(x, z);\n      scene.model.updateMatrixWorld(true);\n      this[$goalYaw] = scene.yaw;\n      this[$initialModelToWorld].copy(scene.model.matrixWorld);\n      this[$initialized] = true;\n    }\n\n    this[$presentedScene].model.orientHotspots(Math.atan2(cameraMatrix.elements[1], cameraMatrix.elements[5]));\n  }\n\n  [$placeInitially](frame) {\n    const hitSource = this[$initialHitSource];\n\n    if (hitSource == null) {\n      return;\n    }\n\n    const hitTestResults = frame.getHitTestResults(hitSource);\n\n    if (hitTestResults.length == 0) {\n      return;\n    }\n\n    const hit = hitTestResults[0];\n    const hitMatrix = this[$getHitPoint](hit);\n\n    if (hitMatrix == null) {\n      return;\n    }\n\n    this.placeModel(hitMatrix);\n    hitSource.cancel();\n    this[$initialHitSource] = null;\n    const session = frame.session;\n    session.addEventListener('selectstart', this[$selectStartHandler]);\n    session.addEventListener('selectend', this[$selectEndHandler]);\n    session.requestHitTestSourceForTransientInput({\n      profile: 'generic-touchscreen'\n    }).then(hitTestSource => {\n      this[$transientHitTestSource] = hitTestSource;\n    });\n  }\n\n  [$getHitPoint](hitResult) {\n    const pose = hitResult.getPose(this[$refSpace]);\n\n    if (pose == null) {\n      return null;\n    }\n\n    const hitMatrix = matrix4.fromArray(pose.transform.matrix); // Check that the y-coordinate of the normal is large enough that the normal\n    // is pointing up.\n\n    return hitMatrix.elements[5] > 0.75 ? hitPosition.setFromMatrixPosition(hitMatrix) : null;\n  }\n  /**\n   * This sets the initial model placement based on the input hit point. The\n   * bottom of the model will be placed on the floor (the shadow will rest on\n   * the input's y-coordinate). The XZ placement is found by first putting the\n   * scene's target at the hit point, drawing a ray from the camera to the\n   * target, and finding the XZ-intersection of this ray with the model's\n   * bounding box. The scene is then translated on the XZ plane to position this\n   * intersection point at the input hit point. If the ray does not intersect,\n   * the target is left at the hit point.\n   *\n   * This ensures the model is placed according to the chosen target, is not\n   * reoriented, and does not intersect the camera even when the model\n   * is large (unless the target is chosen outside of the model's bounding box).\n   */\n\n\n  placeModel(hit) {\n    const scene = this[$presentedScene];\n    const model = scene.model;\n    const _model$boundingBox = model.boundingBox,\n          min = _model$boundingBox.min,\n          max = _model$boundingBox.max;\n    this[$placementBox].show = true;\n    const goal = this[$goalPosition];\n    goal.copy(hit);\n    const floor = hit.y;\n    const origin = this.camera.position.clone();\n    const direction = hit.clone().sub(origin).normalize(); // Pull camera back enough to be outside of large models.\n\n    origin.sub(direction.multiplyScalar(model.idealCameraDistance));\n    const ray = new Ray(origin, direction.normalize());\n    const modelToWorld = this[$initialModelToWorld];\n    const modelPosition = new Vector3().setFromMatrixPosition(modelToWorld).add(hit);\n    modelToWorld.setPosition(modelPosition);\n    const world2Model = new Matrix4().getInverse(modelToWorld);\n    ray.applyMatrix4(world2Model); // Make the box tall so that we don't intersect the top face.\n\n    max.y += 10;\n    ray.intersectBox(model.boundingBox, modelPosition);\n    max.y -= 10;\n\n    if (modelPosition != null) {\n      modelPosition.applyMatrix4(modelToWorld);\n      goal.add(hit).sub(modelPosition);\n    } // Move the scene's target to the model's floor height.\n\n\n    const target = scene.getTarget();\n    scene.setTarget(target.x, min.y, target.z); // Ignore the y-coordinate and set on the floor instead.\n\n    goal.y = floor;\n    this.dispatchEvent({\n      type: 'modelmove'\n    });\n  }\n\n  [$onSelectStart](event) {\n    const hitSource = this[$transientHitTestSource];\n\n    if (hitSource == null) {\n      return;\n    }\n\n    const fingers = this[$frame].getHitTestResultsForTransientInput(hitSource);\n    const scene = this[$presentedScene];\n    const box = this[$placementBox];\n\n    if (fingers.length === 1) {\n      this[$inputSource] = event.inputSource;\n      const axes = event.inputSource.gamepad.axes;\n      const hitPosition = box.getHit(this[$presentedScene], axes[0], axes[1]);\n      box.show = true;\n\n      if (hitPosition != null) {\n        this[$isTranslating] = true;\n        this[$lastDragPosition].copy(hitPosition);\n      } else {\n        this[$isRotating] = true;\n        this[$lastScalar] = axes[0];\n      }\n    } else if (fingers.length === 2 && scene.canScale) {\n      box.show = true;\n      this[$isScaling] = true;\n      this[$lastScalar] = this[$fingerSeparation](fingers) / scene.scale.x;\n    }\n  }\n\n  [$onSelectEnd](_event) {\n    this[$isTranslating] = false;\n    this[$isRotating] = false;\n    this[$isScaling] = false;\n    this[$inputSource] = null;\n    this[$goalPosition].y += this[$placementBox].offsetHeight * this[$presentedScene].scale.x;\n    this[$placementBox].show = false;\n  }\n\n  [$fingerSeparation](fingers) {\n    const fingerOne = fingers[0].inputSource.gamepad.axes;\n    const fingerTwo = fingers[1].inputSource.gamepad.axes;\n    const deltaX = fingerTwo[0] - fingerOne[0];\n    const deltaY = fingerTwo[1] - fingerOne[1];\n    return Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n  }\n\n  [$processInput](frame) {\n    const hitSource = this[$transientHitTestSource];\n\n    if (hitSource == null) {\n      return;\n    }\n\n    if (!this[$isTranslating] && !this[$isScaling] && !this[$isRotating]) {\n      return;\n    }\n\n    const fingers = frame.getHitTestResultsForTransientInput(hitSource);\n    const scene = this[$presentedScene];\n    const scale = scene.scale.x; // Rotating, translating and scaling are mutually exclusive operations; only\n    // one can happen at a time, but we can switch during a gesture.\n\n    if (this[$isScaling]) {\n      if (fingers.length < 2) {\n        // If we lose the second finger, stop scaling (in fact, stop processing\n        // input altogether until a new gesture starts).\n        this[$isScaling] = false;\n      } else {\n        const separation = this[$fingerSeparation](fingers);\n        const scale = separation / this[$lastScalar];\n        this[$goalScale] = scale < SCALE_SNAP_HIGH && scale > SCALE_SNAP_LOW ? 1 : scale;\n      }\n\n      return;\n    } else if (fingers.length === 2 && scene.canScale) {\n      // If we were rotating or translating and we get a second finger, switch\n      // to scaling instead.\n      this[$isTranslating] = false;\n      this[$isRotating] = false;\n      this[$isScaling] = true;\n      this[$lastScalar] = this[$fingerSeparation](fingers) / scale;\n      return;\n    }\n\n    if (this[$isRotating]) {\n      const thisDragX = this[$inputSource].gamepad.axes[0];\n      this[$goalYaw] += (thisDragX - this[$lastScalar]) * ROTATION_RATE;\n      this[$lastScalar] = thisDragX;\n    } else if (this[$isTranslating]) {\n      fingers.forEach(finger => {\n        if (finger.inputSource !== this[$inputSource] || finger.results.length < 1) {\n          return;\n        }\n\n        const hit = this[$getHitPoint](finger.results[0]);\n\n        if (hit == null) {\n          return;\n        }\n\n        this[$goalPosition].sub(this[$lastDragPosition]);\n        const offset = hit.y - this[$lastDragPosition].y; // When a lower floor is found, keep the model at the same height, but\n        // drop the placement box to the floor. The model falls on select end.\n\n        if (offset < 0) {\n          this[$placementBox].offsetHeight = offset / scale;\n          this[$presentedScene].model.setShadowScaleAndOffset(scale, offset); // Interpolate hit ray up to drag plane\n\n          const cameraPosition = vector3.copy(this.camera.position);\n          const alpha = -offset / (cameraPosition.y - hit.y);\n          cameraPosition.multiplyScalar(alpha);\n          hit.multiplyScalar(1 - alpha).add(cameraPosition);\n        }\n\n        this[$goalPosition].add(hit);\n        this[$lastDragPosition].copy(hit);\n      });\n    }\n  }\n\n  [$moveScene](delta) {\n    const scene = this[$presentedScene];\n    const model = scene.model,\n          position = scene.position,\n          yaw = scene.yaw;\n    const radius = model.idealCameraDistance;\n    const goal = this[$goalPosition];\n    const oldScale = scene.scale.x;\n    const box = this[$placementBox];\n\n    if (this[$initialHitSource] == null && (!goal.equals(position) || this[$goalScale] !== oldScale)) {\n      let x = position.x,\n          y = position.y,\n          z = position.z;\n      delta *= this[$damperRate];\n      x = this[$xDamper].update(x, goal.x, delta, radius);\n      y = this[$yDamper].update(y, goal.y, delta, radius);\n      z = this[$zDamper].update(z, goal.z, delta, radius);\n      position.set(x, y, z);\n      const newScale = this[$scaleDamper].update(oldScale, this[$goalScale], delta, 1);\n      scene.scale.set(newScale, newScale, newScale);\n\n      if (!this[$isTranslating]) {\n        const offset = goal.y - y;\n\n        if (this[$placementComplete]) {\n          box.offsetHeight = offset / newScale;\n          model.setShadowScaleAndOffset(newScale, offset);\n        } else if (offset === 0) {\n          this[$placementComplete] = true;\n          box.show = false;\n          scene.setShadowIntensity(AR_SHADOW_INTENSITY);\n          this[$damperRate] = 1;\n        }\n      }\n    }\n\n    box.updateOpacity(delta);\n    scene.updateTarget(delta); // This updates the model's position, which the shadow is based on.\n\n    scene.updateMatrixWorld(true); // yaw must be updated last, since this also updates the shadow position.\n\n    scene.yaw = this[$yawDamper].update(yaw, this[$goalYaw], delta, Math.PI);\n  }\n\n  [$tick]() {\n    this[$rafId] = this[$currentSession].requestAnimationFrame((time, frame) => this[$onWebXRFrame](time, frame));\n  }\n\n  [$onWebXRFrame](time, frame) {\n    this[$frame] = frame;\n    const pose = frame.getViewerPose(this[$refSpace]); // TODO: Notify external observers of tick\n\n    this[$tick]();\n    const scene = this[$presentedScene];\n\n    if (pose == null || scene == null) {\n      return;\n    }\n\n    this[$updateCamera](pose.views[0]);\n    this[$placeInitially](frame);\n    this[$processInput](frame);\n    const delta = time - this[$lastTick];\n    this[$moveScene](delta);\n    this.renderer.preRender(scene, time, delta);\n    this[$lastTick] = time; // NOTE: Clearing depth caused issues on Samsung devices\n    // @see https://github.com/googlecodelabs/ar-with-webxr/issues/8\n    // this.threeRenderer.clearDepth();\n\n    this.threeRenderer.render(scene, this.camera);\n  }\n\n}","map":{"version":3,"sources":["../../src/three-components/ARRenderer.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {EventDispatcher, Matrix4, PerspectiveCamera, Ray, Vector3, WebGLRenderer} from 'three';\n\nimport {$needsRender, $onResize} from '../model-viewer-base.js';\nimport {assertIsArCandidate} from '../utilities.js';\n\nimport {Damper} from './Damper.js';\nimport {ModelScene} from './ModelScene.js';\nimport {PlacementBox} from './PlacementBox.js';\nimport {Renderer} from './Renderer.js';\nimport {assertContext} from './WebGLUtils.js';\n\n// AR shadow is not user-configurable. This is to pave the way for AR lighting\n// estimation, which will be used once available in WebXR.\nconst AR_SHADOW_INTENSITY = 0.3;\nconst ROTATION_RATE = 1.5;\n// Angle down (towards bottom of screen) from camera center ray to use for hit\n// testing against the floor. This makes placement faster and more intuitive\n// assuming the phone is in portrait mode. This seems to be a reasonable\n// assumption for the start of the session and UI will lack landscape mode to\n// encourage upright use.\nconst HIT_ANGLE_DEG = 20;\n// Slow down the dampers for initial placement.\nconst INTRO_DAMPER_RATE = 0.4;\nconst SCALE_SNAP_HIGH = 1.2;\nconst SCALE_SNAP_LOW = 1 / SCALE_SNAP_HIGH;\n\nconst $presentedScene = Symbol('presentedScene');\nconst $placementBox = Symbol('placementBox');\nconst $lastTick = Symbol('lastTick');\nconst $turntableRotation = Symbol('turntableRotation');\nconst $oldShadowIntensity = Symbol('oldShadowIntensity');\nconst $oldBackground = Symbol('oldBackground');\nconst $rafId = Symbol('rafId');\nexport const $currentSession = Symbol('currentSession');\nconst $tick = Symbol('tick');\nconst $refSpace = Symbol('refSpace');\nconst $viewerRefSpace = Symbol('viewerRefSpace');\nconst $frame = Symbol('frame');\nconst $initialized = Symbol('initialized');\nconst $initialModelToWorld = Symbol('initialModelToWorld');\nconst $placementComplete = Symbol('placementComplete');\nconst $initialHitSource = Symbol('hitTestSource');\nconst $transientHitTestSource = Symbol('transiertHitTestSource');\nconst $inputSource = Symbol('inputSource');\nconst $isTranslating = Symbol('isTranslating');\nconst $isRotating = Symbol('isRotating');\nconst $isScaling = Symbol('isScaling');\nconst $lastDragPosition = Symbol('lastDragPosition');\nconst $lastScalar = Symbol('lastScalar');\nconst $goalPosition = Symbol('goalPosition');\nconst $goalYaw = Symbol('goalYaw');\nconst $goalScale = Symbol('goalScale');\nconst $xDamper = Symbol('xDamper');\nconst $yDamper = Symbol('yDamper');\nconst $zDamper = Symbol('zDamper');\nconst $yawDamper = Symbol('yawDamper');\nconst $scaleDamper = Symbol('scaleDamper');\nconst $damperRate = Symbol('damperRate');\nconst $resolveCleanup = Symbol('resolveCleanup');\n\nexport const $onWebXRFrame = Symbol('onWebXRFrame');\nconst $postSessionCleanup = Symbol('postSessionCleanup');\nconst $updateCamera = Symbol('updateCamera');\nconst $placeInitially = Symbol('placeInitially');\nconst $getHitPoint = Symbol('getHitPoint');\nconst $selectStartHandler = Symbol('selectStartHandler');\nconst $onSelectStart = Symbol('onSelectStart');\nconst $selectEndHandler = Symbol('selectHandler');\nconst $onSelectEnd = Symbol('onSelect');\nconst $fingerSeparation = Symbol('fingerSeparation');\nconst $processInput = Symbol('processInput');\nconst $moveScene = Symbol('moveScene');\n\nconst vector3 = new Vector3();\nconst matrix4 = new Matrix4();\nconst hitPosition = new Vector3();\n\nexport class ARRenderer extends EventDispatcher {\n  public threeRenderer: WebGLRenderer;\n\n  public camera: PerspectiveCamera = new PerspectiveCamera();\n\n  private[$placementBox]: PlacementBox|null = null;\n  private[$lastTick]: number|null = null;\n  private[$turntableRotation]: number|null = null;\n  private[$oldShadowIntensity]: number|null = null;\n  private[$oldBackground]: any = null;\n  private[$rafId]: number|null = null;\n  protected[$currentSession]: XRSession|null = null;\n  private[$refSpace]: XRReferenceSpace|null = null;\n  private[$viewerRefSpace]: XRReferenceSpace|null = null;\n  private[$frame]: XRFrame|null = null;\n  private[$initialHitSource]: XRHitTestSource|null = null;\n  private[$transientHitTestSource]: XRTransientInputHitTestSource|null = null;\n  private[$inputSource]: XRInputSource|null = null;\n  private[$presentedScene]: ModelScene|null = null;\n  private[$resolveCleanup]: ((...args: any[]) => void)|null = null;\n\n  private[$initialized] = false;\n  private[$initialModelToWorld] = new Matrix4();\n  private[$placementComplete] = false;\n  private[$isTranslating] = false;\n  private[$isRotating] = false;\n  private[$isScaling] = false;\n  private[$lastDragPosition] = new Vector3();\n  private[$lastScalar] = 0;\n  private[$goalPosition] = new Vector3();\n  private[$goalYaw] = 0;\n  private[$goalScale] = 1;\n  private[$xDamper] = new Damper();\n  private[$yDamper] = new Damper();\n  private[$zDamper] = new Damper();\n  private[$yawDamper] = new Damper();\n  private[$scaleDamper] = new Damper();\n  private[$damperRate] = 1;\n\n  private[$selectStartHandler] = (event: Event) =>\n      this[$onSelectStart](event as XRInputSourceEvent);\n  private[$selectEndHandler] = (event: Event) =>\n      this[$onSelectEnd](event as XRInputSourceEvent);\n\n  constructor(private renderer: Renderer) {\n    super();\n    this.threeRenderer = renderer.threeRenderer;\n    // Turn this off, as the matrix is set directly from webXR rather than using\n    // postion, rotation, scale.\n    this.camera.matrixAutoUpdate = false;\n  }\n\n  async resolveARSession(scene: ModelScene): Promise<XRSession> {\n    assertIsArCandidate();\n\n    const session: XRSession =\n        await navigator.xr!.requestSession!('immersive-ar', {\n          requiredFeatures: ['hit-test'],\n          optionalFeatures: ['dom-overlay'],\n          domOverlay: {\n            root: document.querySelector('model-viewer')!.shadowRoot!\n                      .querySelector('div.annotation-container')\n          }\n        });\n\n    const gl = assertContext(this.renderer.context3D);\n    // `makeXRCompatible` replaced `setCompatibleXRDevice` in Chrome M73 @TODO\n    // #293, handle WebXR API changes. WARNING: this can cause a GL context\n    // loss according to the spec, though current implementations don't do so.\n    await gl.makeXRCompatible();\n\n    session.updateRenderState(\n        {baseLayer: new XRWebGLLayer(session, gl, {alpha: true})});\n\n    // The render state update takes effect on the next animation frame. Wait\n    // for it so that we get a framebuffer.\n    let waitForAnimationFrame = new Promise((resolve, _reject) => {\n      session.requestAnimationFrame(() => resolve());\n    });\n    await waitForAnimationFrame;\n\n    // Redirect rendering to the WebXR offscreen framebuffer.\n    // TODO: this method should be added to three.js's exported interface.\n    (this.threeRenderer as any)\n        .setFramebuffer(session.renderState.baseLayer!.framebuffer);\n    (scene.element)[$onResize](window.screen);\n\n    return session;\n  }\n\n  /**\n   * The currently presented scene, if any\n   */\n  get presentedScene() {\n    return this[$presentedScene];\n  }\n\n  /**\n   * Resolves to true if the renderer has detected all the necessary qualities\n   * to support presentation in AR.\n   */\n  async supportsPresentation() {\n    try {\n      assertIsArCandidate();\n      return await navigator.xr!.isSessionSupported('immersive-ar');\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * Present a scene in AR\n   */\n  async present(scene: ModelScene): Promise<void> {\n    if (this.isPresenting) {\n      console.warn('Cannot present while a model is already presenting');\n    }\n\n    const currentSession = await this.resolveARSession(scene);\n    currentSession.addEventListener('end', () => {\n      this[$postSessionCleanup]();\n    }, {once: true});\n\n    this[$refSpace] = await currentSession.requestReferenceSpace('local');\n    this[$viewerRefSpace] =\n        await currentSession.requestReferenceSpace('viewer');\n\n    const placementBox = new PlacementBox(scene.model);\n    this[$placementComplete] = false;\n\n    scene.setCamera(this.camera);\n    this[$initialized] = false;\n    this[$damperRate] = INTRO_DAMPER_RATE;\n\n    this[$turntableRotation] = scene.yaw;\n    scene.yaw = 0;\n    this[$goalYaw] = 0;\n    this[$goalScale] = 1;\n\n    this[$oldBackground] = scene.background;\n    scene.background = null;\n\n    this[$oldShadowIntensity] = scene.shadowIntensity;\n    scene.setShadowIntensity(0);\n\n    const radians = HIT_ANGLE_DEG * Math.PI / 180;\n    const ray = new XRRay(\n        new DOMPoint(0, 0, 0),\n        new DOMPoint(0, -Math.sin(radians), -Math.cos(radians)));\n    currentSession\n        .requestHitTestSource({space: this[$viewerRefSpace]!, offsetRay: ray})\n        .then(hitTestSource => {\n          this[$initialHitSource] = hitTestSource;\n        });\n\n    this[$currentSession] = currentSession;\n    this[$presentedScene] = scene;\n    this[$placementBox] = placementBox;\n    this[$lastTick] = performance.now();\n\n    // Start the event loop.\n    this[$tick]();\n  }\n\n  /**\n   * If currently presenting a scene in AR, stops presentation and exits AR.\n   */\n  async stopPresenting() {\n    if (!this.isPresenting) {\n      return;\n    }\n\n    const cleanupPromise = new Promise((resolve) => {\n      this[$resolveCleanup] = resolve;\n    });\n\n    try {\n      const session = this[$currentSession]!;\n      session.removeEventListener('selectstart', this[$selectStartHandler]);\n      session.removeEventListener('selectend', this[$selectEndHandler]);\n\n      this[$currentSession] = null;\n      session.cancelAnimationFrame(this[$rafId]!);\n\n      await session.end();\n      await cleanupPromise;\n    } catch (error) {\n      console.warn('Error while trying to end AR session');\n      console.warn(error);\n\n      this[$postSessionCleanup]();\n    }\n  }\n\n  [$postSessionCleanup]() {\n    // The offscreen WebXR framebuffer is now invalid, switch\n    // back to the default framebuffer for canvas output.\n    // TODO: this method should be added to three.js's exported interface.\n    (this.threeRenderer as any).setFramebuffer(null);\n\n    const scene = this[$presentedScene];\n    if (scene != null) {\n      const {model, element} = scene;\n      scene.setCamera(scene.camera);\n      model.remove(this[$placementBox]!);\n\n      scene.position.set(0, 0, 0);\n      scene.scale.set(1, 1, 1);\n      model.setShadowScaleAndOffset(1, 0);\n      scene.yaw = this[$turntableRotation]!;\n      scene.setShadowIntensity(this[$oldShadowIntensity]!);\n      scene.background = this[$oldBackground];\n      model.orientHotspots(0);\n      element.requestUpdate('cameraTarget');\n      element[$needsRender]();\n\n      this.renderer.expandTo(scene.width, scene.height);\n    }\n\n    if (this[$placementBox] != null) {\n      this[$placementBox]!.dispose();\n      this[$placementBox] = null;\n    }\n\n    this[$refSpace] = null;\n    this[$presentedScene] = null;\n\n    if (this[$resolveCleanup] != null) {\n      this[$resolveCleanup]!();\n    }\n  }\n\n  /**\n   * True if a scene is currently in the process of being presented in AR\n   */\n  get isPresenting(): boolean {\n    return this[$presentedScene] != null;\n  }\n\n  [$updateCamera](view: XRView) {\n    const {camera} = this;\n    const {matrix: cameraMatrix} = camera;\n\n    cameraMatrix.fromArray(view.transform.matrix);\n    camera.updateMatrixWorld(true);\n    // position is not updated when matrix is updated.\n    camera.position.setFromMatrixPosition(cameraMatrix);\n\n    if (this[$initialHitSource] != null) {\n      // Target locked to screen center\n      const {position, model} = this[$presentedScene]!;\n      const radius = model.idealCameraDistance;\n      camera.getWorldDirection(position);\n      position.multiplyScalar(radius);\n      position.add(camera.position);\n    }\n\n    if (!this[$initialized]) {\n      camera.projectionMatrix.fromArray(view.projectionMatrix);\n      // Have to set the inverse manually when setting matrix directly. This is\n      // needed for raycasting.\n      camera.projectionMatrixInverse.getInverse(camera.projectionMatrix);\n      // Orient model toward camera on first frame.\n      const {x, z} = camera.position;\n      const scene = this[$presentedScene]!;\n      scene.pointTowards(x, z);\n      scene.model.updateMatrixWorld(true);\n      this[$goalYaw] = scene.yaw;\n      this[$initialModelToWorld].copy(scene.model.matrixWorld);\n      this[$initialized] = true;\n    }\n\n    this[$presentedScene]!.model.orientHotspots(\n        Math.atan2(cameraMatrix.elements[1], cameraMatrix.elements[5]));\n  }\n\n  [$placeInitially](frame: XRFrame) {\n    const hitSource = this[$initialHitSource];\n    if (hitSource == null) {\n      return;\n    }\n\n    const hitTestResults = frame.getHitTestResults(hitSource);\n    if (hitTestResults.length == 0) {\n      return;\n    }\n\n    const hit = hitTestResults[0];\n    const hitMatrix = this[$getHitPoint](hit);\n    if (hitMatrix == null) {\n      return;\n    }\n\n    this.placeModel(hitMatrix);\n\n    hitSource.cancel();\n    this[$initialHitSource] = null;\n\n    const {session} = frame;\n    session.addEventListener('selectstart', this[$selectStartHandler]);\n    session.addEventListener('selectend', this[$selectEndHandler]);\n    session\n        .requestHitTestSourceForTransientInput({profile: 'generic-touchscreen'})\n        .then(hitTestSource => {\n          this[$transientHitTestSource] = hitTestSource;\n        });\n  }\n\n  [$getHitPoint](hitResult: XRHitTestResult): Vector3|null {\n    const pose = hitResult.getPose(this[$refSpace]!);\n    if (pose == null) {\n      return null;\n    }\n\n    const hitMatrix = matrix4.fromArray(pose.transform.matrix);\n    // Check that the y-coordinate of the normal is large enough that the normal\n    // is pointing up.\n    return hitMatrix.elements[5] > 0.75 ?\n        hitPosition.setFromMatrixPosition(hitMatrix) :\n        null;\n  }\n\n  /**\n   * This sets the initial model placement based on the input hit point. The\n   * bottom of the model will be placed on the floor (the shadow will rest on\n   * the input's y-coordinate). The XZ placement is found by first putting the\n   * scene's target at the hit point, drawing a ray from the camera to the\n   * target, and finding the XZ-intersection of this ray with the model's\n   * bounding box. The scene is then translated on the XZ plane to position this\n   * intersection point at the input hit point. If the ray does not intersect,\n   * the target is left at the hit point.\n   *\n   * This ensures the model is placed according to the chosen target, is not\n   * reoriented, and does not intersect the camera even when the model\n   * is large (unless the target is chosen outside of the model's bounding box).\n   */\n  placeModel(hit: Vector3) {\n    const scene = this[$presentedScene]!;\n    const {model} = scene;\n    const {min, max} = model.boundingBox;\n\n    this[$placementBox]!.show = true;\n\n    const goal = this[$goalPosition];\n    goal.copy(hit);\n    const floor = hit.y;\n\n    const origin = this.camera.position.clone();\n    const direction = hit.clone().sub(origin).normalize();\n    // Pull camera back enough to be outside of large models.\n    origin.sub(direction.multiplyScalar(model.idealCameraDistance));\n    const ray = new Ray(origin, direction.normalize());\n\n    const modelToWorld = this[$initialModelToWorld];\n    const modelPosition =\n        new Vector3().setFromMatrixPosition(modelToWorld).add(hit);\n    modelToWorld.setPosition(modelPosition);\n    const world2Model = new Matrix4().getInverse(modelToWorld);\n    ray.applyMatrix4(world2Model);\n\n    // Make the box tall so that we don't intersect the top face.\n    max.y += 10;\n    ray.intersectBox(model.boundingBox, modelPosition);\n    max.y -= 10;\n\n    if (modelPosition != null) {\n      modelPosition.applyMatrix4(modelToWorld);\n      goal.add(hit).sub(modelPosition);\n    }\n\n    // Move the scene's target to the model's floor height.\n    const target = scene.getTarget();\n    scene.setTarget(target.x, min.y, target.z);\n    // Ignore the y-coordinate and set on the floor instead.\n    goal.y = floor;\n\n    this.dispatchEvent({type: 'modelmove'});\n  }\n\n  [$onSelectStart](event: XRInputSourceEvent) {\n    const hitSource = this[$transientHitTestSource];\n    if (hitSource == null) {\n      return;\n    }\n    const fingers = this[$frame]!.getHitTestResultsForTransientInput(hitSource);\n    const scene = this[$presentedScene]!;\n    const box = this[$placementBox]!;\n\n    if (fingers.length === 1) {\n      this[$inputSource] = event.inputSource;\n      const {axes} = event.inputSource.gamepad;\n\n      const hitPosition = box.getHit(this[$presentedScene]!, axes[0], axes[1]);\n      box.show = true;\n\n      if (hitPosition != null) {\n        this[$isTranslating] = true;\n        this[$lastDragPosition].copy(hitPosition);\n      } else {\n        this[$isRotating] = true;\n        this[$lastScalar] = axes[0];\n      }\n    } else if (fingers.length === 2 && scene.canScale) {\n      box.show = true;\n      this[$isScaling] = true;\n      this[$lastScalar] = this[$fingerSeparation](fingers) / scene.scale.x;\n    }\n  }\n\n  [$onSelectEnd](_event: XRInputSourceEvent) {\n    this[$isTranslating] = false;\n    this[$isRotating] = false;\n    this[$isScaling] = false;\n    this[$inputSource] = null;\n    this[$goalPosition].y +=\n        this[$placementBox]!.offsetHeight * this[$presentedScene]!.scale.x;\n    this[$placementBox]!.show = false\n  }\n\n  [$fingerSeparation](fingers: XRTransientInputHitTestResult[]): number {\n    const fingerOne = fingers[0].inputSource.gamepad.axes;\n    const fingerTwo = fingers[1].inputSource.gamepad.axes;\n    const deltaX = fingerTwo[0] - fingerOne[0];\n    const deltaY = fingerTwo[1] - fingerOne[1];\n    return Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n  }\n\n  [$processInput](frame: XRFrame) {\n    const hitSource = this[$transientHitTestSource];\n    if (hitSource == null) {\n      return;\n    }\n    if (!this[$isTranslating] && !this[$isScaling] && !this[$isRotating]) {\n      return;\n    }\n    const fingers = frame.getHitTestResultsForTransientInput(hitSource);\n    const scene = this[$presentedScene]!;\n    const scale = scene.scale.x;\n\n    // Rotating, translating and scaling are mutually exclusive operations; only\n    // one can happen at a time, but we can switch during a gesture.\n    if (this[$isScaling]) {\n      if (fingers.length < 2) {\n        // If we lose the second finger, stop scaling (in fact, stop processing\n        // input altogether until a new gesture starts).\n        this[$isScaling] = false;\n      } else {\n        const separation = this[$fingerSeparation](fingers);\n        const scale = separation / this[$lastScalar];\n        this[$goalScale] =\n            (scale < SCALE_SNAP_HIGH && scale > SCALE_SNAP_LOW) ? 1 : scale;\n      }\n      return;\n    } else if (fingers.length === 2 && scene.canScale) {\n      // If we were rotating or translating and we get a second finger, switch\n      // to scaling instead.\n      this[$isTranslating] = false;\n      this[$isRotating] = false;\n      this[$isScaling] = true;\n      this[$lastScalar] = this[$fingerSeparation](fingers) / scale;\n      return;\n    }\n\n    if (this[$isRotating]) {\n      const thisDragX = this[$inputSource]!.gamepad.axes[0];\n      this[$goalYaw] += (thisDragX - this[$lastScalar]) * ROTATION_RATE;\n      this[$lastScalar] = thisDragX;\n    } else if (this[$isTranslating]) {\n      fingers.forEach(finger => {\n        if (finger.inputSource !== this[$inputSource] ||\n            finger.results.length < 1) {\n          return;\n        }\n\n        const hit = this[$getHitPoint](finger.results[0]);\n        if (hit == null) {\n          return;\n        }\n\n        this[$goalPosition].sub(this[$lastDragPosition]);\n\n        const offset = hit.y - this[$lastDragPosition].y;\n        // When a lower floor is found, keep the model at the same height, but\n        // drop the placement box to the floor. The model falls on select end.\n        if (offset < 0) {\n          this[$placementBox]!.offsetHeight = offset / scale;\n          this[$presentedScene]!.model.setShadowScaleAndOffset(scale, offset);\n          // Interpolate hit ray up to drag plane\n          const cameraPosition = vector3.copy(this.camera.position);\n          const alpha = -offset / (cameraPosition.y - hit.y);\n          cameraPosition.multiplyScalar(alpha);\n          hit.multiplyScalar(1 - alpha).add(cameraPosition);\n        }\n\n        this[$goalPosition].add(hit);\n        this[$lastDragPosition].copy(hit);\n      });\n    }\n  }\n\n  [$moveScene](delta: number) {\n    const scene = this[$presentedScene]!;\n    const {model, position, yaw} = scene;\n    const radius = model.idealCameraDistance;\n    const goal = this[$goalPosition];\n    const oldScale = scene.scale.x;\n    const box = this[$placementBox]!;\n\n    if (this[$initialHitSource] == null &&\n        (!goal.equals(position) || this[$goalScale] !== oldScale)) {\n      let {x, y, z} = position;\n      delta *= this[$damperRate];\n      x = this[$xDamper].update(x, goal.x, delta, radius);\n      y = this[$yDamper].update(y, goal.y, delta, radius);\n      z = this[$zDamper].update(z, goal.z, delta, radius);\n      position.set(x, y, z);\n\n      const newScale =\n          this[$scaleDamper].update(oldScale, this[$goalScale], delta, 1);\n      scene.scale.set(newScale, newScale, newScale);\n\n      if (!this[$isTranslating]) {\n        const offset = goal.y - y;\n        if (this[$placementComplete]) {\n          box.offsetHeight = offset / newScale;\n          model.setShadowScaleAndOffset(newScale, offset);\n        } else if (offset === 0) {\n          this[$placementComplete] = true;\n          box.show = false;\n          scene.setShadowIntensity(AR_SHADOW_INTENSITY);\n          this[$damperRate] = 1;\n        }\n      }\n    }\n    box.updateOpacity(delta);\n    scene.updateTarget(delta);\n    // This updates the model's position, which the shadow is based on.\n    scene.updateMatrixWorld(true);\n    // yaw must be updated last, since this also updates the shadow position.\n    scene.yaw = this[$yawDamper].update(yaw, this[$goalYaw], delta, Math.PI);\n  }\n\n  [$tick]() {\n    this[$rafId] = this[$currentSession]!.requestAnimationFrame(\n        (time, frame) => this[$onWebXRFrame](time, frame));\n  }\n\n  [$onWebXRFrame](time: number, frame: XRFrame) {\n    this[$frame] = frame;\n    const pose = frame.getViewerPose(this[$refSpace]!);\n\n    // TODO: Notify external observers of tick\n    this[$tick]();\n\n    const scene = this[$presentedScene];\n    if (pose == null || scene == null) {\n      return;\n    }\n\n    this[$updateCamera](pose.views[0]);\n\n    this[$placeInitially](frame);\n\n    this[$processInput](frame);\n\n    const delta = time - this[$lastTick]!;\n    this[$moveScene](delta);\n    this.renderer.preRender(scene, time, delta);\n    this[$lastTick] = time;\n\n    // NOTE: Clearing depth caused issues on Samsung devices\n    // @see https://github.com/googlecodelabs/ar-with-webxr/issues/8\n    // this.threeRenderer.clearDepth();\n    this.threeRenderer.render(scene, this.camera);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}