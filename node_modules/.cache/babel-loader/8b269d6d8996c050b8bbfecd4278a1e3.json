{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b;\n\nimport { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport { CacheEvictionPolicy } from '../utilities/cache-eviction-policy.js';\n/**\n * A helper to Promise-ify a Three.js GLTFLoader\n */\n\nexport const loadWithLoader = (url, loader, progressCallback = () => {}) => {\n  const onProgress = event => {\n    progressCallback(event.loaded / event.total);\n  };\n\n  return new Promise((resolve, reject) => {\n    loader.load(url, resolve, onProgress, reject);\n  });\n};\nconst cache = new Map();\nconst preloaded = new Map();\nlet dracoDecoderLocation;\nconst dracoLoader = new DRACOLoader();\nexport const $loader = Symbol('loader');\nexport const $evictionPolicy = Symbol('evictionPolicy');\nconst $GLTFInstance = Symbol('GLTFInstance');\nexport class CachingGLTFLoader {\n  constructor(GLTFInstance) {\n    this[_b] = new GLTFLoader();\n    this[$GLTFInstance] = GLTFInstance;\n    this[$loader].setDRACOLoader(dracoLoader);\n  }\n\n  static setDRACODecoderLocation(url) {\n    dracoDecoderLocation = url;\n    dracoLoader.setDecoderPath(url);\n  }\n\n  static getDRACODecoderLocation() {\n    return dracoDecoderLocation;\n  }\n\n  static get cache() {\n    return cache;\n  }\n  /** @nocollapse */\n\n\n  static clearCache() {\n    cache.forEach((_value, url) => {\n      this.delete(url);\n    });\n    this[$evictionPolicy].reset();\n  }\n\n  static has(url) {\n    return cache.has(url);\n  }\n  /** @nocollapse */\n\n\n  static async delete(url) {\n    if (!this.has(url)) {\n      return;\n    }\n\n    const gltfLoads = cache.get(url);\n    preloaded.delete(url);\n    cache.delete(url);\n    const gltf = await gltfLoads; // Dispose of the cached glTF's materials and geometries:\n\n    gltf.dispose();\n  }\n  /**\n   * Returns true if the model that corresponds to the specified url is\n   * available in our local cache.\n   */\n\n\n  static hasFinishedLoading(url) {\n    return !!preloaded.get(url);\n  }\n\n  get [(_a = $evictionPolicy, _b = $loader, $evictionPolicy)]() {\n    return this.constructor[$evictionPolicy];\n  }\n  /**\n   * Preloads a glTF, populating the cache. Returns a promise that resolves\n   * when the cache is populated.\n   */\n\n\n  async preload(url, progressCallback = () => {}) {\n    if (!cache.has(url)) {\n      const rawGLTFLoads = loadWithLoader(url, this[$loader], progress => {\n        progressCallback(progress * 0.8);\n      });\n      const gltfInstanceLoads = rawGLTFLoads.then(rawGLTF => {\n        const GLTFInstance = this[$GLTFInstance];\n        const preparedGLTF = GLTFInstance.prepare(rawGLTF);\n        progressCallback(0.9);\n        return new GLTFInstance(preparedGLTF);\n      });\n      cache.set(url, gltfInstanceLoads);\n    }\n\n    await cache.get(url);\n\n    if (progressCallback) {\n      progressCallback(1.0);\n    }\n\n    preloaded.set(url, true);\n  }\n  /**\n   * Loads a glTF from the specified url and resolves a unique clone of the\n   * glTF. If the glTF has already been loaded, makes a clone of the cached\n   * copy.\n   */\n\n\n  async load(url, progressCallback = () => {}) {\n    await this.preload(url, progressCallback);\n    const gltf = await cache.get(url);\n    const clone = gltf.clone();\n    this[$evictionPolicy].retain(url); // Patch dispose so that we can properly account for instance use\n    // in the caching layer:\n\n    clone.dispose = (() => {\n      const originalDispose = clone.dispose;\n      let disposed = false;\n      return () => {\n        if (disposed) {\n          return;\n        }\n\n        disposed = true;\n        originalDispose.apply(clone);\n        this[$evictionPolicy].release(url);\n      };\n    })();\n\n    return clone;\n  }\n\n}\nCachingGLTFLoader[_a] = new CacheEvictionPolicy(CachingGLTFLoader);","map":{"version":3,"sources":["../../src/three-components/CachingGLTFLoader.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {DRACOLoader} from 'three/examples/jsm/loaders/DRACOLoader.js';\nimport {GLTF, GLTFLoader} from 'three/examples/jsm/loaders/GLTFLoader.js';\n\nimport {CacheEvictionPolicy} from '../utilities/cache-eviction-policy.js';\n\nimport {GLTFInstance, GLTFInstanceConstructor} from './GLTFInstance.js';\n\nexport type ProgressCallback = (progress: number) => void;\n\n/**\n * A helper to Promise-ify a Three.js GLTFLoader\n */\nexport const loadWithLoader =\n    (url: string,\n     loader: GLTFLoader,\n     progressCallback: ProgressCallback = () => {}) => {\n      const onProgress = (event: ProgressEvent) => {\n        progressCallback!(event.loaded / event.total);\n      };\n      return new Promise<GLTF>((resolve, reject) => {\n        loader.load(url, resolve, onProgress, reject);\n      });\n    };\n\nconst cache = new Map<string, Promise<GLTFInstance>>();\nconst preloaded = new Map<string, boolean>();\n\nlet dracoDecoderLocation: string;\nconst dracoLoader = new DRACOLoader();\n\nexport const $loader = Symbol('loader');\nexport const $evictionPolicy = Symbol('evictionPolicy');\nconst $GLTFInstance = Symbol('GLTFInstance');\n\nexport class CachingGLTFLoader<T extends GLTFInstanceConstructor =\n                                             GLTFInstanceConstructor> {\n  static setDRACODecoderLocation(url: string) {\n    dracoDecoderLocation = url;\n    dracoLoader.setDecoderPath(url);\n  }\n\n  static getDRACODecoderLocation() {\n    return dracoDecoderLocation;\n  }\n\n  static[$evictionPolicy]: CacheEvictionPolicy =\n      new CacheEvictionPolicy(CachingGLTFLoader);\n\n  static get cache() {\n    return cache;\n  }\n\n  /** @nocollapse */\n  static clearCache() {\n    cache.forEach((_value, url) => {\n      this.delete(url);\n    });\n    this[$evictionPolicy].reset();\n  }\n\n  static has(url: string) {\n    return cache.has(url);\n  }\n\n  /** @nocollapse */\n  static async delete(url: string) {\n    if (!this.has(url)) {\n      return;\n    }\n\n    const gltfLoads = cache.get(url);\n    preloaded.delete(url);\n    cache.delete(url);\n\n    const gltf = await gltfLoads;\n    // Dispose of the cached glTF's materials and geometries:\n\n    gltf!.dispose();\n  }\n\n  /**\n   * Returns true if the model that corresponds to the specified url is\n   * available in our local cache.\n   */\n  static hasFinishedLoading(url: string) {\n    return !!preloaded.get(url);\n  }\n\n  constructor(GLTFInstance: T) {\n    this[$GLTFInstance] = GLTFInstance;\n    this[$loader].setDRACOLoader(dracoLoader);\n  }\n\n  protected[$loader]: GLTFLoader = new GLTFLoader();\n  protected[$GLTFInstance]: T;\n\n  protected get[$evictionPolicy](): CacheEvictionPolicy {\n    return (this.constructor as typeof CachingGLTFLoader)[$evictionPolicy];\n  }\n\n  /**\n   * Preloads a glTF, populating the cache. Returns a promise that resolves\n   * when the cache is populated.\n   */\n  async preload(url: string, progressCallback: ProgressCallback = () => {}) {\n    if (!cache.has(url)) {\n      const rawGLTFLoads =\n          loadWithLoader(url, this[$loader], (progress: number) => {\n            progressCallback(progress * 0.8);\n          });\n\n      const gltfInstanceLoads = rawGLTFLoads.then((rawGLTF: GLTF) => {\n        const GLTFInstance = this[$GLTFInstance];\n        const preparedGLTF = GLTFInstance.prepare(rawGLTF);\n\n        progressCallback(0.9);\n\n        return new GLTFInstance(preparedGLTF);\n      });\n\n      cache.set(url, gltfInstanceLoads);\n    }\n\n    await cache.get(url);\n\n    if (progressCallback) {\n      progressCallback(1.0);\n    }\n\n    preloaded.set(url, true);\n  }\n\n  /**\n   * Loads a glTF from the specified url and resolves a unique clone of the\n   * glTF. If the glTF has already been loaded, makes a clone of the cached\n   * copy.\n   */\n  async load(url: string, progressCallback: ProgressCallback = () => {}):\n      Promise<InstanceType<T>> {\n    await this.preload(url, progressCallback);\n\n    const gltf = await cache.get(url)!;\n    const clone = gltf.clone() as InstanceType<T>;\n\n    this[$evictionPolicy].retain(url);\n\n    // Patch dispose so that we can properly account for instance use\n    // in the caching layer:\n    clone.dispose = (() => {\n      const originalDispose = clone.dispose;\n      let disposed = false;\n\n      return () => {\n        if (disposed) {\n          return;\n        }\n\n        disposed = true;\n        originalDispose.apply(clone);\n        this[$evictionPolicy].release(url);\n      };\n    })();\n\n    return clone;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}