{"ast":null,"code":"/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b;\n\nimport { ALLOWLISTED_GLOBALS } from './context/allowlist.js';\nimport { generateAPI } from './context/generate-api.js';\nimport { generateCapabilityFilter } from './context/generate-capability-filter.js';\nimport { generateContextPatch } from './context/generate-context-patch.js';\nimport { generateInitializer } from './context/generate-initializer.js';\nimport { ThreeDOMMessageType } from './protocol.js';\nconst $modelGraft = Symbol('modelGraft');\nconst $port = Symbol('port');\nconst $messageEventHandler = Symbol('messageEventHandler');\nconst $onMessageEvent = Symbol('onMessageEvent');\n/**\n * A ModelGraftManipulator is an internal construct intended to consolidate\n * any mutations that operate on the backing scene graph. It can be thought\n * of as a host execution context counterpart to the ModelKernel in the scene\n * graph execution context.\n */\n\nclass ModelGraftManipulator {\n  constructor(modelGraft, port) {\n    this[_a] = event => this[$onMessageEvent](event);\n\n    this[$modelGraft] = modelGraft;\n    this[$port] = port;\n    this[$port].addEventListener('message', this[$messageEventHandler]);\n    this[$port].start();\n  }\n  /**\n   * Clean up internal state so that the ModelGraftManipulator can be properly\n   * garbage collected.\n   */\n\n\n  dispose() {\n    this[$port].removeEventListener('message', this[$messageEventHandler]);\n    this[$port].close();\n  }\n\n  [(_a = $messageEventHandler, $onMessageEvent)](event) {\n    const data = event.data;\n\n    if (data && data.type) {\n      if (data.type === ThreeDOMMessageType.MUTATE) {\n        let applied = false;\n        const mutationId = data.mutationId;\n\n        try {\n          this[$modelGraft].mutate(data.id, data.property, data.value);\n          applied = true;\n        } finally {\n          this[$port].postMessage({\n            type: ThreeDOMMessageType.MUTATION_RESULT,\n            applied,\n            mutationId\n          });\n        }\n      }\n    }\n  }\n\n}\n\nconst ALL_CAPABILITIES = Object.freeze(['messaging', 'material-properties', 'fetch']);\n/**\n * Constructs and returns a string representing a fully-formed scene graph\n * execution context script, including context patching, capabilities and\n * scene graph API constructs.\n */\n\nexport const generateContextScriptSource = (capabilities = ALL_CAPABILITIES) => {\n  return `;(function() {\nvar ThreeDOMMessageType = ${JSON.stringify(ThreeDOMMessageType)};\n\nvar preservedContext = {\n  postMessage: self.postMessage.bind(self),\n  addEventListener: self.addEventListener.bind(self),\n  importScripts: self.importScripts.bind(self)\n};\n\n${generateContextPatch(ALLOWLISTED_GLOBALS)}\n${generateAPI()}\n${generateCapabilityFilter(capabilities)}\n${generateInitializer()}\n\ninitialize.call(self, ModelKernel, preservedContext);\n\n})();`;\n};\nconst $worker = Symbol('worker');\nconst $workerInitializes = Symbol('workerInitializes');\nconst $modelGraftManipulator = Symbol('modelGraftManipulator');\n/**\n * A ThreeDOMExecutionContext is created in the host execution context that\n * wishes to invoke scripts in a specially crafted and carefully isolated\n * script context, referred to as the scene graph execution context. For\n * practical implementation purposes, the scene graph execution context is\n * a Worker whose global scope has been heavily patched before any custom\n * script is subsequently invoked in it.\n *\n * The ThreeDOMExecutionContext must be given a set of allowed capabilities\n * when it is created. The allowed capabilities cannot be changed after the\n * scene graph execution context has been established.\n */\n\nexport class ThreeDOMExecutionContext extends EventTarget {\n  constructor(capabilities) {\n    super();\n    this[_b] = null;\n    const contextScriptSource = generateContextScriptSource(capabilities);\n    const url = URL.createObjectURL(new Blob([contextScriptSource], {\n      type: 'text/javascript'\n    }));\n    this[$worker] = new Worker(url);\n    this[$workerInitializes] = new Promise(resolve => {\n      const _ref = new MessageChannel(),\n            port1 = _ref.port1,\n            port2 = _ref.port2;\n\n      const onMessageEvent = event => {\n        if (event.data && event.data.type === ThreeDOMMessageType.CONTEXT_INITIALIZED) {\n          port1.removeEventListener('message', onMessageEvent);\n          resolve(port1);\n        }\n      };\n\n      this[$worker].postMessage({\n        type: ThreeDOMMessageType.HANDSHAKE\n      }, [port2]);\n      port1.addEventListener('message', onMessageEvent);\n      port1.start();\n    });\n  }\n\n  get worker() {\n    return this[$worker];\n  }\n\n  async changeModel(modelGraft) {\n    const port = await this[$workerInitializes];\n\n    const _ref2 = new MessageChannel(),\n          port1 = _ref2.port1,\n          port2 = _ref2.port2;\n\n    port.postMessage({\n      type: ThreeDOMMessageType.MODEL_CHANGE,\n      model: modelGraft != null && modelGraft.model != null ? modelGraft.model.toJSON() : null\n    }, [port2]);\n    const modelGraftManipulator = this[$modelGraftManipulator];\n\n    if (modelGraftManipulator != null) {\n      modelGraftManipulator.dispose();\n      this[$modelGraftManipulator] = null;\n    }\n\n    if (modelGraft != null) {\n      this[$modelGraftManipulator] = new ModelGraftManipulator(modelGraft, port1);\n    }\n  }\n  /**\n   * Evaluate an arbitrary chunk of script in the scene graph execution context.\n   * The script is guaranteed to be evaluated after the scene graph execution\n   * context is fully initialized. It is not guaranteed to be evaluated before\n   * or after a Model is made available in the scene graph execution context.\n   *\n   * Note that web browsers do not universally support module scripts (\"ESM\") in\n   * Workers, so for now all scripts must be valid non-module scripts.\n   */\n\n\n  async eval(scriptSource) {\n    await this.import(URL.createObjectURL(new Blob([scriptSource], {\n      type: 'text/javascript'\n    })));\n  }\n  /* end eval marker (do not remove) */\n\n  /**\n   * Load a script by URL in the scene graph execution context. Generally works\n   * the same as eval, but is generally safer because it allows you full control\n   * of the script text. Like eval, does not support module scripts.\n   */\n\n\n  async import(url) {\n    const port = await this[$workerInitializes];\n    port.postMessage({\n      type: ThreeDOMMessageType.IMPORT_SCRIPT,\n      url\n    });\n  }\n  /**\n   * Terminates the scene graph execution context, closes the designated\n   * messaging port and generally cleans up the ThreeDOMExecutionContext\n   * so that it can be properly garbage collected.\n   */\n\n\n  async terminate() {\n    this[$worker].terminate();\n    const modelGraftManipulator = this[$modelGraftManipulator];\n\n    if (modelGraftManipulator != null) {\n      modelGraftManipulator.dispose();\n      this[$modelGraftManipulator] = null;\n    }\n\n    const port = await this[$workerInitializes];\n    port.close();\n  }\n\n}\n_b = $modelGraftManipulator;","map":{"version":3,"sources":["../src/context.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {ThreeDOMCapability} from './api.js';\nimport {ALLOWLISTED_GLOBALS} from './context/allowlist.js';\nimport {generateAPI} from './context/generate-api.js';\nimport {generateCapabilityFilter} from './context/generate-capability-filter.js';\nimport {generateContextPatch} from './context/generate-context-patch.js';\nimport {generateInitializer} from './context/generate-initializer.js';\nimport {ModelGraft} from './facade/api.js';\nimport {MutateMessage, ThreeDOMMessageType} from './protocol.js';\n\nconst $modelGraft = Symbol('modelGraft');\nconst $port = Symbol('port');\n\nconst $messageEventHandler = Symbol('messageEventHandler');\nconst $onMessageEvent = Symbol('onMessageEvent');\n\n/**\n * A ModelGraftManipulator is an internal construct intended to consolidate\n * any mutations that operate on the backing scene graph. It can be thought\n * of as a host execution context counterpart to the ModelKernel in the scene\n * graph execution context.\n */\nclass ModelGraftManipulator {\n  protected[$port]: MessagePort;\n  protected[$modelGraft]: ModelGraft;\n\n  protected[$messageEventHandler] = (event: MessageEvent) =>\n      this[$onMessageEvent](event);\n\n  constructor(modelGraft: ModelGraft, port: MessagePort) {\n    this[$modelGraft] = modelGraft;\n    this[$port] = port;\n    this[$port].addEventListener('message', this[$messageEventHandler]);\n    this[$port].start();\n  }\n\n  /**\n   * Clean up internal state so that the ModelGraftManipulator can be properly\n   * garbage collected.\n   */\n  dispose() {\n    this[$port].removeEventListener('message', this[$messageEventHandler]);\n    this[$port].close();\n  }\n\n  [$onMessageEvent](event: MessageEvent) {\n    const {data} = event;\n    if (data && data.type) {\n      if (data.type === ThreeDOMMessageType.MUTATE) {\n        let applied = false;\n        const {mutationId} = data as MutateMessage;\n        try {\n          this[$modelGraft].mutate(data.id, data.property, data.value);\n          applied = true;\n        } finally {\n          this[$port].postMessage(\n              {type: ThreeDOMMessageType.MUTATION_RESULT, applied, mutationId});\n        }\n      }\n    }\n  }\n}\n\n\nconst ALL_CAPABILITIES: Readonly<Array<ThreeDOMCapability>> =\n    Object.freeze(['messaging', 'material-properties', 'fetch']);\n\n/**\n * Constructs and returns a string representing a fully-formed scene graph\n * execution context script, including context patching, capabilities and\n * scene graph API constructs.\n */\nexport const generateContextScriptSource =\n    (capabilities: Readonly<Array<ThreeDOMCapability>> = ALL_CAPABILITIES) => {\n      return `;(function() {\nvar ThreeDOMMessageType = ${JSON.stringify(ThreeDOMMessageType)};\n\nvar preservedContext = {\n  postMessage: self.postMessage.bind(self),\n  addEventListener: self.addEventListener.bind(self),\n  importScripts: self.importScripts.bind(self)\n};\n\n${generateContextPatch(ALLOWLISTED_GLOBALS)}\n${generateAPI()}\n${generateCapabilityFilter(capabilities)}\n${generateInitializer()}\n\ninitialize.call(self, ModelKernel, preservedContext);\n\n})();`;\n    };\n\n\nconst $worker = Symbol('worker');\nconst $workerInitializes = Symbol('workerInitializes');\nconst $modelGraftManipulator = Symbol('modelGraftManipulator');\n\n/**\n * A ThreeDOMExecutionContext is created in the host execution context that\n * wishes to invoke scripts in a specially crafted and carefully isolated\n * script context, referred to as the scene graph execution context. For\n * practical implementation purposes, the scene graph execution context is\n * a Worker whose global scope has been heavily patched before any custom\n * script is subsequently invoked in it.\n *\n * The ThreeDOMExecutionContext must be given a set of allowed capabilities\n * when it is created. The allowed capabilities cannot be changed after the\n * scene graph execution context has been established.\n */\nexport class ThreeDOMExecutionContext extends EventTarget {\n  get worker() {\n    return this[$worker];\n  }\n\n  protected[$worker]: Worker;\n  protected[$workerInitializes]: Promise<MessagePort>;\n  protected[$modelGraftManipulator]: ModelGraftManipulator|null = null;\n\n  constructor(capabilities: Array<ThreeDOMCapability>) {\n    super();\n\n    const contextScriptSource = generateContextScriptSource(capabilities);\n    const url = URL.createObjectURL(\n        new Blob([contextScriptSource], {type: 'text/javascript'}));\n\n    this[$worker] = new Worker(url);\n    this[$workerInitializes] = new Promise<MessagePort>((resolve) => {\n      const {port1, port2} = new MessageChannel();\n      const onMessageEvent = (event: MessageEvent) => {\n        if (event.data &&\n            event.data.type === ThreeDOMMessageType.CONTEXT_INITIALIZED) {\n          port1.removeEventListener('message', onMessageEvent);\n\n          resolve(port1);\n        }\n      };\n\n      this[$worker].postMessage({type: ThreeDOMMessageType.HANDSHAKE}, [port2]);\n\n      port1.addEventListener('message', onMessageEvent);\n      port1.start();\n    });\n  }\n\n  async changeModel(modelGraft: ModelGraft|null): Promise<void> {\n    const port = await this[$workerInitializes];\n    const {port1, port2} = new MessageChannel();\n\n    port.postMessage(\n        {\n          type: ThreeDOMMessageType.MODEL_CHANGE,\n          model: modelGraft != null && modelGraft.model != null ?\n              modelGraft.model.toJSON() :\n              null\n        },\n        [port2]);\n\n    const modelGraftManipulator = this[$modelGraftManipulator];\n\n    if (modelGraftManipulator != null) {\n      modelGraftManipulator.dispose();\n      this[$modelGraftManipulator] = null;\n    }\n\n    if (modelGraft != null) {\n      this[$modelGraftManipulator] =\n          new ModelGraftManipulator(modelGraft, port1);\n    }\n  }\n\n  /**\n   * Evaluate an arbitrary chunk of script in the scene graph execution context.\n   * The script is guaranteed to be evaluated after the scene graph execution\n   * context is fully initialized. It is not guaranteed to be evaluated before\n   * or after a Model is made available in the scene graph execution context.\n   *\n   * Note that web browsers do not universally support module scripts (\"ESM\") in\n   * Workers, so for now all scripts must be valid non-module scripts.\n   */\n  async eval(scriptSource: string): Promise<void> {\n    await this.import(URL.createObjectURL(\n        new Blob([scriptSource], {type: 'text/javascript'})));\n  } /* end eval marker (do not remove) */\n\n  /**\n   * Load a script by URL in the scene graph execution context. Generally works\n   * the same as eval, but is generally safer because it allows you full control\n   * of the script text. Like eval, does not support module scripts.\n   */\n  async import(url: string): Promise<void> {\n    const port = await this[$workerInitializes];\n    port.postMessage({type: ThreeDOMMessageType.IMPORT_SCRIPT, url});\n  }\n\n  /**\n   * Terminates the scene graph execution context, closes the designated\n   * messaging port and generally cleans up the ThreeDOMExecutionContext\n   * so that it can be properly garbage collected.\n   */\n  async terminate() {\n    this[$worker].terminate();\n\n    const modelGraftManipulator = this[$modelGraftManipulator];\n\n    if (modelGraftManipulator != null) {\n      modelGraftManipulator.dispose();\n      this[$modelGraftManipulator] = null;\n    }\n\n    const port = await this[$workerInitializes];\n    port.close();\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}