{"ast":null,"code":"/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a;\n\nexport const SETTLING_TIME = 10000; // plenty long enough\n\nconst DECAY_MILLISECONDS = 50;\nconst NATURAL_FREQUENCY = 1 / DECAY_MILLISECONDS;\nconst NIL_SPEED = 0.0002 * NATURAL_FREQUENCY;\nconst $velocity = Symbol('velocity');\n/**\n * The Damper class is a generic second-order critically damped system that does\n * one linear step of the desired length of time. The only parameter is\n * DECAY_MILLISECONDS, which should be adjustable: TODO(#580). This common\n * parameter makes all states converge at the same rate regardless of scale.\n * xNormalization is a number to provide the rough scale of x, such that\n * NIL_SPEED clamping also happens at roughly the same convergence for all\n * states.\n */\n\nexport class Damper {\n  constructor() {\n    this[_a] = 0;\n  }\n\n  update(x, xGoal, timeStepMilliseconds, xNormalization) {\n    if (x == null) {\n      return xGoal;\n    }\n\n    if (x === xGoal && this[$velocity] === 0) {\n      return xGoal;\n    }\n\n    if (timeStepMilliseconds < 0) {\n      return x;\n    } // Exact solution to a critically damped second-order system, where:\n    // acceleration = NATURAL_FREQUENCY * NATURAL_FREQUENCY * (xGoal - x) -\n    // 2 * NATURAL_FREQUENCY * this[$velocity];\n\n\n    const deltaX = x - xGoal;\n    const intermediateVelocity = this[$velocity] + NATURAL_FREQUENCY * deltaX;\n    const intermediateX = deltaX + timeStepMilliseconds * intermediateVelocity;\n    const decay = Math.exp(-NATURAL_FREQUENCY * timeStepMilliseconds);\n    const newVelocity = (intermediateVelocity - NATURAL_FREQUENCY * intermediateX) * decay;\n    const acceleration = -NATURAL_FREQUENCY * (newVelocity + intermediateVelocity * decay);\n\n    if (Math.abs(newVelocity) < NIL_SPEED * xNormalization && acceleration * deltaX >= 0) {\n      // This ensures the controls settle and stop calling this function instead\n      // of asymptotically approaching their goal.\n      this[$velocity] = 0;\n      return xGoal;\n    } else {\n      this[$velocity] = newVelocity;\n      return xGoal + intermediateX * decay;\n    }\n  }\n\n}\n_a = $velocity;","map":{"version":3,"sources":["../../src/three-components/Damper.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;AAeA,OAAO,MAAM,aAAa,GAAG,KAAtB,C,CAA8B;;AACrC,MAAM,kBAAkB,GAAG,EAA3B;AACA,MAAM,iBAAiB,GAAG,IAAI,kBAA9B;AACA,MAAM,SAAS,GAAG,SAAS,iBAA3B;AAEA,MAAM,SAAS,GAAG,MAAM,CAAC,UAAD,CAAxB;AAEA;;;;;;;;;;AASA,OAAM,MAAO,MAAP,CAAa;AAAnB,EAAA,WAAA,GAAA;AACS,SAAA,EAAA,IAAsB,CAAtB;AAoCR;;AAlCC,EAAA,MAAM,CACF,CADE,EACS,KADT,EACwB,oBADxB,EAEF,cAFE,EAEoB;AACxB,QAAI,CAAC,IAAI,IAAT,EAAe;AACb,aAAO,KAAP;AACD;;AACD,QAAI,CAAC,KAAK,KAAN,IAAe,KAAK,SAAL,MAAoB,CAAvC,EAA0C;AACxC,aAAO,KAAP;AACD;;AACD,QAAI,oBAAoB,GAAG,CAA3B,EAA8B;AAC5B,aAAO,CAAP;AACD,KATuB,CAUxB;AACA;AACA;;;AACA,UAAM,MAAM,GAAI,CAAC,GAAG,KAApB;AACA,UAAM,oBAAoB,GAAG,KAAK,SAAL,IAAkB,iBAAiB,GAAG,MAAnE;AACA,UAAM,aAAa,GAAG,MAAM,GAAG,oBAAoB,GAAG,oBAAtD;AACA,UAAM,KAAK,GAAG,IAAI,CAAC,GAAL,CAAS,CAAC,iBAAD,GAAqB,oBAA9B,CAAd;AACA,UAAM,WAAW,GACb,CAAC,oBAAoB,GAAG,iBAAiB,GAAG,aAA5C,IAA6D,KADjE;AAEA,UAAM,YAAY,GACd,CAAC,iBAAD,IAAsB,WAAW,GAAG,oBAAoB,GAAG,KAA3D,CADJ;;AAEA,QAAI,IAAI,CAAC,GAAL,CAAS,WAAT,IAAwB,SAAS,GAAG,cAApC,IACA,YAAY,GAAG,MAAf,IAAyB,CAD7B,EACgC;AAC9B;AACA;AACA,WAAK,SAAL,IAAkB,CAAlB;AACA,aAAO,KAAP;AACD,KAND,MAMO;AACL,WAAK,SAAL,IAAkB,WAAlB;AACA,aAAO,KAAK,GAAG,aAAa,GAAG,KAA/B;AACD;AACF;;AApCgB;KACT,S","sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const SETTLING_TIME = 10000;  // plenty long enough\nconst DECAY_MILLISECONDS = 50;\nconst NATURAL_FREQUENCY = 1 / DECAY_MILLISECONDS;\nconst NIL_SPEED = 0.0002 * NATURAL_FREQUENCY;\n\nconst $velocity = Symbol('velocity');\n\n/**\n * The Damper class is a generic second-order critically damped system that does\n * one linear step of the desired length of time. The only parameter is\n * DECAY_MILLISECONDS, which should be adjustable: TODO(#580). This common\n * parameter makes all states converge at the same rate regardless of scale.\n * xNormalization is a number to provide the rough scale of x, such that\n * NIL_SPEED clamping also happens at roughly the same convergence for all\n * states.\n */\nexport class Damper {\n  private[$velocity]: number = 0;\n\n  update(\n      x: number, xGoal: number, timeStepMilliseconds: number,\n      xNormalization: number): number {\n    if (x == null) {\n      return xGoal;\n    }\n    if (x === xGoal && this[$velocity] === 0) {\n      return xGoal;\n    }\n    if (timeStepMilliseconds < 0) {\n      return x;\n    }\n    // Exact solution to a critically damped second-order system, where:\n    // acceleration = NATURAL_FREQUENCY * NATURAL_FREQUENCY * (xGoal - x) -\n    // 2 * NATURAL_FREQUENCY * this[$velocity];\n    const deltaX = (x - xGoal);\n    const intermediateVelocity = this[$velocity] + NATURAL_FREQUENCY * deltaX;\n    const intermediateX = deltaX + timeStepMilliseconds * intermediateVelocity;\n    const decay = Math.exp(-NATURAL_FREQUENCY * timeStepMilliseconds);\n    const newVelocity =\n        (intermediateVelocity - NATURAL_FREQUENCY * intermediateX) * decay;\n    const acceleration =\n        -NATURAL_FREQUENCY * (newVelocity + intermediateVelocity * decay);\n    if (Math.abs(newVelocity) < NIL_SPEED * xNormalization &&\n        acceleration * deltaX >= 0) {\n      // This ensures the controls settle and stop calling this function instead\n      // of asymptotically approaching their goal.\n      this[$velocity] = 0;\n      return xGoal;\n    } else {\n      this[$velocity] = newVelocity;\n      return xGoal + intermediateX * decay;\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}