{"ast":null,"code":"/**\n * Utils for parsing style-like strings (e.g., \"primitive: box; width: 5; height: 4.5\").\n * Some code adapted from `style-attr` (https://github.com/joshwnj/style-attr)\n * by Josh Johnston (MIT License).\n */\nvar DASH_REGEX = /-([a-z])/g;\n/**\n * Deserialize style-like string into an object of properties.\n *\n * @param {string} value - HTML attribute value.\n * @param {object} obj - Reused object for object pooling.\n * @returns {object} Property data.\n */\n\nmodule.exports.parse = function (value, obj) {\n  var parsedData;\n\n  if (typeof value !== 'string') {\n    return value;\n  }\n\n  parsedData = styleParse(value, obj); // The style parser returns an object { \"\" : \"test\"} when fed a string\n\n  if (parsedData['']) {\n    return value;\n  }\n\n  return transformKeysToCamelCase(parsedData);\n};\n/**\n * Serialize an object of properties into a style-like string.\n *\n * @param {object} data - Property data.\n * @returns {string}\n */\n\n\nmodule.exports.stringify = function (data) {\n  if (typeof data === 'string') {\n    return data;\n  }\n\n  return styleStringify(data);\n};\n/**\n * Converts string from hyphen to camelCase.\n *\n * @param {string} str - String to camelCase.\n * @return {string} CamelCased string.\n */\n\n\nfunction toCamelCase(str) {\n  return str.replace(DASH_REGEX, upperCase);\n}\n\nmodule.exports.toCamelCase = toCamelCase;\n/**\n * Converts object's keys from hyphens to camelCase (e.g., `max-value` to\n * `maxValue`).\n *\n * @param {object} obj - The object to camelCase keys.\n * @return {object} The object with keys camelCased.\n */\n\nfunction transformKeysToCamelCase(obj) {\n  var camelKey;\n  var key;\n\n  for (key in obj) {\n    camelKey = toCamelCase(key);\n\n    if (key === camelKey) {\n      continue;\n    }\n\n    obj[camelKey] = obj[key];\n    delete obj[key];\n  }\n\n  return obj;\n}\n\nmodule.exports.transformKeysToCamelCase = transformKeysToCamelCase;\n/**\n * Split a string into chunks matching `<key>: <value>`\n */\n\nvar getKeyValueChunks = function () {\n  var chunks = [];\n  var hasUnclosedUrl = /url\\([^)]+$/;\n  return function getKeyValueChunks(raw) {\n    var chunk = '';\n    var nextSplit;\n    var offset = 0;\n    var sep = ';';\n    chunks.length = 0;\n\n    while (offset < raw.length) {\n      nextSplit = raw.indexOf(sep, offset);\n\n      if (nextSplit === -1) {\n        nextSplit = raw.length;\n      }\n\n      chunk += raw.substring(offset, nextSplit); // data URIs can contain semicolons, so make sure we get the whole thing\n\n      if (hasUnclosedUrl.test(chunk)) {\n        chunk += ';';\n        offset = nextSplit + 1;\n        continue;\n      }\n\n      chunks.push(chunk.trim());\n      chunk = '';\n      offset = nextSplit + 1;\n    }\n\n    return chunks;\n  };\n}();\n/**\n * Convert a style attribute string to an object.\n *\n * @param {object} str - Attribute string.\n * @param {object} obj - Object to reuse as a base, else a new one will be allocated.\n */\n\n\nfunction styleParse(str, obj) {\n  var chunks;\n  var i;\n  var item;\n  var pos;\n  var key;\n  var val;\n  obj = obj || {};\n  chunks = getKeyValueChunks(str);\n\n  for (i = 0; i < chunks.length; i++) {\n    item = chunks[i];\n\n    if (!item) {\n      continue;\n    } // Split with `.indexOf` rather than `.split` because the value may also contain colons.\n\n\n    pos = item.indexOf(':');\n    key = item.substr(0, pos).trim();\n    val = item.substr(pos + 1).trim();\n    obj[key] = val;\n  }\n\n  return obj;\n}\n/**\n * Convert an object into an attribute string\n **/\n\n\nfunction styleStringify(obj) {\n  var key;\n  var keyCount = 0;\n  var i = 0;\n  var str = '';\n\n  for (key in obj) {\n    keyCount++;\n  }\n\n  for (key in obj) {\n    str += key + ': ' + obj[key];\n\n    if (i < keyCount - 1) {\n      str += '; ';\n    }\n\n    i++;\n  }\n\n  return str;\n}\n\nfunction upperCase(str) {\n  return str[1].toUpperCase();\n}","map":{"version":3,"sources":["C:/Users/Hannuri/Desktop/RoyalCyber/my-first-app/node_modules/aframe/src/utils/styleParser.js"],"names":["DASH_REGEX","module","exports","parse","value","obj","parsedData","styleParse","transformKeysToCamelCase","stringify","data","styleStringify","toCamelCase","str","replace","upperCase","camelKey","key","getKeyValueChunks","chunks","hasUnclosedUrl","raw","chunk","nextSplit","offset","sep","length","indexOf","substring","test","push","trim","i","item","pos","val","substr","keyCount","toUpperCase"],"mappings":"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","sourcesContent":["/**\n * Utils for parsing style-like strings (e.g., \"primitive: box; width: 5; height: 4.5\").\n * Some code adapted from `style-attr` (https://github.com/joshwnj/style-attr)\n * by Josh Johnston (MIT License).\n */\nvar DASH_REGEX = /-([a-z])/g;\n\n/**\n * Deserialize style-like string into an object of properties.\n *\n * @param {string} value - HTML attribute value.\n * @param {object} obj - Reused object for object pooling.\n * @returns {object} Property data.\n */\nmodule.exports.parse = function (value, obj) {\n  var parsedData;\n  if (typeof value !== 'string') { return value; }\n  parsedData = styleParse(value, obj);\n  // The style parser returns an object { \"\" : \"test\"} when fed a string\n  if (parsedData['']) { return value; }\n  return transformKeysToCamelCase(parsedData);\n};\n\n/**\n * Serialize an object of properties into a style-like string.\n *\n * @param {object} data - Property data.\n * @returns {string}\n */\nmodule.exports.stringify = function (data) {\n  if (typeof data === 'string') { return data; }\n  return styleStringify(data);\n};\n\n/**\n * Converts string from hyphen to camelCase.\n *\n * @param {string} str - String to camelCase.\n * @return {string} CamelCased string.\n */\nfunction toCamelCase (str) {\n  return str.replace(DASH_REGEX, upperCase);\n}\nmodule.exports.toCamelCase = toCamelCase;\n\n/**\n * Converts object's keys from hyphens to camelCase (e.g., `max-value` to\n * `maxValue`).\n *\n * @param {object} obj - The object to camelCase keys.\n * @return {object} The object with keys camelCased.\n */\nfunction transformKeysToCamelCase (obj) {\n  var camelKey;\n  var key;\n  for (key in obj) {\n    camelKey = toCamelCase(key);\n    if (key === camelKey) { continue; }\n    obj[camelKey] = obj[key];\n    delete obj[key];\n  }\n  return obj;\n}\nmodule.exports.transformKeysToCamelCase = transformKeysToCamelCase;\n\n/**\n * Split a string into chunks matching `<key>: <value>`\n */\nvar getKeyValueChunks = (function () {\n  var chunks = [];\n  var hasUnclosedUrl = /url\\([^)]+$/;\n\n  return function getKeyValueChunks (raw) {\n    var chunk = '';\n    var nextSplit;\n    var offset = 0;\n    var sep = ';';\n\n    chunks.length = 0;\n\n    while (offset < raw.length) {\n      nextSplit = raw.indexOf(sep, offset);\n      if (nextSplit === -1) { nextSplit = raw.length; }\n\n      chunk += raw.substring(offset, nextSplit);\n\n      // data URIs can contain semicolons, so make sure we get the whole thing\n      if (hasUnclosedUrl.test(chunk)) {\n        chunk += ';';\n        offset = nextSplit + 1;\n        continue;\n      }\n\n      chunks.push(chunk.trim());\n      chunk = '';\n      offset = nextSplit + 1;\n    }\n\n    return chunks;\n  };\n})();\n\n/**\n * Convert a style attribute string to an object.\n *\n * @param {object} str - Attribute string.\n * @param {object} obj - Object to reuse as a base, else a new one will be allocated.\n */\nfunction styleParse (str, obj) {\n  var chunks;\n  var i;\n  var item;\n  var pos;\n  var key;\n  var val;\n\n  obj = obj || {};\n\n  chunks = getKeyValueChunks(str);\n  for (i = 0; i < chunks.length; i++) {\n    item = chunks[i];\n    if (!item) { continue; }\n    // Split with `.indexOf` rather than `.split` because the value may also contain colons.\n    pos = item.indexOf(':');\n    key = item.substr(0, pos).trim();\n    val = item.substr(pos + 1).trim();\n    obj[key] = val;\n  }\n  return obj;\n}\n\n/**\n * Convert an object into an attribute string\n **/\nfunction styleStringify (obj) {\n  var key;\n  var keyCount = 0;\n  var i = 0;\n  var str = '';\n\n  for (key in obj) { keyCount++; }\n\n  for (key in obj) {\n    str += (key + ': ' + obj[key]);\n    if (i < keyCount - 1) { str += '; '; }\n    i++;\n  }\n  return str;\n}\n\nfunction upperCase (str) { return str[1].toUpperCase(); }\n"]},"metadata":{},"sourceType":"script"}