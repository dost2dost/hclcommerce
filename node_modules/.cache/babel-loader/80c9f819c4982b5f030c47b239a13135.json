{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a;\n\nimport { PerspectiveCamera, Raycaster, Scene, Vector3 } from 'three';\nimport { USE_OFFSCREEN_CANVAS } from '../constants.js';\nimport { $renderer } from '../model-viewer-base.js';\nimport { Damper, SETTLING_TIME } from './Damper.js';\nimport Model, { DEFAULT_FOV_DEG } from './Model.js';\nexport const IlluminationRole = {\n  Primary: 'primary',\n  Secondary: 'secondary'\n};\nconst DEFAULT_TAN_FOV = Math.tan(DEFAULT_FOV_DEG / 2 * Math.PI / 180);\nconst raycaster = new Raycaster();\nconst vector3 = new Vector3();\nconst $paused = Symbol('paused');\n/**\n * A THREE.Scene object that takes a Model and CanvasHTMLElement and\n * constructs a framed scene based off of the canvas dimensions.\n * Provides lights and cameras to be used in a renderer.\n */\n\nexport class ModelScene extends Scene {\n  constructor({\n    canvas,\n    element,\n    width,\n    height\n  }) {\n    super();\n    this[_a] = false;\n    this.aspect = 1;\n    this.shadowIntensity = 0;\n    this.shadowSoftness = 1;\n    this.width = 1;\n    this.height = 1;\n    this.isDirty = false;\n    this.context = null;\n    this.exposure = 1;\n    this.canScale = true;\n    this.framedFieldOfView = DEFAULT_FOV_DEG; // These default camera values are never used, as they are reset once the\n    // model is loaded and framing is computed.\n\n    this.camera = new PerspectiveCamera(45, 1, 0.1, 100);\n    this.goalTarget = new Vector3();\n    this.targetDamperX = new Damper();\n    this.targetDamperY = new Damper();\n    this.targetDamperZ = new Damper();\n    this.name = 'ModelScene';\n    this.element = element;\n    this.canvas = canvas;\n    this.model = new Model(); // These default camera values are never used, as they are reset once the\n    // model is loaded and framing is computed.\n\n    this.camera = new PerspectiveCamera(45, 1, 0.1, 100);\n    this.camera.name = 'MainCamera';\n    this.activeCamera = this.camera;\n    this.add(this.model);\n    this.setSize(width, height);\n    this.model.addEventListener('model-load', event => this.onModelLoad(event));\n  }\n\n  get paused() {\n    return this[$paused];\n  }\n\n  pause() {\n    this[$paused] = true;\n  }\n\n  resume() {\n    this[$paused] = false;\n  }\n  /**\n   * Function to create the context lazily, as when there is only one\n   * <model-viewer> element, the renderer's 3D context can be displayed\n   * directly. This extra context is necessary to copy the renderings into when\n   * there are more than one.\n   */\n\n\n  createContext() {\n    if (USE_OFFSCREEN_CANVAS) {\n      this.context = this.canvas.getContext('bitmaprenderer');\n    } else {\n      this.context = this.canvas.getContext('2d');\n    }\n  }\n  /**\n   * Sets the model via URL.\n   */\n\n\n  async setModelSource(source, progressCallback) {\n    try {\n      await this.model.setSource(source, progressCallback);\n    } catch (e) {\n      throw new Error(`Could not set model source to '${source}': ${e.message}`);\n    }\n  }\n  /**\n   * Receives the size of the 2D canvas element to make according\n   * adjustments in the scene.\n   */\n\n\n  setSize(width, height) {\n    if (width !== this.width || height !== this.height) {\n      this.width = Math.max(width, 1);\n      this.height = Math.max(height, 1);\n      this.aspect = this.width / this.height;\n      this.frameModel();\n      const renderer = this.element[$renderer];\n      renderer.expandTo(this.width, this.height);\n      this.canvas.width = renderer.width;\n      this.canvas.height = renderer.height; // Immediately queue a render to happen at microtask timing. This is\n      // necessary because setting the width and height of the canvas has the\n      // side-effect of clearing it, and also if we wait for the next rAF to\n      // render again we might get hit with yet-another-resize, or worse we\n      // may not actually be marked as dirty and so render will just not\n      // happen. Queuing a render to happen here means we will render twice on\n      // a resize frame, but it avoids most of the visual artifacts associated\n      // with other potential mitigations for this problem. See discussion in\n      // https://github.com/GoogleWebComponents/model-viewer/pull/619 for\n      // additional considerations.\n\n      Promise.resolve().then(() => {\n        renderer.render(performance.now());\n      });\n    }\n  }\n  /**\n   * Set's the framedFieldOfView based on the aspect ratio of the window in\n   * order to keep the model fully visible at any camera orientation.\n   */\n\n\n  frameModel() {\n    const vertical = DEFAULT_TAN_FOV * Math.max(1, this.model.fieldOfViewAspect / this.aspect);\n    this.framedFieldOfView = 2 * Math.atan(vertical) * 180 / Math.PI;\n  }\n  /**\n   * Returns the size of the corresponding canvas element.\n   */\n\n\n  getSize() {\n    return {\n      width: this.width,\n      height: this.height\n    };\n  }\n  /**\n   * Returns the current camera.\n   */\n\n\n  getCamera() {\n    return this.activeCamera;\n  }\n  /**\n   * Sets the passed in camera to be used for rendering.\n   */\n\n\n  setCamera(camera) {\n    this.activeCamera = camera;\n  }\n  /**\n   * Called when the model's contents have loaded, or changed.\n   */\n\n\n  onModelLoad(event) {\n    this.frameModel();\n    this.setShadowIntensity(this.shadowIntensity);\n    this.isDirty = true;\n    this.dispatchEvent({\n      type: 'model-load',\n      url: event.url\n    });\n  }\n  /**\n   * Sets the point in model coordinates the model should orbit/pivot around.\n   */\n\n\n  setTarget(modelX, modelY, modelZ) {\n    this.goalTarget.set(-modelX, -modelY, -modelZ);\n  }\n  /**\n   * Gets the point in model coordinates the model should orbit/pivot around.\n   */\n\n\n  getTarget() {\n    return vector3.copy(this.goalTarget).multiplyScalar(-1);\n  }\n  /**\n   * Shifts the model to the target point immediately instead of easing in.\n   */\n\n\n  jumpToGoal() {\n    this.updateTarget(SETTLING_TIME);\n  }\n  /**\n   * This should be called every frame with the frame delta to cause the target\n   * to transition to its set point.\n   */\n\n\n  updateTarget(delta) {\n    const goal = this.goalTarget;\n    const target = this.model.position;\n\n    if (!goal.equals(target)) {\n      const radius = this.model.idealCameraDistance;\n      let x = target.x,\n          y = target.y,\n          z = target.z;\n      x = this.targetDamperX.update(x, goal.x, delta, radius);\n      y = this.targetDamperY.update(y, goal.y, delta, radius);\n      z = this.targetDamperZ.update(z, goal.z, delta, radius);\n      this.model.position.set(x, y, z);\n      this.isDirty = true;\n    }\n  }\n  /**\n   * Yaw the +z (front) of the model toward the indicated world coordinates.\n   */\n\n\n  pointTowards(worldX, worldZ) {\n    const _this$position = this.position,\n          x = _this$position.x,\n          z = _this$position.z;\n    this.yaw = Math.atan2(worldX - x, worldZ - z);\n  }\n  /**\n   * Yaw is the scene's orientation about the y-axis, around the rotation\n   * center.\n   */\n\n\n  set yaw(radiansY) {\n    this.rotation.y = radiansY;\n    this.model.setShadowRotation(radiansY);\n    this.isDirty = true;\n  }\n\n  get yaw() {\n    return this.rotation.y;\n  }\n  /**\n   * Sets the shadow's intensity, lazily creating the shadow as necessary.\n   */\n\n\n  setShadowIntensity(shadowIntensity) {\n    shadowIntensity = Math.max(shadowIntensity, 0);\n    this.shadowIntensity = shadowIntensity;\n\n    if (this.model.hasModel()) {\n      this.model.setShadowIntensity(shadowIntensity, this.shadowSoftness);\n    }\n  }\n  /**\n   * Sets the shadow's softness by mapping a [0, 1] softness parameter to the\n   * shadow's resolution. This involves reallocation, so it should not be\n   * changed frequently. Softer shadows are cheaper to render.\n   */\n\n\n  setShadowSoftness(softness) {\n    this.shadowSoftness = softness;\n    this.model.setShadowSoftness(softness);\n  }\n  /**\n   * This method returns the world position and model-space normal of the point\n   * on the mesh corresponding to the input pixel coordinates given relative to\n   * the model-viewer element. If the mesh is not hit, the result is null.\n   */\n\n\n  positionAndNormalFromPoint(pixelPosition, object = this) {\n    raycaster.setFromCamera(pixelPosition, this.getCamera());\n    const hits = raycaster.intersectObject(object, true);\n\n    if (hits.length === 0) {\n      return null;\n    }\n\n    const hit = hits[0];\n\n    if (hit.face == null) {\n      return null;\n    }\n\n    return {\n      position: hit.point,\n      normal: hit.face.normal\n    };\n  }\n\n}\n_a = $paused;","map":{"version":3,"sources":["../../src/three-components/ModelScene.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Camera, Event as ThreeEvent, Object3D, PerspectiveCamera, Raycaster, Scene, Vector2, Vector3} from 'three';\n\nimport {USE_OFFSCREEN_CANVAS} from '../constants.js';\nimport ModelViewerElementBase, {$renderer} from '../model-viewer-base.js';\n\nimport {Damper, SETTLING_TIME} from './Damper.js';\nimport Model, {DEFAULT_FOV_DEG} from './Model.js';\n\nexport interface ModelLoadEvent extends ThreeEvent {\n  url: string\n}\n\nexport interface ModelSceneConfig {\n  element: ModelViewerElementBase;\n  canvas: HTMLCanvasElement;\n  width: number;\n  height: number;\n}\n\nexport type IlluminationRole = 'primary'|'secondary'\n\nexport const IlluminationRole: {[index: string]: IlluminationRole} = {\n  Primary: 'primary',\n  Secondary: 'secondary'\n};\n\nconst DEFAULT_TAN_FOV = Math.tan((DEFAULT_FOV_DEG / 2) * Math.PI / 180);\n\nconst raycaster = new Raycaster();\nconst vector3 = new Vector3();\n\nconst $paused = Symbol('paused');\n\n/**\n * A THREE.Scene object that takes a Model and CanvasHTMLElement and\n * constructs a framed scene based off of the canvas dimensions.\n * Provides lights and cameras to be used in a renderer.\n */\nexport class ModelScene extends Scene {\n  private[$paused]: boolean = false;\n\n  public aspect = 1;\n  public canvas: HTMLCanvasElement;\n  public shadowIntensity = 0;\n  public shadowSoftness = 1;\n  public width = 1;\n  public height = 1;\n  public isDirty: boolean = false;\n  public element: ModelViewerElementBase;\n  public context: CanvasRenderingContext2D|ImageBitmapRenderingContext|null =\n      null;\n  public exposure = 1;\n  public model: Model;\n  public canScale = true;\n  public framedFieldOfView = DEFAULT_FOV_DEG;\n  public activeCamera: Camera;\n  // These default camera values are never used, as they are reset once the\n  // model is loaded and framing is computed.\n  public camera = new PerspectiveCamera(45, 1, 0.1, 100);\n\n  private goalTarget = new Vector3();\n  private targetDamperX = new Damper();\n  private targetDamperY = new Damper();\n  private targetDamperZ = new Damper();\n\n  constructor({canvas, element, width, height}: ModelSceneConfig) {\n    super();\n\n    this.name = 'ModelScene';\n\n    this.element = element;\n    this.canvas = canvas;\n    this.model = new Model();\n\n    // These default camera values are never used, as they are reset once the\n    // model is loaded and framing is computed.\n    this.camera = new PerspectiveCamera(45, 1, 0.1, 100);\n    this.camera.name = 'MainCamera';\n\n    this.activeCamera = this.camera;\n\n    this.add(this.model);\n\n    this.setSize(width, height);\n\n    this.model.addEventListener(\n        'model-load', (event: any) => this.onModelLoad(event));\n  }\n\n  get paused() {\n    return this[$paused];\n  }\n\n  pause() {\n    this[$paused] = true;\n  }\n\n  resume() {\n    this[$paused] = false;\n  }\n\n  /**\n   * Function to create the context lazily, as when there is only one\n   * <model-viewer> element, the renderer's 3D context can be displayed\n   * directly. This extra context is necessary to copy the renderings into when\n   * there are more than one.\n   */\n  createContext() {\n    if (USE_OFFSCREEN_CANVAS) {\n      this.context = this.canvas.getContext('bitmaprenderer')!;\n    } else {\n      this.context = this.canvas.getContext('2d')!;\n    }\n  }\n\n  /**\n   * Sets the model via URL.\n   */\n  async setModelSource(\n      source: string|null, progressCallback?: (progress: number) => void) {\n    try {\n      await this.model.setSource(source, progressCallback);\n    } catch (e) {\n      throw new Error(\n          `Could not set model source to '${source}': ${e.message}`);\n    }\n  }\n\n  /**\n   * Receives the size of the 2D canvas element to make according\n   * adjustments in the scene.\n   */\n  setSize(width: number, height: number) {\n    if (width !== this.width || height !== this.height) {\n      this.width = Math.max(width, 1);\n      this.height = Math.max(height, 1);\n\n      this.aspect = this.width / this.height;\n      this.frameModel();\n\n      const renderer = this.element[$renderer];\n      renderer.expandTo(this.width, this.height);\n      this.canvas.width = renderer.width;\n      this.canvas.height = renderer.height;\n\n      // Immediately queue a render to happen at microtask timing. This is\n      // necessary because setting the width and height of the canvas has the\n      // side-effect of clearing it, and also if we wait for the next rAF to\n      // render again we might get hit with yet-another-resize, or worse we\n      // may not actually be marked as dirty and so render will just not\n      // happen. Queuing a render to happen here means we will render twice on\n      // a resize frame, but it avoids most of the visual artifacts associated\n      // with other potential mitigations for this problem. See discussion in\n      // https://github.com/GoogleWebComponents/model-viewer/pull/619 for\n      // additional considerations.\n      Promise.resolve().then(() => {\n        renderer.render(performance.now());\n      });\n    }\n  }\n\n  /**\n   * Set's the framedFieldOfView based on the aspect ratio of the window in\n   * order to keep the model fully visible at any camera orientation.\n   */\n  frameModel() {\n    const vertical = DEFAULT_TAN_FOV *\n        Math.max(1, this.model.fieldOfViewAspect / this.aspect);\n    this.framedFieldOfView = 2 * Math.atan(vertical) * 180 / Math.PI;\n  }\n\n  /**\n   * Returns the size of the corresponding canvas element.\n   */\n  getSize(): {width: number, height: number} {\n    return {width: this.width, height: this.height};\n  }\n\n  /**\n   * Returns the current camera.\n   */\n  getCamera(): Camera {\n    return this.activeCamera;\n  }\n\n  /**\n   * Sets the passed in camera to be used for rendering.\n   */\n  setCamera(camera: Camera) {\n    this.activeCamera = camera;\n  }\n\n  /**\n   * Called when the model's contents have loaded, or changed.\n   */\n  onModelLoad(event: {url: string}) {\n    this.frameModel();\n    this.setShadowIntensity(this.shadowIntensity);\n    this.isDirty = true;\n    this.dispatchEvent({type: 'model-load', url: event.url});\n  }\n\n  /**\n   * Sets the point in model coordinates the model should orbit/pivot around.\n   */\n  setTarget(modelX: number, modelY: number, modelZ: number) {\n    this.goalTarget.set(-modelX, -modelY, -modelZ);\n  }\n\n  /**\n   * Gets the point in model coordinates the model should orbit/pivot around.\n   */\n  getTarget(): Vector3 {\n    return vector3.copy(this.goalTarget).multiplyScalar(-1);\n  }\n\n  /**\n   * Shifts the model to the target point immediately instead of easing in.\n   */\n  jumpToGoal() {\n    this.updateTarget(SETTLING_TIME);\n  }\n\n  /**\n   * This should be called every frame with the frame delta to cause the target\n   * to transition to its set point.\n   */\n  updateTarget(delta: number) {\n    const goal = this.goalTarget;\n    const target = this.model.position;\n    if (!goal.equals(target)) {\n      const radius = this.model.idealCameraDistance;\n      let {x, y, z} = target;\n      x = this.targetDamperX.update(x, goal.x, delta, radius);\n      y = this.targetDamperY.update(y, goal.y, delta, radius);\n      z = this.targetDamperZ.update(z, goal.z, delta, radius);\n      this.model.position.set(x, y, z);\n      this.isDirty = true;\n    }\n  }\n\n  /**\n   * Yaw the +z (front) of the model toward the indicated world coordinates.\n   */\n  pointTowards(worldX: number, worldZ: number) {\n    const {x, z} = this.position;\n    this.yaw = Math.atan2(worldX - x, worldZ - z);\n  }\n\n  /**\n   * Yaw is the scene's orientation about the y-axis, around the rotation\n   * center.\n   */\n  set yaw(radiansY: number) {\n    this.rotation.y = radiansY;\n    this.model.setShadowRotation(radiansY);\n    this.isDirty = true;\n  }\n\n  get yaw(): number {\n    return this.rotation.y;\n  }\n\n  /**\n   * Sets the shadow's intensity, lazily creating the shadow as necessary.\n   */\n  setShadowIntensity(shadowIntensity: number) {\n    shadowIntensity = Math.max(shadowIntensity, 0);\n    this.shadowIntensity = shadowIntensity;\n    if (this.model.hasModel()) {\n      this.model.setShadowIntensity(shadowIntensity, this.shadowSoftness);\n    }\n  }\n\n  /**\n   * Sets the shadow's softness by mapping a [0, 1] softness parameter to the\n   * shadow's resolution. This involves reallocation, so it should not be\n   * changed frequently. Softer shadows are cheaper to render.\n   */\n  setShadowSoftness(softness: number) {\n    this.shadowSoftness = softness;\n    this.model.setShadowSoftness(softness);\n  }\n\n  /**\n   * This method returns the world position and model-space normal of the point\n   * on the mesh corresponding to the input pixel coordinates given relative to\n   * the model-viewer element. If the mesh is not hit, the result is null.\n   */\n  positionAndNormalFromPoint(pixelPosition: Vector2, object: Object3D = this):\n      {position: Vector3, normal: Vector3}|null {\n    raycaster.setFromCamera(pixelPosition, this.getCamera());\n    const hits = raycaster.intersectObject(object, true);\n\n    if (hits.length === 0) {\n      return null;\n    }\n\n    const hit = hits[0];\n    if (hit.face == null) {\n      return null;\n    }\n\n    return {position: hit.point, normal: hit.face.normal};\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}