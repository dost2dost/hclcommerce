{"ast":null,"code":"var registerComponent = require('../core/component').registerComponent;\n\nvar controllerUtils = require('../utils/tracked-controls');\n\nvar DEFAULT_CAMERA_HEIGHT = require('../constants').DEFAULT_CAMERA_HEIGHT;\n\nvar THREE = require('../lib/three');\n\nvar DEFAULT_HANDEDNESS = require('../constants').DEFAULT_HANDEDNESS; // Vector from eyes to elbow (divided by user height).\n\n\nvar EYES_TO_ELBOW = {\n  x: 0.175,\n  y: -0.3,\n  z: -0.03\n}; // Vector from eyes to elbow (divided by user height).\n\nvar FOREARM = {\n  x: 0,\n  y: 0,\n  z: -0.175\n}; // Due to unfortunate name collision, add empty touches array to avoid Daydream error.\n\nvar EMPTY_DAYDREAM_TOUCHES = {\n  touches: []\n};\nvar EVENTS = {\n  AXISMOVE: 'axismove',\n  BUTTONCHANGED: 'buttonchanged',\n  BUTTONDOWN: 'buttondown',\n  BUTTONUP: 'buttonup',\n  TOUCHSTART: 'touchstart',\n  TOUCHEND: 'touchend'\n};\n/**\n * Tracked controls component.\n * Wrap the gamepad API for pose and button states.\n * Select the appropriate controller and apply pose to the entity.\n * Observe button states and emit appropriate events.\n *\n * @property {number} controller - Index of controller in array returned by Gamepad API.\n *  Only used if hand property is not set.\n * @property {string} id - Selected controller among those returned by Gamepad API.\n * @property {number} hand - If multiple controllers found with id, choose the one with the\n *  given value for hand. If set, we ignore 'controller' property\n */\n\nmodule.exports.Component = registerComponent('tracked-controls-webvr', {\n  schema: {\n    autoHide: {\n      default: true\n    },\n    controller: {\n      default: 0\n    },\n    id: {\n      type: 'string',\n      default: ''\n    },\n    hand: {\n      type: 'string',\n      default: ''\n    },\n    idPrefix: {\n      type: 'string',\n      default: ''\n    },\n    orientationOffset: {\n      type: 'vec3'\n    },\n    // Arm model parameters when not 6DoF.\n    armModel: {\n      default: true\n    },\n    headElement: {\n      type: 'selector'\n    }\n  },\n  init: function () {\n    // Copy variables back to tracked-controls for backwards compatibility.\n    // Some 3rd components rely on them.\n    this.axis = this.el.components['tracked-controls'].axis = [0, 0, 0];\n    this.buttonStates = this.el.components['tracked-controls'].buttonStates = {};\n    this.changedAxes = [];\n    this.targetControllerNumber = this.data.controller;\n    this.axisMoveEventDetail = {\n      axis: this.axis,\n      changed: this.changedAxes\n    };\n    this.deltaControllerPosition = new THREE.Vector3();\n    this.controllerQuaternion = new THREE.Quaternion();\n    this.controllerEuler = new THREE.Euler();\n    this.updateGamepad();\n    this.buttonEventDetails = {};\n  },\n  tick: function (time, delta) {\n    var mesh = this.el.getObject3D('mesh'); // Update mesh animations.\n\n    if (mesh && mesh.update) {\n      mesh.update(delta / 1000);\n    }\n\n    this.updateGamepad();\n    this.updatePose();\n    this.updateButtons();\n  },\n\n  /**\n   * Return default user height to use for non-6DOF arm model.\n   */\n  defaultUserHeight: function () {\n    return DEFAULT_CAMERA_HEIGHT;\n  },\n\n  /**\n   * Return head element to use for non-6DOF arm model.\n   */\n  getHeadElement: function () {\n    return this.data.headElement || this.el.sceneEl.camera.el;\n  },\n\n  /**\n   * Handle update controller match criteria (such as `id`, `idPrefix`, `hand`, `controller`)\n   */\n  updateGamepad: function () {\n    var data = this.data;\n    var controller = controllerUtils.findMatchingControllerWebVR(this.system.controllers, data.id, data.idPrefix, data.hand, data.controller);\n    this.controller = controller; // Legacy handle to the controller for old components.\n\n    this.el.components['tracked-controls'].controller = controller;\n\n    if (this.data.autoHide) {\n      this.el.object3D.visible = !!this.controller;\n    }\n  },\n\n  /**\n   * Applies an artificial arm model to simulate elbow to wrist positioning\n   * based on the orientation of the controller.\n   *\n   * @param {object} controllerPosition - Existing vector to update with controller position.\n   */\n  applyArmModel: function (controllerPosition) {\n    // Use controllerPosition and deltaControllerPosition to avoid creating variables.\n    var controller = this.controller;\n    var controllerEuler = this.controllerEuler;\n    var controllerQuaternion = this.controllerQuaternion;\n    var deltaControllerPosition = this.deltaControllerPosition;\n    var hand;\n    var headEl;\n    var headObject3D;\n    var pose;\n    var userHeight;\n    headEl = this.getHeadElement();\n    headObject3D = headEl.object3D;\n    userHeight = this.defaultUserHeight();\n    pose = controller.pose;\n    hand = (controller ? controller.hand : undefined) || DEFAULT_HANDEDNESS; // Use camera position as head position.\n\n    controllerPosition.copy(headObject3D.position); // Set offset for degenerate \"arm model\" to elbow.\n\n    deltaControllerPosition.set(EYES_TO_ELBOW.x * (hand === 'left' ? -1 : hand === 'right' ? 1 : 0), EYES_TO_ELBOW.y, // Lower than our eyes.\n    EYES_TO_ELBOW.z); // Slightly out in front.\n    // Scale offset by user height.\n\n    deltaControllerPosition.multiplyScalar(userHeight); // Apply camera Y rotation (not X or Z, so you can look down at your hand).\n\n    deltaControllerPosition.applyAxisAngle(headObject3D.up, headObject3D.rotation.y); // Apply rotated offset to position.\n\n    controllerPosition.add(deltaControllerPosition); // Set offset for degenerate \"arm model\" forearm. Forearm sticking out from elbow.\n\n    deltaControllerPosition.set(FOREARM.x, FOREARM.y, FOREARM.z); // Scale offset by user height.\n\n    deltaControllerPosition.multiplyScalar(userHeight); // Apply controller X/Y rotation (tilting up/down/left/right is usually moving the arm).\n\n    if (pose.orientation) {\n      controllerQuaternion.fromArray(pose.orientation);\n    } else {\n      controllerQuaternion.copy(headObject3D.quaternion);\n    }\n\n    controllerEuler.setFromQuaternion(controllerQuaternion);\n    controllerEuler.set(controllerEuler.x, controllerEuler.y, 0);\n    deltaControllerPosition.applyEuler(controllerEuler); // Apply rotated offset to position.\n\n    controllerPosition.add(deltaControllerPosition);\n  },\n\n  /**\n   * Read pose from controller (from Gamepad API), apply transforms, apply to entity.\n   */\n  updatePose: function () {\n    var controller = this.controller;\n    var data = this.data;\n    var object3D = this.el.object3D;\n    var pose;\n    var vrDisplay = this.system.vrDisplay;\n    var standingMatrix;\n\n    if (!controller) {\n      return;\n    } // Compose pose from Gamepad.\n\n\n    pose = controller.pose;\n\n    if (pose.position) {\n      object3D.position.fromArray(pose.position);\n    } else {\n      // Controller not 6DOF, apply arm model.\n      if (data.armModel) {\n        this.applyArmModel(object3D.position);\n      }\n    }\n\n    if (pose.orientation) {\n      object3D.quaternion.fromArray(pose.orientation);\n    } // Apply transforms, if 6DOF and in VR.\n\n\n    if (vrDisplay && pose.position) {\n      standingMatrix = this.el.sceneEl.renderer.xr.getStandingMatrix();\n      object3D.matrix.compose(object3D.position, object3D.quaternion, object3D.scale);\n      object3D.matrix.multiplyMatrices(standingMatrix, object3D.matrix);\n      object3D.matrix.decompose(object3D.position, object3D.quaternion, object3D.scale);\n    }\n\n    object3D.rotateX(this.data.orientationOffset.x * THREE.Math.DEG2RAD);\n    object3D.rotateY(this.data.orientationOffset.y * THREE.Math.DEG2RAD);\n    object3D.rotateZ(this.data.orientationOffset.z * THREE.Math.DEG2RAD);\n  },\n\n  /**\n   * Handle button changes including axes, presses, touches, values.\n   */\n  updateButtons: function () {\n    var buttonState;\n    var controller = this.controller;\n    var id;\n\n    if (!controller) {\n      return;\n    } // Check every button.\n\n\n    for (id = 0; id < controller.buttons.length; ++id) {\n      // Initialize button state.\n      if (!this.buttonStates[id]) {\n        this.buttonStates[id] = {\n          pressed: false,\n          touched: false,\n          value: 0\n        };\n      }\n\n      if (!this.buttonEventDetails[id]) {\n        this.buttonEventDetails[id] = {\n          id: id,\n          state: this.buttonStates[id]\n        };\n      }\n\n      buttonState = controller.buttons[id];\n      this.handleButton(id, buttonState);\n    } // Check axes.\n\n\n    this.handleAxes();\n  },\n\n  /**\n   * Handle presses and touches for a single button.\n   *\n   * @param {number} id - Index of button in Gamepad button array.\n   * @param {number} buttonState - Value of button state from 0 to 1.\n   * @returns {boolean} Whether button has changed in any way.\n   */\n  handleButton: function (id, buttonState) {\n    var changed;\n    changed = this.handlePress(id, buttonState) | this.handleTouch(id, buttonState) | this.handleValue(id, buttonState);\n\n    if (!changed) {\n      return false;\n    }\n\n    this.el.emit(EVENTS.BUTTONCHANGED, this.buttonEventDetails[id], false);\n    return true;\n  },\n\n  /**\n   * An axis is an array of values from -1 (up, left) to 1 (down, right).\n   * Compare each component of the axis to the previous value to determine change.\n   *\n   * @returns {boolean} Whether axes changed.\n   */\n  handleAxes: function () {\n    var changed = false;\n    var controllerAxes = this.controller.axes;\n    var i;\n    var previousAxis = this.axis;\n    var changedAxes = this.changedAxes; // Check if axis changed.\n\n    this.changedAxes.length = 0;\n\n    for (i = 0; i < controllerAxes.length; ++i) {\n      changedAxes.push(previousAxis[i] !== controllerAxes[i]);\n\n      if (changedAxes[i]) {\n        changed = true;\n      }\n    }\n\n    if (!changed) {\n      return false;\n    }\n\n    this.axis.length = 0;\n\n    for (i = 0; i < controllerAxes.length; i++) {\n      this.axis.push(controllerAxes[i]);\n    }\n\n    this.el.emit(EVENTS.AXISMOVE, this.axisMoveEventDetail, false);\n    return true;\n  },\n\n  /**\n   * Determine whether a button press has occured and emit events as appropriate.\n   *\n   * @param {string} id - ID of the button to check.\n   * @param {object} buttonState - State of the button to check.\n   * @returns {boolean} Whether button press state changed.\n   */\n  handlePress: function (id, buttonState) {\n    var evtName;\n    var previousButtonState = this.buttonStates[id]; // Not changed.\n\n    if (buttonState.pressed === previousButtonState.pressed) {\n      return false;\n    }\n\n    evtName = buttonState.pressed ? EVENTS.BUTTONDOWN : EVENTS.BUTTONUP;\n    this.el.emit(evtName, this.buttonEventDetails[id], false);\n    previousButtonState.pressed = buttonState.pressed;\n    return true;\n  },\n\n  /**\n   * Determine whether a button touch has occured and emit events as appropriate.\n   *\n   * @param {string} id - ID of the button to check.\n   * @param {object} buttonState - State of the button to check.\n   * @returns {boolean} Whether button touch state changed.\n   */\n  handleTouch: function (id, buttonState) {\n    var evtName;\n    var previousButtonState = this.buttonStates[id]; // Not changed.\n\n    if (buttonState.touched === previousButtonState.touched) {\n      return false;\n    }\n\n    evtName = buttonState.touched ? EVENTS.TOUCHSTART : EVENTS.TOUCHEND;\n    this.el.emit(evtName, this.buttonEventDetails[id], false, EMPTY_DAYDREAM_TOUCHES);\n    previousButtonState.touched = buttonState.touched;\n    return true;\n  },\n\n  /**\n   * Determine whether a button value has changed.\n   *\n   * @param {string} id - Id of the button to check.\n   * @param {object} buttonState - State of the button to check.\n   * @returns {boolean} Whether button value changed.\n   */\n  handleValue: function (id, buttonState) {\n    var previousButtonState = this.buttonStates[id]; // Not changed.\n\n    if (buttonState.value === previousButtonState.value) {\n      return false;\n    }\n\n    previousButtonState.value = buttonState.value;\n    return true;\n  }\n});","map":{"version":3,"sources":["C:/Users/Hannuri/Desktop/RoyalCyber/my-first-app/node_modules/aframe/src/components/tracked-controls-webvr.js"],"names":["registerComponent","require","controllerUtils","DEFAULT_CAMERA_HEIGHT","THREE","DEFAULT_HANDEDNESS","EYES_TO_ELBOW","x","y","z","FOREARM","EMPTY_DAYDREAM_TOUCHES","touches","EVENTS","AXISMOVE","BUTTONCHANGED","BUTTONDOWN","BUTTONUP","TOUCHSTART","TOUCHEND","module","exports","Component","schema","autoHide","default","controller","id","type","hand","idPrefix","orientationOffset","armModel","headElement","init","axis","el","components","buttonStates","changedAxes","targetControllerNumber","data","axisMoveEventDetail","changed","deltaControllerPosition","Vector3","controllerQuaternion","Quaternion","controllerEuler","Euler","updateGamepad","buttonEventDetails","tick","time","delta","mesh","getObject3D","update","updatePose","updateButtons","defaultUserHeight","getHeadElement","sceneEl","camera","findMatchingControllerWebVR","system","controllers","object3D","visible","applyArmModel","controllerPosition","headEl","headObject3D","pose","userHeight","undefined","copy","position","set","multiplyScalar","applyAxisAngle","up","rotation","add","orientation","fromArray","quaternion","setFromQuaternion","applyEuler","vrDisplay","standingMatrix","renderer","xr","getStandingMatrix","matrix","compose","scale","multiplyMatrices","decompose","rotateX","Math","DEG2RAD","rotateY","rotateZ","buttonState","buttons","length","pressed","touched","value","state","handleButton","handleAxes","handlePress","handleTouch","handleValue","emit","controllerAxes","axes","i","previousAxis","push","evtName","previousButtonState"],"mappings":"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","sourcesContent":["var registerComponent = require('../core/component').registerComponent;\nvar controllerUtils = require('../utils/tracked-controls');\nvar DEFAULT_CAMERA_HEIGHT = require('../constants').DEFAULT_CAMERA_HEIGHT;\nvar THREE = require('../lib/three');\n\nvar DEFAULT_HANDEDNESS = require('../constants').DEFAULT_HANDEDNESS;\n// Vector from eyes to elbow (divided by user height).\nvar EYES_TO_ELBOW = {x: 0.175, y: -0.3, z: -0.03};\n// Vector from eyes to elbow (divided by user height).\nvar FOREARM = {x: 0, y: 0, z: -0.175};\n\n// Due to unfortunate name collision, add empty touches array to avoid Daydream error.\nvar EMPTY_DAYDREAM_TOUCHES = {touches: []};\n\nvar EVENTS = {\n  AXISMOVE: 'axismove',\n  BUTTONCHANGED: 'buttonchanged',\n  BUTTONDOWN: 'buttondown',\n  BUTTONUP: 'buttonup',\n  TOUCHSTART: 'touchstart',\n  TOUCHEND: 'touchend'\n};\n\n/**\n * Tracked controls component.\n * Wrap the gamepad API for pose and button states.\n * Select the appropriate controller and apply pose to the entity.\n * Observe button states and emit appropriate events.\n *\n * @property {number} controller - Index of controller in array returned by Gamepad API.\n *  Only used if hand property is not set.\n * @property {string} id - Selected controller among those returned by Gamepad API.\n * @property {number} hand - If multiple controllers found with id, choose the one with the\n *  given value for hand. If set, we ignore 'controller' property\n */\nmodule.exports.Component = registerComponent('tracked-controls-webvr', {\n  schema: {\n    autoHide: {default: true},\n    controller: {default: 0},\n    id: {type: 'string', default: ''},\n    hand: {type: 'string', default: ''},\n    idPrefix: {type: 'string', default: ''},\n    orientationOffset: {type: 'vec3'},\n    // Arm model parameters when not 6DoF.\n    armModel: {default: true},\n    headElement: {type: 'selector'}\n  },\n\n  init: function () {\n    // Copy variables back to tracked-controls for backwards compatibility.\n    // Some 3rd components rely on them.\n    this.axis = this.el.components['tracked-controls'].axis = [0, 0, 0];\n    this.buttonStates = this.el.components['tracked-controls'].buttonStates = {};\n    this.changedAxes = [];\n    this.targetControllerNumber = this.data.controller;\n\n    this.axisMoveEventDetail = {axis: this.axis, changed: this.changedAxes};\n    this.deltaControllerPosition = new THREE.Vector3();\n    this.controllerQuaternion = new THREE.Quaternion();\n    this.controllerEuler = new THREE.Euler();\n\n    this.updateGamepad();\n\n    this.buttonEventDetails = {};\n  },\n\n  tick: function (time, delta) {\n    var mesh = this.el.getObject3D('mesh');\n    // Update mesh animations.\n    if (mesh && mesh.update) { mesh.update(delta / 1000); }\n    this.updateGamepad();\n    this.updatePose();\n    this.updateButtons();\n  },\n\n  /**\n   * Return default user height to use for non-6DOF arm model.\n   */\n  defaultUserHeight: function () {\n    return DEFAULT_CAMERA_HEIGHT;\n  },\n\n  /**\n   * Return head element to use for non-6DOF arm model.\n   */\n  getHeadElement: function () {\n    return this.data.headElement || this.el.sceneEl.camera.el;\n  },\n\n  /**\n   * Handle update controller match criteria (such as `id`, `idPrefix`, `hand`, `controller`)\n   */\n  updateGamepad: function () {\n    var data = this.data;\n    var controller = controllerUtils.findMatchingControllerWebVR(\n      this.system.controllers,\n      data.id,\n      data.idPrefix,\n      data.hand,\n      data.controller\n    );\n\n    this.controller = controller;\n    // Legacy handle to the controller for old components.\n    this.el.components['tracked-controls'].controller = controller;\n\n    if (this.data.autoHide) { this.el.object3D.visible = !!this.controller; }\n  },\n\n  /**\n   * Applies an artificial arm model to simulate elbow to wrist positioning\n   * based on the orientation of the controller.\n   *\n   * @param {object} controllerPosition - Existing vector to update with controller position.\n   */\n  applyArmModel: function (controllerPosition) {\n    // Use controllerPosition and deltaControllerPosition to avoid creating variables.\n    var controller = this.controller;\n    var controllerEuler = this.controllerEuler;\n    var controllerQuaternion = this.controllerQuaternion;\n    var deltaControllerPosition = this.deltaControllerPosition;\n    var hand;\n    var headEl;\n    var headObject3D;\n    var pose;\n    var userHeight;\n\n    headEl = this.getHeadElement();\n    headObject3D = headEl.object3D;\n    userHeight = this.defaultUserHeight();\n\n    pose = controller.pose;\n    hand = (controller ? controller.hand : undefined) || DEFAULT_HANDEDNESS;\n\n    // Use camera position as head position.\n    controllerPosition.copy(headObject3D.position);\n    // Set offset for degenerate \"arm model\" to elbow.\n    deltaControllerPosition.set(\n      EYES_TO_ELBOW.x * (hand === 'left' ? -1 : hand === 'right' ? 1 : 0),\n      EYES_TO_ELBOW.y,  // Lower than our eyes.\n      EYES_TO_ELBOW.z);  // Slightly out in front.\n    // Scale offset by user height.\n    deltaControllerPosition.multiplyScalar(userHeight);\n    // Apply camera Y rotation (not X or Z, so you can look down at your hand).\n    deltaControllerPosition.applyAxisAngle(headObject3D.up, headObject3D.rotation.y);\n    // Apply rotated offset to position.\n    controllerPosition.add(deltaControllerPosition);\n\n    // Set offset for degenerate \"arm model\" forearm. Forearm sticking out from elbow.\n    deltaControllerPosition.set(FOREARM.x, FOREARM.y, FOREARM.z);\n    // Scale offset by user height.\n    deltaControllerPosition.multiplyScalar(userHeight);\n    // Apply controller X/Y rotation (tilting up/down/left/right is usually moving the arm).\n    if (pose.orientation) {\n      controllerQuaternion.fromArray(pose.orientation);\n    } else {\n      controllerQuaternion.copy(headObject3D.quaternion);\n    }\n    controllerEuler.setFromQuaternion(controllerQuaternion);\n    controllerEuler.set(controllerEuler.x, controllerEuler.y, 0);\n    deltaControllerPosition.applyEuler(controllerEuler);\n    // Apply rotated offset to position.\n    controllerPosition.add(deltaControllerPosition);\n  },\n\n  /**\n   * Read pose from controller (from Gamepad API), apply transforms, apply to entity.\n   */\n  updatePose: function () {\n    var controller = this.controller;\n    var data = this.data;\n    var object3D = this.el.object3D;\n    var pose;\n    var vrDisplay = this.system.vrDisplay;\n    var standingMatrix;\n\n    if (!controller) { return; }\n\n    // Compose pose from Gamepad.\n    pose = controller.pose;\n\n    if (pose.position) {\n      object3D.position.fromArray(pose.position);\n    } else {\n      // Controller not 6DOF, apply arm model.\n      if (data.armModel) { this.applyArmModel(object3D.position); }\n    }\n\n    if (pose.orientation) {\n      object3D.quaternion.fromArray(pose.orientation);\n    }\n\n    // Apply transforms, if 6DOF and in VR.\n    if (vrDisplay && pose.position) {\n      standingMatrix = this.el.sceneEl.renderer.xr.getStandingMatrix();\n      object3D.matrix.compose(object3D.position, object3D.quaternion, object3D.scale);\n      object3D.matrix.multiplyMatrices(standingMatrix, object3D.matrix);\n      object3D.matrix.decompose(object3D.position, object3D.quaternion, object3D.scale);\n    }\n\n    object3D.rotateX(this.data.orientationOffset.x * THREE.Math.DEG2RAD);\n    object3D.rotateY(this.data.orientationOffset.y * THREE.Math.DEG2RAD);\n    object3D.rotateZ(this.data.orientationOffset.z * THREE.Math.DEG2RAD);\n  },\n\n  /**\n   * Handle button changes including axes, presses, touches, values.\n   */\n  updateButtons: function () {\n    var buttonState;\n    var controller = this.controller;\n    var id;\n\n    if (!controller) { return; }\n\n    // Check every button.\n    for (id = 0; id < controller.buttons.length; ++id) {\n      // Initialize button state.\n      if (!this.buttonStates[id]) {\n        this.buttonStates[id] = {pressed: false, touched: false, value: 0};\n      }\n      if (!this.buttonEventDetails[id]) {\n        this.buttonEventDetails[id] = {id: id, state: this.buttonStates[id]};\n      }\n\n      buttonState = controller.buttons[id];\n      this.handleButton(id, buttonState);\n    }\n    // Check axes.\n    this.handleAxes();\n  },\n\n  /**\n   * Handle presses and touches for a single button.\n   *\n   * @param {number} id - Index of button in Gamepad button array.\n   * @param {number} buttonState - Value of button state from 0 to 1.\n   * @returns {boolean} Whether button has changed in any way.\n   */\n  handleButton: function (id, buttonState) {\n    var changed;\n    changed = this.handlePress(id, buttonState) |\n              this.handleTouch(id, buttonState) |\n              this.handleValue(id, buttonState);\n    if (!changed) { return false; }\n    this.el.emit(EVENTS.BUTTONCHANGED, this.buttonEventDetails[id], false);\n    return true;\n  },\n\n  /**\n   * An axis is an array of values from -1 (up, left) to 1 (down, right).\n   * Compare each component of the axis to the previous value to determine change.\n   *\n   * @returns {boolean} Whether axes changed.\n   */\n  handleAxes: function () {\n    var changed = false;\n    var controllerAxes = this.controller.axes;\n    var i;\n    var previousAxis = this.axis;\n    var changedAxes = this.changedAxes;\n\n    // Check if axis changed.\n    this.changedAxes.length = 0;\n    for (i = 0; i < controllerAxes.length; ++i) {\n      changedAxes.push(previousAxis[i] !== controllerAxes[i]);\n      if (changedAxes[i]) { changed = true; }\n    }\n    if (!changed) { return false; }\n\n    this.axis.length = 0;\n    for (i = 0; i < controllerAxes.length; i++) {\n      this.axis.push(controllerAxes[i]);\n    }\n    this.el.emit(EVENTS.AXISMOVE, this.axisMoveEventDetail, false);\n    return true;\n  },\n\n  /**\n   * Determine whether a button press has occured and emit events as appropriate.\n   *\n   * @param {string} id - ID of the button to check.\n   * @param {object} buttonState - State of the button to check.\n   * @returns {boolean} Whether button press state changed.\n   */\n  handlePress: function (id, buttonState) {\n    var evtName;\n    var previousButtonState = this.buttonStates[id];\n\n    // Not changed.\n    if (buttonState.pressed === previousButtonState.pressed) { return false; }\n\n    evtName = buttonState.pressed ? EVENTS.BUTTONDOWN : EVENTS.BUTTONUP;\n    this.el.emit(evtName, this.buttonEventDetails[id], false);\n    previousButtonState.pressed = buttonState.pressed;\n    return true;\n  },\n\n  /**\n   * Determine whether a button touch has occured and emit events as appropriate.\n   *\n   * @param {string} id - ID of the button to check.\n   * @param {object} buttonState - State of the button to check.\n   * @returns {boolean} Whether button touch state changed.\n   */\n  handleTouch: function (id, buttonState) {\n    var evtName;\n    var previousButtonState = this.buttonStates[id];\n\n    // Not changed.\n    if (buttonState.touched === previousButtonState.touched) { return false; }\n\n    evtName = buttonState.touched ? EVENTS.TOUCHSTART : EVENTS.TOUCHEND;\n    this.el.emit(evtName, this.buttonEventDetails[id], false, EMPTY_DAYDREAM_TOUCHES);\n    previousButtonState.touched = buttonState.touched;\n    return true;\n  },\n\n  /**\n   * Determine whether a button value has changed.\n   *\n   * @param {string} id - Id of the button to check.\n   * @param {object} buttonState - State of the button to check.\n   * @returns {boolean} Whether button value changed.\n   */\n  handleValue: function (id, buttonState) {\n    var previousButtonState = this.buttonStates[id];\n\n    // Not changed.\n    if (buttonState.value === previousButtonState.value) { return false; }\n\n    previousButtonState.value = buttonState.value;\n    return true;\n  }\n});\n"]},"metadata":{},"sourceType":"script"}