{"ast":null,"code":"var newline = /\\n/;\nvar newlineChar = '\\n';\nvar whitespace = /\\s/;\n\nmodule.exports = function (text, opt) {\n  var lines = module.exports.lines(text, opt);\n  return lines.map(function (line) {\n    return text.substring(line.start, line.end);\n  }).join('\\n');\n};\n\nmodule.exports.lines = function wordwrap(text, opt) {\n  opt = opt || {}; //zero width results in nothing visible\n\n  if (opt.width === 0 && opt.mode !== 'nowrap') return [];\n  text = text || '';\n  var width = typeof opt.width === 'number' ? opt.width : Number.MAX_VALUE;\n  var start = Math.max(0, opt.start || 0);\n  var end = typeof opt.end === 'number' ? opt.end : text.length;\n  var mode = opt.mode;\n  var measure = opt.measure || monospace;\n  if (mode === 'pre') return pre(measure, text, start, end, width);else return greedy(measure, text, start, end, width, mode);\n};\n\nfunction idxOf(text, chr, start, end) {\n  var idx = text.indexOf(chr, start);\n  if (idx === -1 || idx > end) return end;\n  return idx;\n}\n\nfunction isWhitespace(chr) {\n  return whitespace.test(chr);\n}\n\nfunction pre(measure, text, start, end, width) {\n  var lines = [];\n  var lineStart = start;\n\n  for (var i = start; i < end && i < text.length; i++) {\n    var chr = text.charAt(i);\n    var isNewline = newline.test(chr); //If we've reached a newline, then step down a line\n    //Or if we've reached the EOF\n\n    if (isNewline || i === end - 1) {\n      var lineEnd = isNewline ? i : i + 1;\n      var measured = measure(text, lineStart, lineEnd, width);\n      lines.push(measured);\n      lineStart = i + 1;\n    }\n  }\n\n  return lines;\n}\n\nfunction greedy(measure, text, start, end, width, mode) {\n  //A greedy word wrapper based on LibGDX algorithm\n  //https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFontCache.java\n  var lines = [];\n  var testWidth = width; //if 'nowrap' is specified, we only wrap on newline chars\n\n  if (mode === 'nowrap') testWidth = Number.MAX_VALUE;\n\n  while (start < end && start < text.length) {\n    //get next newline position\n    var newLine = idxOf(text, newlineChar, start, end); //eat whitespace at start of line\n\n    while (start < newLine) {\n      if (!isWhitespace(text.charAt(start))) break;\n      start++;\n    } //determine visible # of glyphs for the available width\n\n\n    var measured = measure(text, start, newLine, testWidth);\n    var lineEnd = start + (measured.end - measured.start);\n    var nextStart = lineEnd + newlineChar.length; //if we had to cut the line before the next newline...\n\n    if (lineEnd < newLine) {\n      //find char to break on\n      while (lineEnd > start) {\n        if (isWhitespace(text.charAt(lineEnd))) break;\n        lineEnd--;\n      }\n\n      if (lineEnd === start) {\n        if (nextStart > start + newlineChar.length) nextStart--;\n        lineEnd = nextStart; // If no characters to break, show all.\n      } else {\n        nextStart = lineEnd; //eat whitespace at end of line\n\n        while (lineEnd > start) {\n          if (!isWhitespace(text.charAt(lineEnd - newlineChar.length))) break;\n          lineEnd--;\n        }\n      }\n    }\n\n    if (lineEnd >= start) {\n      var result = measure(text, start, lineEnd, testWidth);\n      lines.push(result);\n    }\n\n    start = nextStart;\n  }\n\n  return lines;\n} //determines the visible number of glyphs within a given width\n\n\nfunction monospace(text, start, end, width) {\n  var glyphs = Math.min(width, end - start);\n  return {\n    start: start,\n    end: start + glyphs\n  };\n}","map":{"version":3,"sources":["C:/Users/Hannuri/Desktop/RoyalCyber/my-first-app/node_modules/word-wrapper/index.js"],"names":["newline","newlineChar","whitespace","module","exports","text","opt","lines","map","line","substring","start","end","join","wordwrap","width","mode","Number","MAX_VALUE","Math","max","length","measure","monospace","pre","greedy","idxOf","chr","idx","indexOf","isWhitespace","test","lineStart","i","charAt","isNewline","lineEnd","measured","push","testWidth","newLine","nextStart","result","glyphs","min"],"mappings":"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","sourcesContent":["var newline = /\\n/\nvar newlineChar = '\\n'\nvar whitespace = /\\s/\n\nmodule.exports = function(text, opt) {\n    var lines = module.exports.lines(text, opt)\n    return lines.map(function(line) {\n        return text.substring(line.start, line.end)\n    }).join('\\n')\n}\n\nmodule.exports.lines = function wordwrap(text, opt) {\n    opt = opt||{}\n\n    //zero width results in nothing visible\n    if (opt.width === 0 && opt.mode !== 'nowrap') \n        return []\n\n    text = text||''\n    var width = typeof opt.width === 'number' ? opt.width : Number.MAX_VALUE\n    var start = Math.max(0, opt.start||0)\n    var end = typeof opt.end === 'number' ? opt.end : text.length\n    var mode = opt.mode\n\n    var measure = opt.measure || monospace\n    if (mode === 'pre')\n        return pre(measure, text, start, end, width)\n    else\n        return greedy(measure, text, start, end, width, mode)\n}\n\nfunction idxOf(text, chr, start, end) {\n    var idx = text.indexOf(chr, start)\n    if (idx === -1 || idx > end)\n        return end\n    return idx\n}\n\nfunction isWhitespace(chr) {\n    return whitespace.test(chr)\n}\n\nfunction pre(measure, text, start, end, width) {\n    var lines = []\n    var lineStart = start\n    for (var i=start; i<end && i<text.length; i++) {\n        var chr = text.charAt(i)\n        var isNewline = newline.test(chr)\n\n        //If we've reached a newline, then step down a line\n        //Or if we've reached the EOF\n        if (isNewline || i===end-1) {\n            var lineEnd = isNewline ? i : i+1\n            var measured = measure(text, lineStart, lineEnd, width)\n            lines.push(measured)\n            \n            lineStart = i+1\n        }\n    }\n    return lines\n}\n\nfunction greedy(measure, text, start, end, width, mode) {\n    //A greedy word wrapper based on LibGDX algorithm\n    //https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFontCache.java\n    var lines = []\n\n    var testWidth = width\n    //if 'nowrap' is specified, we only wrap on newline chars\n    if (mode === 'nowrap')\n        testWidth = Number.MAX_VALUE\n\n    while (start < end && start < text.length) {\n        //get next newline position\n        var newLine = idxOf(text, newlineChar, start, end)\n\n        //eat whitespace at start of line\n        while (start < newLine) {\n            if (!isWhitespace( text.charAt(start) ))\n                break\n            start++\n        }\n\n        //determine visible # of glyphs for the available width\n        var measured = measure(text, start, newLine, testWidth)\n\n        var lineEnd = start + (measured.end-measured.start)\n        var nextStart = lineEnd + newlineChar.length\n\n        //if we had to cut the line before the next newline...\n        if (lineEnd < newLine) {\n            //find char to break on\n            while (lineEnd > start) {\n                if (isWhitespace(text.charAt(lineEnd)))\n                    break\n                lineEnd--\n            }\n            if (lineEnd === start) {\n                if (nextStart > start + newlineChar.length) nextStart--\n                lineEnd = nextStart // If no characters to break, show all.\n            } else {\n                nextStart = lineEnd\n                //eat whitespace at end of line\n                while (lineEnd > start) {\n                    if (!isWhitespace(text.charAt(lineEnd - newlineChar.length)))\n                        break\n                    lineEnd--\n                }\n            }\n        }\n        if (lineEnd >= start) {\n            var result = measure(text, start, lineEnd, testWidth)\n            lines.push(result)\n        }\n        start = nextStart\n    }\n    return lines\n}\n\n//determines the visible number of glyphs within a given width\nfunction monospace(text, start, end, width) {\n    var glyphs = Math.min(width, end-start)\n    return {\n        start: start,\n        end: start+glyphs\n    }\n}"]},"metadata":{},"sourceType":"script"}