{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Matrix4, Vector2 } from 'three';\nimport { CSS2DRenderer } from 'three/examples/jsm/renderers/CSS2DRenderer.js';\nimport { $needsRender, $onResize, $scene, $tick, toVector3D } from '../model-viewer-base.js';\nimport { Hotspot } from '../three-components/Hotspot.js';\nconst $annotationRenderer = Symbol('annotationRenderer');\nconst $hotspotMap = Symbol('hotspotMap');\nconst $mutationCallback = Symbol('mutationCallback');\nconst $observer = Symbol('observer');\nconst $addHotspot = Symbol('addHotspot');\nconst $removeHotspot = Symbol('removeHotspot'); // Used internally by positionAndNormalFromPoint()\n\nconst pixelPosition = new Vector2();\nconst worldToModel = new Matrix4();\n/**\n * AnnotationMixin implements a declarative API to add hotspots and annotations.\n * Child elements of the <model-viewer> element that have a slot name that\n * begins with \"hotspot\" and data-position and data-normal attributes in\n * the format of the camera-target attribute will be added to the scene and\n * track the specified model coordinates.\n */\n\nexport const AnnotationMixin = ModelViewerElement => {\n  var _a, _b, _c, _d;\n\n  class AnnotationModelViewerElement extends ModelViewerElement {\n    constructor(...args) {\n      super(...args);\n      this[_a] = new CSS2DRenderer();\n      this[_b] = new Map();\n\n      this[_c] = mutations => {\n        mutations.forEach(mutation => {\n          // NOTE: Be wary that in ShadyDOM cases, the MutationRecord\n          // only has addedNodes and removedNodes (and no other details).\n          if (!(mutation instanceof MutationRecord) || mutation.type === 'childList') {\n            mutation.addedNodes.forEach(node => {\n              this[$addHotspot](node);\n            });\n            mutation.removedNodes.forEach(node => {\n              this[$removeHotspot](node);\n            });\n            this[$needsRender]();\n          }\n        });\n      };\n\n      this[_d] = new MutationObserver(this[$mutationCallback]);\n      const shadowRoot = this.shadowRoot;\n      const domElement = this[$annotationRenderer].domElement;\n      domElement.classList.add('annotation-container');\n      shadowRoot.querySelector('.container').appendChild(domElement);\n      domElement.appendChild(shadowRoot.querySelector('.default'));\n    }\n\n    connectedCallback() {\n      super.connectedCallback();\n\n      for (let i = 0; i < this.children.length; ++i) {\n        this[$addHotspot](this.children[i]);\n      }\n\n      const _self = self,\n            ShadyDOM = _self.ShadyDOM;\n\n      if (ShadyDOM == null) {\n        this[$observer].observe(this, {\n          childList: true\n        });\n      } else {\n        this[$observer] = ShadyDOM.observeChildren(this, this[$mutationCallback]);\n      }\n    }\n\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      const _self2 = self,\n            ShadyDOM = _self2.ShadyDOM;\n\n      if (ShadyDOM == null) {\n        this[$observer].disconnect();\n      } else {\n        ShadyDOM.unobserveChildren(this[$observer]);\n      }\n    }\n    /**\n     * Since the data-position and data-normal attributes are not observed, use\n     * this method to move a hotspot. Keep in mind that all hotspots with the\n     * same slot name use a single location and the first definition takes\n     * precedence, until updated with this method.\n     */\n\n\n    updateHotspot(config) {\n      const hotspot = this[$hotspotMap].get(config.name);\n\n      if (hotspot == null) {\n        return;\n      }\n\n      hotspot.updatePosition(config.position);\n      hotspot.updateNormal(config.normal);\n    }\n    /**\n     * This method returns the model position and normal of the point on the\n     * mesh corresponding to the input pixel coordinates given relative to the\n     * model-viewer element. The position and normal are returned as strings in\n     * the format suitable for putting in a hotspot's data-position and\n     * data-normal attributes. If the mesh is not hit, the result is null.\n     */\n\n\n    positionAndNormalFromPoint(pixelX, pixelY) {\n      const scene = this[$scene];\n      const width = scene.width,\n            height = scene.height,\n            model = scene.model;\n      pixelPosition.set(pixelX / width, pixelY / height).multiplyScalar(2).subScalar(1);\n      pixelPosition.y *= -1;\n      const hit = scene.positionAndNormalFromPoint(pixelPosition);\n\n      if (hit == null) {\n        return null;\n      }\n\n      worldToModel.getInverse(model.matrixWorld);\n      const position = toVector3D(hit.position.applyMatrix4(worldToModel));\n      const normal = toVector3D(hit.normal);\n      return {\n        position: position,\n        normal: normal\n      };\n    }\n\n    [(_a = $annotationRenderer, _b = $hotspotMap, _c = $mutationCallback, _d = $observer, $tick)](time, delta) {\n      super[$tick](time, delta);\n      const scene = this[$scene];\n      const camera = scene.getCamera();\n\n      if (scene.isDirty) {\n        scene.model.updateHotspots(camera.position);\n        this[$annotationRenderer].render(scene, camera);\n      }\n    }\n\n    [$onResize](e) {\n      super[$onResize](e);\n      this[$annotationRenderer].setSize(e.width, e.height);\n    }\n\n    [$addHotspot](node) {\n      if (!(node instanceof HTMLElement && node.slot.indexOf('hotspot') === 0)) {\n        return;\n      }\n\n      let hotspot = this[$hotspotMap].get(node.slot);\n\n      if (hotspot != null) {\n        hotspot.increment();\n      } else {\n        hotspot = new Hotspot({\n          name: node.slot,\n          position: node.dataset.position,\n          normal: node.dataset.normal\n        });\n        this[$hotspotMap].set(node.slot, hotspot);\n        this[$scene].model.addHotspot(hotspot);\n      }\n    }\n\n    [$removeHotspot](node) {\n      if (!(node instanceof HTMLElement)) {\n        return;\n      }\n\n      const hotspot = this[$hotspotMap].get(node.slot);\n\n      if (!hotspot) {\n        return;\n      }\n\n      if (hotspot.decrement()) {\n        this[$scene].model.removeHotspot(hotspot);\n        this[$hotspotMap].delete(node.slot);\n        hotspot.dispose();\n      }\n    }\n\n  }\n\n  return AnnotationModelViewerElement;\n};","map":{"version":3,"sources":["../../src/features/annotation.ts"],"names":[],"mappings":"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","sourcesContent":["\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Matrix4, Vector2} from 'three';\nimport {CSS2DRenderer} from 'three/examples/jsm/renderers/CSS2DRenderer.js';\n\nimport ModelViewerElementBase, {$needsRender, $onResize, $scene, $tick, toVector3D, Vector3D} from '../model-viewer-base.js';\nimport {Hotspot, HotspotConfiguration} from '../three-components/Hotspot.js';\nimport {Constructor} from '../utilities.js';\n\nconst $annotationRenderer = Symbol('annotationRenderer');\nconst $hotspotMap = Symbol('hotspotMap');\nconst $mutationCallback = Symbol('mutationCallback');\nconst $observer = Symbol('observer');\nconst $addHotspot = Symbol('addHotspot');\nconst $removeHotspot = Symbol('removeHotspot');\n\n// Used internally by positionAndNormalFromPoint()\nconst pixelPosition = new Vector2();\nconst worldToModel = new Matrix4();\n\nexport declare interface AnnotationInterface {\n  updateHotspot(config: HotspotConfiguration): void;\n  positionAndNormalFromPoint(pixelX: number, pixelY: number):\n      {position: Vector3D, normal: Vector3D}|null\n}\n\n/**\n * AnnotationMixin implements a declarative API to add hotspots and annotations.\n * Child elements of the <model-viewer> element that have a slot name that\n * begins with \"hotspot\" and data-position and data-normal attributes in\n * the format of the camera-target attribute will be added to the scene and\n * track the specified model coordinates.\n */\nexport const AnnotationMixin = <T extends Constructor<ModelViewerElementBase>>(\n    ModelViewerElement: T): Constructor<AnnotationInterface>&T => {\n  class AnnotationModelViewerElement extends ModelViewerElement {\n    private[$annotationRenderer] = new CSS2DRenderer();\n    private[$hotspotMap] = new Map<string, Hotspot>();\n    private[$mutationCallback] = (mutations: Array<unknown>) => {\n      mutations.forEach((mutation) => {\n        // NOTE: Be wary that in ShadyDOM cases, the MutationRecord\n        // only has addedNodes and removedNodes (and no other details).\n        if (!(mutation instanceof MutationRecord) ||\n            mutation.type === 'childList') {\n          (mutation as MutationRecord).addedNodes.forEach((node) => {\n            this[$addHotspot](node);\n          });\n          (mutation as MutationRecord).removedNodes.forEach((node) => {\n            this[$removeHotspot](node);\n          });\n          this[$needsRender]();\n        }\n      });\n    };\n    private[$observer] = new MutationObserver(this[$mutationCallback]);\n\n    constructor(...args: Array<any>) {\n      super(...args);\n\n      const shadowRoot = this.shadowRoot!;\n      const {domElement} = this[$annotationRenderer];\n      domElement.classList.add('annotation-container');\n      shadowRoot.querySelector('.container')!.appendChild(domElement);\n      domElement.appendChild(shadowRoot.querySelector('.default')!);\n    }\n\n    connectedCallback() {\n      super.connectedCallback();\n\n      for (let i = 0; i < this.children.length; ++i) {\n        this[$addHotspot](this.children[i]);\n      }\n\n      const {ShadyDOM} = self as any;\n\n      if (ShadyDOM == null) {\n        this[$observer].observe(this, {childList: true});\n      } else {\n        this[$observer] =\n            ShadyDOM.observeChildren(this, this[$mutationCallback]);\n      }\n    }\n\n    disconnectedCallback() {\n      super.disconnectedCallback();\n\n      const {ShadyDOM} = self as any;\n\n      if (ShadyDOM == null) {\n        this[$observer].disconnect();\n      } else {\n        ShadyDOM.unobserveChildren(this[$observer]);\n      }\n    }\n\n    /**\n     * Since the data-position and data-normal attributes are not observed, use\n     * this method to move a hotspot. Keep in mind that all hotspots with the\n     * same slot name use a single location and the first definition takes\n     * precedence, until updated with this method.\n     */\n    updateHotspot(config: HotspotConfiguration) {\n      const hotspot = this[$hotspotMap].get(config.name);\n\n      if (hotspot == null) {\n        return;\n      }\n\n      hotspot.updatePosition(config.position);\n      hotspot.updateNormal(config.normal);\n    }\n\n    /**\n     * This method returns the model position and normal of the point on the\n     * mesh corresponding to the input pixel coordinates given relative to the\n     * model-viewer element. The position and normal are returned as strings in\n     * the format suitable for putting in a hotspot's data-position and\n     * data-normal attributes. If the mesh is not hit, the result is null.\n     */\n    positionAndNormalFromPoint(pixelX: number, pixelY: number):\n        {position: Vector3D, normal: Vector3D}|null {\n      const scene = this[$scene];\n      const {width, height, model} = scene;\n      pixelPosition.set(pixelX / width, pixelY / height)\n          .multiplyScalar(2)\n          .subScalar(1);\n      pixelPosition.y *= -1;\n\n      const hit = scene.positionAndNormalFromPoint(pixelPosition);\n      if (hit == null) {\n        return null;\n      }\n\n      worldToModel.getInverse(model.matrixWorld);\n      const position = toVector3D(hit.position.applyMatrix4(worldToModel));\n      const normal = toVector3D(hit.normal);\n      return {position: position, normal: normal};\n    }\n\n    [$tick](time: number, delta: number) {\n      super[$tick](time, delta);\n      const scene = this[$scene];\n      const camera = scene.getCamera();\n\n      if (scene.isDirty) {\n        scene.model.updateHotspots(camera.position);\n        this[$annotationRenderer].render(scene, camera);\n      }\n    }\n\n    [$onResize](e: {width: number, height: number}) {\n      super[$onResize](e);\n      this[$annotationRenderer].setSize(e.width, e.height);\n    }\n\n    private[$addHotspot](node: Node) {\n      if (!(node instanceof HTMLElement &&\n            node.slot.indexOf('hotspot') === 0)) {\n        return;\n      }\n\n      let hotspot = this[$hotspotMap].get(node.slot);\n\n      if (hotspot != null) {\n        hotspot.increment();\n      } else {\n        hotspot = new Hotspot({\n          name: node.slot,\n          position: node.dataset.position,\n          normal: node.dataset.normal,\n        });\n        this[$hotspotMap].set(node.slot, hotspot);\n        this[$scene].model.addHotspot(hotspot);\n      }\n    }\n\n    private[$removeHotspot](node: Node) {\n      if (!(node instanceof HTMLElement)) {\n        return;\n      }\n\n      const hotspot = this[$hotspotMap].get(node.slot);\n\n      if (!hotspot) {\n        return;\n      }\n\n      if (hotspot.decrement()) {\n        this[$scene].model.removeHotspot(hotspot);\n        this[$hotspotMap].delete(node.slot);\n        hotspot.dispose();\n      }\n    }\n  }\n\n  return AnnotationModelViewerElement;\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}