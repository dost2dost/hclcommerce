{"ast":null,"code":"/* global CustomEvent */\nvar registerElement = require('./a-register-element').registerElement;\n\nvar isNode = require('./a-register-element').isNode;\n\nvar utils = require('../utils/');\n\nvar warn = utils.debug('core:a-node:warn');\nvar error = utils.debug('core:a-node:error');\n/**\n * Base class for A-Frame that manages loading of objects.\n *\n * Nodes can be modified using mixins.\n * Nodes emit a `loaded` event when they and their children have initialized.\n */\n\nmodule.exports = registerElement('a-node', {\n  prototype: Object.create(window.HTMLElement.prototype, {\n    createdCallback: {\n      value: function () {\n        this.computedMixinStr = '';\n        this.hasLoaded = false;\n        this.isNode = true;\n        this.mixinEls = [];\n      },\n      writable: window.debug\n    },\n    attachedCallback: {\n      value: function () {\n        var mixins;\n        this.sceneEl = this.closestScene();\n\n        if (!this.sceneEl) {\n          warn('You are attempting to attach <' + this.tagName + '> outside of an A-Frame ' + 'scene. Append this element to `<a-scene>` instead.');\n        }\n\n        this.hasLoaded = false;\n        this.emit('nodeready', undefined, false);\n\n        if (!this.isMixin) {\n          mixins = this.getAttribute('mixin');\n\n          if (mixins) {\n            this.updateMixins(mixins);\n          }\n        }\n      },\n      writable: window.debug\n    },\n\n    /**\n     * Handle mixin.\n     */\n    attributeChangedCallback: {\n      value: function (attr, oldVal, newVal) {\n        // Ignore if `<a-node>` code is just updating computed mixin in the DOM.\n        if (newVal === this.computedMixinStr) {\n          return;\n        }\n\n        if (attr === 'mixin' && !this.isMixin) {\n          this.updateMixins(newVal, oldVal);\n        }\n      }\n    },\n\n    /**\n     * Returns the first scene by traversing up the tree starting from and\n     * including receiver element.\n     */\n    closestScene: {\n      value: function closest() {\n        var element = this;\n\n        while (element) {\n          if (element.isScene) {\n            break;\n          }\n\n          element = element.parentElement;\n        }\n\n        return element;\n      }\n    },\n\n    /**\n     * Returns first element matching a selector by traversing up the tree starting\n     * from and including receiver element.\n     *\n     * @param {string} selector - Selector of element to find.\n     */\n    closest: {\n      value: function closest(selector) {\n        var matches = this.matches || this.mozMatchesSelector || this.msMatchesSelector || this.oMatchesSelector || this.webkitMatchesSelector;\n        var element = this;\n\n        while (element) {\n          if (matches.call(element, selector)) {\n            break;\n          }\n\n          element = element.parentElement;\n        }\n\n        return element;\n      }\n    },\n    detachedCallback: {\n      value: function () {\n        this.hasLoaded = false;\n      }\n    },\n\n    /**\n     * Wait for children to load, if any.\n     * Then emit `loaded` event and set `hasLoaded`.\n     */\n    load: {\n      value: function (cb, childFilter) {\n        var children;\n        var childrenLoaded;\n        var self = this;\n\n        if (this.hasLoaded) {\n          return;\n        } // Default to waiting for all nodes.\n\n\n        childFilter = childFilter || isNode; // Wait for children to load (if any), then load.\n\n        children = this.getChildren();\n        childrenLoaded = children.filter(childFilter).map(function (child) {\n          return new Promise(function waitForLoaded(resolve) {\n            if (child.hasLoaded) {\n              return resolve();\n            }\n\n            child.addEventListener('loaded', resolve);\n          });\n        });\n        Promise.all(childrenLoaded).then(function emitLoaded() {\n          self.hasLoaded = true;\n\n          if (cb) {\n            cb();\n          }\n\n          self.emit('loaded', undefined, false);\n        }).catch(function (err) {\n          error('Failure loading node: ', err);\n        });\n      },\n      writable: true\n    },\n    getChildren: {\n      value: function () {\n        return Array.prototype.slice.call(this.children, 0);\n      }\n    },\n\n    /**\n     * Unregister old mixins and listeners.\n     * Register new mixins and listeners.\n     * Registering means to update `this.mixinEls` with listeners.\n     */\n    updateMixins: {\n      value: function () {\n        var newMixinIdArray = [];\n        var oldMixinIdArray = [];\n        var mixinIds = {};\n        return function (newMixins, oldMixins) {\n          var i;\n          var newMixinIds;\n          var oldMixinIds;\n          newMixinIdArray.length = 0;\n          oldMixinIdArray.length = 0;\n          newMixinIds = newMixins ? utils.split(newMixins.trim(), /\\s+/) : newMixinIdArray;\n          oldMixinIds = oldMixins ? utils.split(oldMixins.trim(), /\\s+/) : oldMixinIdArray;\n          mixinIds.newMixinIds = newMixinIds;\n          mixinIds.oldMixinIds = oldMixinIds; // Unregister old mixins.\n\n          for (i = 0; i < oldMixinIds.length; i++) {\n            if (newMixinIds.indexOf(oldMixinIds[i]) === -1) {\n              this.unregisterMixin(oldMixinIds[i]);\n            }\n          } // Register new mixins.\n\n\n          this.computedMixinStr = '';\n          this.mixinEls.length = 0;\n\n          for (i = 0; i < newMixinIds.length; i++) {\n            this.registerMixin(document.getElementById(newMixinIds[i]));\n          } // Update DOM. Keep track of `computedMixinStr` to not recurse back here after\n          // update.\n\n\n          if (this.computedMixinStr) {\n            this.computedMixinStr = this.computedMixinStr.trim();\n            window.HTMLElement.prototype.setAttribute.call(this, 'mixin', this.computedMixinStr);\n          }\n\n          return mixinIds;\n        };\n      }()\n    },\n\n    /**\n     * From mixin ID, add mixin element to `mixinEls`.\n     *\n     * @param {Element} mixinEl\n     */\n    registerMixin: {\n      value: function (mixinEl) {\n        var compositedMixinIds;\n        var i;\n        var mixin;\n\n        if (!mixinEl) {\n          return;\n        } // Register composited mixins (if mixin has mixins).\n\n\n        mixin = mixinEl.getAttribute('mixin');\n\n        if (mixin) {\n          compositedMixinIds = utils.split(mixin.trim(), /\\s+/);\n\n          for (i = 0; i < compositedMixinIds.length; i++) {\n            this.registerMixin(document.getElementById(compositedMixinIds[i]));\n          }\n        } // Register mixin.\n\n\n        this.computedMixinStr = this.computedMixinStr + ' ' + mixinEl.id;\n        this.mixinEls.push(mixinEl);\n      }\n    },\n    setAttribute: {\n      value: function (attr, newValue) {\n        if (attr === 'mixin') {\n          this.updateMixins(newValue);\n        }\n\n        window.HTMLElement.prototype.setAttribute.call(this, attr, newValue);\n      }\n    },\n    unregisterMixin: {\n      value: function (mixinId) {\n        var i;\n        var mixinEls = this.mixinEls;\n        var mixinEl;\n\n        for (i = 0; i < mixinEls.length; ++i) {\n          mixinEl = mixinEls[i];\n\n          if (mixinId === mixinEl.id) {\n            mixinEls.splice(i, 1);\n            break;\n          }\n        }\n      }\n    },\n\n    /**\n     * Emit a DOM event.\n     *\n     * @param {string} name - Name of event.\n     * @param {object} [detail={}] - Custom data to pass as `detail` to the event.\n     * @param {boolean} [bubbles=true] - Whether the event should bubble.\n     * @param {object} [extraData] - Extra data to pass to the event, if any.\n     */\n    emit: {\n      value: function () {\n        var data = {};\n        return function (name, detail, bubbles, extraData) {\n          if (bubbles === undefined) {\n            bubbles = true;\n          }\n\n          data.bubbles = !!bubbles;\n          data.detail = detail; // If extra data is present, we need to create a new object.\n\n          if (extraData) {\n            data = utils.extend({}, extraData, data);\n          }\n\n          this.dispatchEvent(new CustomEvent(name, data));\n        };\n      }(),\n      writable: window.debug\n    }\n  })\n});","map":{"version":3,"sources":["C:/Users/Hannuri/Desktop/RoyalCyber/my-first-app/node_modules/aframe/src/core/a-node.js"],"names":["registerElement","require","isNode","utils","warn","debug","error","module","exports","prototype","Object","create","window","HTMLElement","createdCallback","value","computedMixinStr","hasLoaded","mixinEls","writable","attachedCallback","mixins","sceneEl","closestScene","tagName","emit","undefined","isMixin","getAttribute","updateMixins","attributeChangedCallback","attr","oldVal","newVal","closest","element","isScene","parentElement","selector","matches","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","call","detachedCallback","load","cb","childFilter","children","childrenLoaded","self","getChildren","filter","map","child","Promise","waitForLoaded","resolve","addEventListener","all","then","emitLoaded","catch","err","Array","slice","newMixinIdArray","oldMixinIdArray","mixinIds","newMixins","oldMixins","i","newMixinIds","oldMixinIds","length","split","trim","indexOf","unregisterMixin","registerMixin","document","getElementById","setAttribute","mixinEl","compositedMixinIds","mixin","id","push","newValue","mixinId","splice","data","name","detail","bubbles","extraData","extend","dispatchEvent","CustomEvent"],"mappings":"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","sourcesContent":["/* global CustomEvent */\nvar registerElement = require('./a-register-element').registerElement;\nvar isNode = require('./a-register-element').isNode;\nvar utils = require('../utils/');\n\nvar warn = utils.debug('core:a-node:warn');\nvar error = utils.debug('core:a-node:error');\n\n/**\n * Base class for A-Frame that manages loading of objects.\n *\n * Nodes can be modified using mixins.\n * Nodes emit a `loaded` event when they and their children have initialized.\n */\nmodule.exports = registerElement('a-node', {\n  prototype: Object.create(window.HTMLElement.prototype, {\n    createdCallback: {\n      value: function () {\n        this.computedMixinStr = '';\n        this.hasLoaded = false;\n        this.isNode = true;\n        this.mixinEls = [];\n      },\n      writable: window.debug\n    },\n\n    attachedCallback: {\n      value: function () {\n        var mixins;\n        this.sceneEl = this.closestScene();\n\n        if (!this.sceneEl) {\n          warn('You are attempting to attach <' + this.tagName + '> outside of an A-Frame ' +\n               'scene. Append this element to `<a-scene>` instead.');\n        }\n\n        this.hasLoaded = false;\n        this.emit('nodeready', undefined, false);\n\n        if (!this.isMixin) {\n          mixins = this.getAttribute('mixin');\n          if (mixins) { this.updateMixins(mixins); }\n        }\n      },\n      writable: window.debug\n    },\n\n    /**\n     * Handle mixin.\n     */\n    attributeChangedCallback: {\n      value: function (attr, oldVal, newVal) {\n        // Ignore if `<a-node>` code is just updating computed mixin in the DOM.\n        if (newVal === this.computedMixinStr) { return; }\n\n        if (attr === 'mixin' && !this.isMixin) {\n          this.updateMixins(newVal, oldVal);\n        }\n      }\n    },\n\n   /**\n    * Returns the first scene by traversing up the tree starting from and\n    * including receiver element.\n    */\n    closestScene: {\n      value: function closest () {\n        var element = this;\n        while (element) {\n          if (element.isScene) { break; }\n          element = element.parentElement;\n        }\n        return element;\n      }\n    },\n\n    /**\n     * Returns first element matching a selector by traversing up the tree starting\n     * from and including receiver element.\n     *\n     * @param {string} selector - Selector of element to find.\n     */\n    closest: {\n      value: function closest (selector) {\n        var matches = this.matches || this.mozMatchesSelector ||\n          this.msMatchesSelector || this.oMatchesSelector || this.webkitMatchesSelector;\n        var element = this;\n        while (element) {\n          if (matches.call(element, selector)) { break; }\n          element = element.parentElement;\n        }\n        return element;\n      }\n    },\n\n    detachedCallback: {\n      value: function () {\n        this.hasLoaded = false;\n      }\n    },\n\n    /**\n     * Wait for children to load, if any.\n     * Then emit `loaded` event and set `hasLoaded`.\n     */\n    load: {\n      value: function (cb, childFilter) {\n        var children;\n        var childrenLoaded;\n        var self = this;\n\n        if (this.hasLoaded) { return; }\n\n        // Default to waiting for all nodes.\n        childFilter = childFilter || isNode;\n        // Wait for children to load (if any), then load.\n        children = this.getChildren();\n        childrenLoaded = children.filter(childFilter).map(function (child) {\n          return new Promise(function waitForLoaded (resolve) {\n            if (child.hasLoaded) { return resolve(); }\n            child.addEventListener('loaded', resolve);\n          });\n        });\n\n        Promise.all(childrenLoaded).then(function emitLoaded () {\n          self.hasLoaded = true;\n          if (cb) { cb(); }\n          self.emit('loaded', undefined, false);\n        }).catch(function (err) {\n          error('Failure loading node: ', err);\n        });\n      },\n      writable: true\n    },\n\n    getChildren: {\n      value: function () {\n        return Array.prototype.slice.call(this.children, 0);\n      }\n    },\n\n    /**\n     * Unregister old mixins and listeners.\n     * Register new mixins and listeners.\n     * Registering means to update `this.mixinEls` with listeners.\n     */\n    updateMixins: {\n      value: (function () {\n        var newMixinIdArray = [];\n        var oldMixinIdArray = [];\n        var mixinIds = {};\n\n        return function (newMixins, oldMixins) {\n          var i;\n          var newMixinIds;\n          var oldMixinIds;\n\n          newMixinIdArray.length = 0;\n          oldMixinIdArray.length = 0;\n          newMixinIds = newMixins ? utils.split(newMixins.trim(), /\\s+/) : newMixinIdArray;\n          oldMixinIds = oldMixins ? utils.split(oldMixins.trim(), /\\s+/) : oldMixinIdArray;\n\n          mixinIds.newMixinIds = newMixinIds;\n          mixinIds.oldMixinIds = oldMixinIds;\n\n          // Unregister old mixins.\n          for (i = 0; i < oldMixinIds.length; i++) {\n            if (newMixinIds.indexOf(oldMixinIds[i]) === -1) {\n              this.unregisterMixin(oldMixinIds[i]);\n            }\n          }\n\n          // Register new mixins.\n          this.computedMixinStr = '';\n          this.mixinEls.length = 0;\n          for (i = 0; i < newMixinIds.length; i++) {\n            this.registerMixin(document.getElementById(newMixinIds[i]));\n          }\n\n          // Update DOM. Keep track of `computedMixinStr` to not recurse back here after\n          // update.\n          if (this.computedMixinStr) {\n            this.computedMixinStr = this.computedMixinStr.trim();\n            window.HTMLElement.prototype.setAttribute.call(this, 'mixin',\n                                                           this.computedMixinStr);\n          }\n\n          return mixinIds;\n        };\n      })()\n    },\n\n    /**\n     * From mixin ID, add mixin element to `mixinEls`.\n     *\n     * @param {Element} mixinEl\n     */\n    registerMixin: {\n      value: function (mixinEl) {\n        var compositedMixinIds;\n        var i;\n        var mixin;\n\n        if (!mixinEl) { return; }\n\n        // Register composited mixins (if mixin has mixins).\n        mixin = mixinEl.getAttribute('mixin');\n        if (mixin) {\n          compositedMixinIds = utils.split(mixin.trim(), /\\s+/);\n          for (i = 0; i < compositedMixinIds.length; i++) {\n            this.registerMixin(document.getElementById(compositedMixinIds[i]));\n          }\n        }\n\n        // Register mixin.\n        this.computedMixinStr = this.computedMixinStr + ' ' + mixinEl.id;\n        this.mixinEls.push(mixinEl);\n      }\n    },\n\n    setAttribute: {\n      value: function (attr, newValue) {\n        if (attr === 'mixin') { this.updateMixins(newValue); }\n        window.HTMLElement.prototype.setAttribute.call(this, attr, newValue);\n      }\n    },\n\n    unregisterMixin: {\n      value: function (mixinId) {\n        var i;\n        var mixinEls = this.mixinEls;\n        var mixinEl;\n        for (i = 0; i < mixinEls.length; ++i) {\n          mixinEl = mixinEls[i];\n          if (mixinId === mixinEl.id) {\n            mixinEls.splice(i, 1);\n            break;\n          }\n        }\n      }\n    },\n\n    /**\n     * Emit a DOM event.\n     *\n     * @param {string} name - Name of event.\n     * @param {object} [detail={}] - Custom data to pass as `detail` to the event.\n     * @param {boolean} [bubbles=true] - Whether the event should bubble.\n     * @param {object} [extraData] - Extra data to pass to the event, if any.\n     */\n    emit: {\n      value: (function () {\n        var data = {};\n\n        return function (name, detail, bubbles, extraData) {\n          if (bubbles === undefined) { bubbles = true; }\n          data.bubbles = !!bubbles;\n          data.detail = detail;\n\n          // If extra data is present, we need to create a new object.\n          if (extraData) { data = utils.extend({}, extraData, data); }\n\n          this.dispatchEvent(new CustomEvent(name, data));\n        };\n      })(),\n      writable: window.debug\n    }\n  })\n});\n"]},"metadata":{},"sourceType":"script"}