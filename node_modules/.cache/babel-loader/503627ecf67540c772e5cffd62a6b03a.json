{"ast":null,"code":"/* @license\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n\nimport { Euler, EventDispatcher, Spherical } from 'three';\nimport { clamp } from '../utilities.js';\nimport { Damper, SETTLING_TIME } from './Damper.js';\nexport const DEFAULT_OPTIONS = Object.freeze({\n  minimumRadius: 0,\n  maximumRadius: Infinity,\n  minimumPolarAngle: Math.PI / 8,\n  maximumPolarAngle: Math.PI - Math.PI / 8,\n  minimumAzimuthalAngle: -Infinity,\n  maximumAzimuthalAngle: Infinity,\n  minimumFieldOfView: 10,\n  maximumFieldOfView: 45,\n  eventHandlingBehavior: 'prevent-all',\n  interactionPolicy: 'always-allow'\n}); // Internal orbital position state\n\nconst $spherical = Symbol('spherical');\nconst $goalSpherical = Symbol('goalSpherical');\nconst $thetaDamper = Symbol('thetaDamper');\nconst $phiDamper = Symbol('phiDamper');\nconst $radiusDamper = Symbol('radiusDamper');\nconst $logFov = Symbol('fov');\nconst $goalLogFov = Symbol('goalLogFov');\nconst $fovDamper = Symbol('fovDamper');\nconst $options = Symbol('options');\nconst $touchMode = Symbol('touchMode');\nconst $canInteract = Symbol('canInteract');\nconst $interactionEnabled = Symbol('interactionEnabled');\nconst $userAdjustOrbit = Symbol('userAdjustOrbit');\nconst $isUserChange = Symbol('isUserChange');\nconst $isStationary = Symbol('isMoving');\nconst $moveCamera = Symbol('moveCamera');\nconst $isUserPointing = Symbol('isUserPointing'); // Pointer state\n\nconst $pointerIsDown = Symbol('pointerIsDown');\nconst $lastPointerPosition = Symbol('lastPointerPosition');\nconst $lastTouches = Symbol('lastTouches'); // Value conversion methods\n\nconst $pixelLengthToSphericalAngle = Symbol('pixelLengthToSphericalAngle');\nconst $twoTouchDistance = Symbol('twoTouchDistance');\nconst $wrapAngle = Symbol('wrapAngle'); // Event handlers\n\nconst $onMouseMove = Symbol('onMouseMove');\nconst $onMouseDown = Symbol('onMouseDown');\nconst $onMouseUp = Symbol('onMouseUp');\nconst $onTouchStart = Symbol('onTouchStart');\nconst $onTouchEnd = Symbol('onTouchEnd');\nconst $onTouchMove = Symbol('onTouchMove');\nconst $onWheel = Symbol('onWheel');\nconst $onKeyDown = Symbol('onKeyDown');\nconst $handlePointerMove = Symbol('handlePointerMove');\nconst $handleSinglePointerMove = Symbol('handleSinglePointerMove');\nconst $handlePointerDown = Symbol('handlePointerDown');\nconst $handleSinglePointerDown = Symbol('handleSinglePointerDown');\nconst $handlePointerUp = Symbol('handlePointerUp');\nconst $handleWheel = Symbol('handleWheel');\nconst $handleKey = Symbol('handleKey'); // Constants\n\nconst TOUCH_EVENT_RE = /^touch(start|end|move)$/;\nconst KEYBOARD_ORBIT_INCREMENT = Math.PI / 8;\nconst ZOOM_SENSITIVITY = 0.04;\nexport const KeyCode = {\n  PAGE_UP: 33,\n  PAGE_DOWN: 34,\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40\n};\nexport const ChangeSource = {\n  USER_INTERACTION: 'user-interaction',\n  NONE: 'none'\n};\n/**\n * SmoothControls is a Three.js helper for adding delightful pointer and\n * keyboard-based input to a staged Three.js scene. Its API is very similar to\n * OrbitControls, but it offers more opinionated (subjectively more delightful)\n * defaults, easy extensibility and subjectively better out-of-the-box keyboard\n * support.\n *\n * One important change compared to OrbitControls is that the `update` method\n * of SmoothControls must be invoked on every frame, otherwise the controls\n * will not have an effect.\n *\n * Another notable difference compared to OrbitControls is that SmoothControls\n * does not currently support panning (but probably will in a future revision).\n *\n * Like OrbitControls, SmoothControls assumes that the orientation of the camera\n * has been set in terms of position, rotation and scale, so it is important to\n * ensure that the camera's matrixWorld is in sync before using SmoothControls.\n */\n\nexport class SmoothControls extends EventDispatcher {\n  constructor(camera, element) {\n    super();\n    this.camera = camera;\n    this.element = element;\n    this[_a] = false;\n    this[_b] = false;\n    this[_c] = false;\n    this[_d] = new Spherical();\n    this[_e] = new Spherical();\n    this[_f] = new Damper();\n    this[_g] = new Damper();\n    this[_h] = new Damper();\n    this[_j] = new Damper();\n    this[_k] = false;\n    this[_l] = {\n      clientX: 0,\n      clientY: 0\n    };\n\n    this[$onMouseMove] = event => this[$handlePointerMove](event);\n\n    this[$onMouseDown] = event => this[$handlePointerDown](event);\n\n    this[$onMouseUp] = event => this[$handlePointerUp](event);\n\n    this[$onWheel] = event => this[$handleWheel](event);\n\n    this[$onKeyDown] = event => this[$handleKey](event);\n\n    this[$onTouchStart] = event => this[$handlePointerDown](event);\n\n    this[$onTouchEnd] = event => this[$handlePointerUp](event);\n\n    this[$onTouchMove] = event => this[$handlePointerMove](event);\n\n    this[$options] = Object.assign({}, DEFAULT_OPTIONS);\n    this.setOrbit(0, Math.PI / 2, 1);\n    this.setFieldOfView(100);\n    this.jumpToGoal();\n  }\n\n  get interactionEnabled() {\n    return this[$interactionEnabled];\n  }\n\n  enableInteraction() {\n    if (this[$interactionEnabled] === false) {\n      const element = this.element;\n      element.addEventListener('mousemove', this[$onMouseMove]);\n      element.addEventListener('mousedown', this[$onMouseDown]);\n      element.addEventListener('wheel', this[$onWheel]);\n      element.addEventListener('keydown', this[$onKeyDown]);\n      element.addEventListener('touchstart', this[$onTouchStart]);\n      element.addEventListener('touchmove', this[$onTouchMove]);\n      self.addEventListener('mouseup', this[$onMouseUp]);\n      self.addEventListener('touchend', this[$onTouchEnd]);\n      this.element.style.cursor = 'grab';\n      this[$interactionEnabled] = true;\n    }\n  }\n\n  disableInteraction() {\n    if (this[$interactionEnabled] === true) {\n      const element = this.element;\n      element.removeEventListener('mousemove', this[$onMouseMove]);\n      element.removeEventListener('mousedown', this[$onMouseDown]);\n      element.removeEventListener('wheel', this[$onWheel]);\n      element.removeEventListener('keydown', this[$onKeyDown]);\n      element.removeEventListener('touchstart', this[$onTouchStart]);\n      element.removeEventListener('touchmove', this[$onTouchMove]);\n      self.removeEventListener('mouseup', this[$onMouseUp]);\n      self.removeEventListener('touchend', this[$onTouchEnd]);\n      element.style.cursor = '';\n      this[$interactionEnabled] = false;\n    }\n  }\n  /**\n   * The options that are currently configured for the controls instance.\n   */\n\n\n  get options() {\n    return this[$options];\n  }\n  /**\n   * Copy the spherical values that represent the current camera orbital\n   * position relative to the configured target into a provided Spherical\n   * instance. If no Spherical is provided, a new Spherical will be allocated\n   * to copy the values into. The Spherical that values are copied into is\n   * returned.\n   */\n\n\n  getCameraSpherical(target = new Spherical()) {\n    return target.copy(this[$spherical]);\n  }\n  /**\n   * Returns the camera's current vertical field of view in degrees.\n   */\n\n\n  getFieldOfView() {\n    return this.camera.fov;\n  }\n  /**\n   * Configure the options of the controls. Configured options will be\n   * merged with whatever options have already been configured for this\n   * controls instance.\n   */\n\n\n  applyOptions(options) {\n    Object.assign(this[$options], options); // Re-evaluates clamping based on potentially new values for min/max\n    // polar, azimuth and radius:\n\n    this.setOrbit();\n    this.setFieldOfView(Math.exp(this[$goalLogFov]));\n  }\n  /**\n   * Sets the near and far planes of the camera.\n   */\n\n\n  updateNearFar(nearPlane, farPlane) {\n    this.camera.near = Math.max(nearPlane, farPlane / 1000);\n    this.camera.far = farPlane;\n    this.camera.updateProjectionMatrix();\n  }\n  /**\n   * Sets the aspect ratio of the camera\n   */\n\n\n  updateAspect(aspect) {\n    this.camera.aspect = aspect;\n    this.camera.updateProjectionMatrix();\n  }\n  /**\n   * Set the absolute orbital goal of the camera. The change will be\n   * applied over a number of frames depending on configured acceleration and\n   * dampening options.\n   *\n   * Returns true if invoking the method will result in the camera changing\n   * position and/or rotation, otherwise false.\n   */\n\n\n  setOrbit(goalTheta = this[$goalSpherical].theta, goalPhi = this[$goalSpherical].phi, goalRadius = this[$goalSpherical].radius) {\n    const _this$$options = this[$options],\n          minimumAzimuthalAngle = _this$$options.minimumAzimuthalAngle,\n          maximumAzimuthalAngle = _this$$options.maximumAzimuthalAngle,\n          minimumPolarAngle = _this$$options.minimumPolarAngle,\n          maximumPolarAngle = _this$$options.maximumPolarAngle,\n          minimumRadius = _this$$options.minimumRadius,\n          maximumRadius = _this$$options.maximumRadius;\n    const _this$$goalSpherical = this[$goalSpherical],\n          theta = _this$$goalSpherical.theta,\n          phi = _this$$goalSpherical.phi,\n          radius = _this$$goalSpherical.radius;\n    const nextTheta = clamp(goalTheta, minimumAzimuthalAngle, maximumAzimuthalAngle);\n\n    if (!isFinite(minimumAzimuthalAngle) && !isFinite(maximumAzimuthalAngle)) {\n      this[$spherical].theta = this[$wrapAngle](this[$spherical].theta - nextTheta) + nextTheta;\n    }\n\n    const nextPhi = clamp(goalPhi, minimumPolarAngle, maximumPolarAngle);\n    const nextRadius = clamp(goalRadius, minimumRadius, maximumRadius);\n\n    if (nextTheta === theta && nextPhi === phi && nextRadius === radius) {\n      return false;\n    }\n\n    this[$goalSpherical].theta = nextTheta;\n    this[$goalSpherical].phi = nextPhi;\n    this[$goalSpherical].radius = nextRadius;\n    this[$goalSpherical].makeSafe();\n    this[$isUserChange] = false;\n    return true;\n  }\n  /**\n   * Subset of setOrbit() above, which only sets the camera's radius.\n   */\n\n\n  setRadius(radius) {\n    this[$goalSpherical].radius = radius;\n    this.setOrbit();\n  }\n  /**\n   * Sets the goal field of view for the camera\n   */\n\n\n  setFieldOfView(fov) {\n    const _this$$options2 = this[$options],\n          minimumFieldOfView = _this$$options2.minimumFieldOfView,\n          maximumFieldOfView = _this$$options2.maximumFieldOfView;\n    fov = clamp(fov, minimumFieldOfView, maximumFieldOfView);\n    this[$goalLogFov] = Math.log(fov);\n  }\n  /**\n   * Adjust the orbital position of the camera relative to its current orbital\n   * position. Does not let the theta goal get more than pi ahead of the current\n   * theta, which ensures interpolation continues in the direction of the delta.\n   * The deltaZoom parameter adjusts both the field of view and the orbit radius\n   * such that they progress across their allowed ranges in sync.\n   */\n\n\n  adjustOrbit(deltaTheta, deltaPhi, deltaZoom) {\n    const _this$$goalSpherical2 = this[$goalSpherical],\n          theta = _this$$goalSpherical2.theta,\n          phi = _this$$goalSpherical2.phi,\n          radius = _this$$goalSpherical2.radius;\n    const _this$$options3 = this[$options],\n          minimumRadius = _this$$options3.minimumRadius,\n          maximumRadius = _this$$options3.maximumRadius,\n          minimumFieldOfView = _this$$options3.minimumFieldOfView,\n          maximumFieldOfView = _this$$options3.maximumFieldOfView;\n    const dTheta = this[$spherical].theta - theta;\n    const dThetaLimit = Math.PI - 0.001;\n    const goalTheta = theta - clamp(deltaTheta, -dThetaLimit - dTheta, dThetaLimit - dTheta);\n    const goalPhi = phi - deltaPhi;\n    const deltaRatio = deltaZoom === 0 ? 0 : deltaZoom > 0 ? (maximumRadius - radius) / (Math.log(maximumFieldOfView) - this[$goalLogFov]) : (radius - minimumRadius) / (this[$goalLogFov] - Math.log(minimumFieldOfView));\n    const goalRadius = radius + deltaZoom * Math.min(isFinite(deltaRatio) ? deltaRatio : Infinity, maximumRadius - minimumRadius);\n    let handled = this.setOrbit(goalTheta, goalPhi, goalRadius);\n\n    if (deltaZoom !== 0) {\n      const goalLogFov = this[$goalLogFov] + deltaZoom;\n      this.setFieldOfView(Math.exp(goalLogFov));\n      handled = true;\n    }\n\n    return handled;\n  }\n  /**\n   * Move the camera instantly instead of accelerating toward the goal\n   * parameters.\n   */\n\n\n  jumpToGoal() {\n    this.update(0, SETTLING_TIME);\n  }\n  /**\n   * Update controls. In most cases, this will result in the camera\n   * interpolating its position and rotation until it lines up with the\n   * designated goal orbital position.\n   *\n   * Time and delta are measured in milliseconds.\n   */\n\n\n  update(_time, delta) {\n    if (this[$isStationary]()) {\n      return;\n    }\n\n    const _this$$options4 = this[$options],\n          maximumPolarAngle = _this$$options4.maximumPolarAngle,\n          maximumRadius = _this$$options4.maximumRadius;\n    const dTheta = this[$spherical].theta - this[$goalSpherical].theta;\n\n    if (Math.abs(dTheta) > Math.PI && !isFinite(this[$options].minimumAzimuthalAngle) && !isFinite(this[$options].maximumAzimuthalAngle)) {\n      this[$spherical].theta -= Math.sign(dTheta) * 2 * Math.PI;\n    }\n\n    this[$spherical].theta = this[$thetaDamper].update(this[$spherical].theta, this[$goalSpherical].theta, delta, Math.PI);\n    this[$spherical].phi = this[$phiDamper].update(this[$spherical].phi, this[$goalSpherical].phi, delta, maximumPolarAngle);\n    this[$spherical].radius = this[$radiusDamper].update(this[$spherical].radius, this[$goalSpherical].radius, delta, maximumRadius);\n    this[$logFov] = this[$fovDamper].update(this[$logFov], this[$goalLogFov], delta, 1);\n    this[$moveCamera]();\n  }\n\n  [(_a = $interactionEnabled, _b = $isUserChange, _c = $isUserPointing, _d = $spherical, _e = $goalSpherical, _f = $thetaDamper, _g = $phiDamper, _h = $radiusDamper, _j = $fovDamper, _k = $pointerIsDown, _l = $lastPointerPosition, $isStationary)]() {\n    return this[$goalSpherical].theta === this[$spherical].theta && this[$goalSpherical].phi === this[$spherical].phi && this[$goalSpherical].radius === this[$spherical].radius && this[$goalLogFov] === this[$logFov];\n  }\n\n  [$moveCamera]() {\n    // Derive the new camera position from the updated spherical:\n    this[$spherical].makeSafe();\n    this.camera.position.setFromSpherical(this[$spherical]);\n    this.camera.setRotationFromEuler(new Euler(this[$spherical].phi - Math.PI / 2, this[$spherical].theta, 0, 'YXZ'));\n\n    if (this.camera.fov !== Math.exp(this[$logFov])) {\n      this.camera.fov = Math.exp(this[$logFov]);\n      this.camera.updateProjectionMatrix();\n    }\n\n    const source = this[$isUserChange] ? ChangeSource.USER_INTERACTION : ChangeSource.NONE;\n    this.dispatchEvent({\n      type: 'change',\n      source\n    });\n  }\n\n  get [$canInteract]() {\n    if (this[$options].interactionPolicy == 'allow-when-focused') {\n      const rootNode = this.element.getRootNode();\n      return rootNode.activeElement === this.element;\n    }\n\n    return this[$options].interactionPolicy === 'always-allow';\n  }\n\n  [$userAdjustOrbit](deltaTheta, deltaPhi, deltaZoom) {\n    const handled = this.adjustOrbit(deltaTheta, deltaPhi, deltaZoom);\n    this[$isUserChange] = true; // Always make sure that an initial event is triggered in case there is\n    // contention between user interaction and imperative changes. This initial\n    // event will give external observers that chance to observe that\n    // interaction occurred at all:\n\n    this.dispatchEvent({\n      type: 'change',\n      source: ChangeSource.USER_INTERACTION\n    });\n    return handled;\n  } // Wraps to bewteen -pi and pi\n\n\n  [$wrapAngle](radians) {\n    const normalized = (radians + Math.PI) / (2 * Math.PI);\n    const wrapped = normalized - Math.floor(normalized);\n    return wrapped * 2 * Math.PI - Math.PI;\n  }\n\n  [$pixelLengthToSphericalAngle](pixelLength) {\n    return 2 * Math.PI * pixelLength / this.element.clientHeight;\n  }\n\n  [$twoTouchDistance](touchOne, touchTwo) {\n    const xOne = touchOne.clientX,\n          yOne = touchOne.clientY;\n    const xTwo = touchTwo.clientX,\n          yTwo = touchTwo.clientY;\n    const xDelta = xTwo - xOne;\n    const yDelta = yTwo - yOne;\n    return Math.sqrt(xDelta * xDelta + yDelta * yDelta);\n  }\n\n  [$handlePointerMove](event) {\n    if (!this[$pointerIsDown] || !this[$canInteract]) {\n      return;\n    }\n\n    let handled = false; // NOTE(cdata): We test event.type as some browsers do not have a global\n    // TouchEvent contructor.\n\n    if (TOUCH_EVENT_RE.test(event.type)) {\n      const touches = event.touches;\n\n      switch (this[$touchMode]) {\n        case 'zoom':\n          if (this[$lastTouches].length > 1 && touches.length > 1) {\n            const lastTouchDistance = this[$twoTouchDistance](this[$lastTouches][0], this[$lastTouches][1]);\n            const touchDistance = this[$twoTouchDistance](touches[0], touches[1]);\n            const deltaZoom = ZOOM_SENSITIVITY * (lastTouchDistance - touchDistance) / 10.0;\n            handled = this[$userAdjustOrbit](0, 0, deltaZoom);\n          }\n\n          break;\n\n        case 'rotate':\n          handled = this[$handleSinglePointerMove](touches[0]);\n          break;\n      }\n\n      this[$lastTouches] = touches;\n    } else {\n      handled = this[$handleSinglePointerMove](event);\n    }\n\n    if ((handled || this[$options].eventHandlingBehavior === 'prevent-all') && event.cancelable) {\n      event.preventDefault();\n    }\n\n    ;\n  }\n\n  [$handleSinglePointerMove](pointer) {\n    const clientX = pointer.clientX,\n          clientY = pointer.clientY;\n    const deltaTheta = this[$pixelLengthToSphericalAngle](clientX - this[$lastPointerPosition].clientX);\n    const deltaPhi = this[$pixelLengthToSphericalAngle](clientY - this[$lastPointerPosition].clientY);\n    this[$lastPointerPosition].clientX = clientX;\n    this[$lastPointerPosition].clientY = clientY;\n\n    if (this[$isUserPointing] === false) {\n      this[$isUserPointing] = true;\n      this.dispatchEvent({\n        type: 'pointer-change-start',\n        pointer: Object.assign({}, pointer)\n      });\n    }\n\n    return this[$userAdjustOrbit](deltaTheta, deltaPhi, 0);\n  }\n\n  [$handlePointerDown](event) {\n    this[$pointerIsDown] = true;\n    this[$isUserPointing] = false;\n\n    if (TOUCH_EVENT_RE.test(event.type)) {\n      const touches = event.touches;\n\n      switch (touches.length) {\n        default:\n        case 1:\n          this[$touchMode] = 'rotate';\n          this[$handleSinglePointerDown](touches[0]);\n          break;\n\n        case 2:\n          this[$touchMode] = 'zoom';\n          break;\n      }\n\n      this[$lastTouches] = touches;\n    } else {\n      this[$handleSinglePointerDown](event);\n    }\n  }\n\n  [$handleSinglePointerDown](pointer) {\n    this[$lastPointerPosition].clientX = pointer.clientX;\n    this[$lastPointerPosition].clientY = pointer.clientY;\n    this.element.style.cursor = 'grabbing';\n  }\n\n  [$handlePointerUp](_event) {\n    this.element.style.cursor = 'grab';\n    this[$pointerIsDown] = false;\n\n    if (this[$isUserPointing]) {\n      this.dispatchEvent({\n        type: 'pointer-change-end',\n        pointer: Object.assign({}, this[$lastPointerPosition])\n      });\n    }\n  }\n\n  [$handleWheel](event) {\n    if (!this[$canInteract]) {\n      return;\n    }\n\n    const deltaZoom = event.deltaY * ZOOM_SENSITIVITY / 30;\n\n    if ((this[$userAdjustOrbit](0, 0, deltaZoom) || this[$options].eventHandlingBehavior === 'prevent-all') && event.cancelable) {\n      event.preventDefault();\n    }\n  }\n\n  [$handleKey](event) {\n    // We track if the key is actually one we respond to, so as not to\n    // accidentally clober unrelated key inputs when the <model-viewer> has\n    // focus and eventHandlingBehavior is set to 'prevent-all'.\n    let relevantKey = false;\n    let handled = false;\n\n    switch (event.keyCode) {\n      case KeyCode.PAGE_UP:\n        relevantKey = true;\n        handled = this[$userAdjustOrbit](0, 0, ZOOM_SENSITIVITY);\n        break;\n\n      case KeyCode.PAGE_DOWN:\n        relevantKey = true;\n        handled = this[$userAdjustOrbit](0, 0, -1 * ZOOM_SENSITIVITY);\n        break;\n\n      case KeyCode.UP:\n        relevantKey = true;\n        handled = this[$userAdjustOrbit](0, -KEYBOARD_ORBIT_INCREMENT, 0);\n        break;\n\n      case KeyCode.DOWN:\n        relevantKey = true;\n        handled = this[$userAdjustOrbit](0, KEYBOARD_ORBIT_INCREMENT, 0);\n        break;\n\n      case KeyCode.LEFT:\n        relevantKey = true;\n        handled = this[$userAdjustOrbit](-KEYBOARD_ORBIT_INCREMENT, 0, 0);\n        break;\n\n      case KeyCode.RIGHT:\n        relevantKey = true;\n        handled = this[$userAdjustOrbit](KEYBOARD_ORBIT_INCREMENT, 0, 0);\n        break;\n    }\n\n    if (relevantKey && (handled || this[$options].eventHandlingBehavior === 'prevent-all') && event.cancelable) {\n      event.preventDefault();\n    }\n  }\n\n}","map":{"version":3,"sources":["../../src/three-components/SmoothControls.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Euler, Event as ThreeEvent, EventDispatcher, PerspectiveCamera, Spherical} from 'three';\n\nimport {clamp} from '../utilities.js';\nimport {Damper, SETTLING_TIME} from './Damper.js';\n\nexport type EventHandlingBehavior = 'prevent-all'|'prevent-handled';\nexport type InteractionPolicy = 'always-allow'|'allow-when-focused';\nexport type TouchMode = 'rotate'|'zoom';\n\nexport interface Pointer {\n  clientX: number, clientY: number,\n}\n\nexport interface SmoothControlsOptions {\n  // The closest the camera can be to the target\n  minimumRadius?: number;\n  // The farthest the camera can be from the target\n  maximumRadius?: number;\n  // The minimum angle between model-up and the camera polar position\n  minimumPolarAngle?: number;\n  // The maximum angle between model-up and the camera polar position\n  maximumPolarAngle?: number;\n  // The minimum angle between model-forward and the camera azimuthal position\n  minimumAzimuthalAngle?: number;\n  // The maximum angle between model-forward and the camera azimuthal position\n  maximumAzimuthalAngle?: number;\n  // The minimum camera field of view in degrees\n  minimumFieldOfView?: number;\n  // The maximum camera field of view in degrees\n  maximumFieldOfView?: number;\n  // Controls when events will be cancelled (always, or only when handled)\n  eventHandlingBehavior?: EventHandlingBehavior;\n  // Controls when interaction is allowed (always, or only when focused)\n  interactionPolicy?: InteractionPolicy;\n}\n\nexport const DEFAULT_OPTIONS = Object.freeze<SmoothControlsOptions>({\n  minimumRadius: 0,\n  maximumRadius: Infinity,\n  minimumPolarAngle: Math.PI / 8,\n  maximumPolarAngle: Math.PI - Math.PI / 8,\n  minimumAzimuthalAngle: -Infinity,\n  maximumAzimuthalAngle: Infinity,\n  minimumFieldOfView: 10,\n  maximumFieldOfView: 45,\n  eventHandlingBehavior: 'prevent-all',\n  interactionPolicy: 'always-allow'\n});\n\n// Internal orbital position state\nconst $spherical = Symbol('spherical');\nconst $goalSpherical = Symbol('goalSpherical');\nconst $thetaDamper = Symbol('thetaDamper');\nconst $phiDamper = Symbol('phiDamper');\nconst $radiusDamper = Symbol('radiusDamper');\nconst $logFov = Symbol('fov');\nconst $goalLogFov = Symbol('goalLogFov');\nconst $fovDamper = Symbol('fovDamper');\n\nconst $options = Symbol('options');\nconst $touchMode = Symbol('touchMode');\nconst $canInteract = Symbol('canInteract');\nconst $interactionEnabled = Symbol('interactionEnabled');\nconst $userAdjustOrbit = Symbol('userAdjustOrbit');\nconst $isUserChange = Symbol('isUserChange');\nconst $isStationary = Symbol('isMoving');\nconst $moveCamera = Symbol('moveCamera');\nconst $isUserPointing = Symbol('isUserPointing');\n\n// Pointer state\nconst $pointerIsDown = Symbol('pointerIsDown');\nconst $lastPointerPosition = Symbol('lastPointerPosition');\nconst $lastTouches = Symbol('lastTouches');\n\n// Value conversion methods\nconst $pixelLengthToSphericalAngle = Symbol('pixelLengthToSphericalAngle');\nconst $twoTouchDistance = Symbol('twoTouchDistance');\nconst $wrapAngle = Symbol('wrapAngle');\n\n// Event handlers\nconst $onMouseMove = Symbol('onMouseMove');\nconst $onMouseDown = Symbol('onMouseDown');\nconst $onMouseUp = Symbol('onMouseUp');\nconst $onTouchStart = Symbol('onTouchStart');\nconst $onTouchEnd = Symbol('onTouchEnd');\nconst $onTouchMove = Symbol('onTouchMove');\nconst $onWheel = Symbol('onWheel');\nconst $onKeyDown = Symbol('onKeyDown');\nconst $handlePointerMove = Symbol('handlePointerMove');\nconst $handleSinglePointerMove = Symbol('handleSinglePointerMove');\nconst $handlePointerDown = Symbol('handlePointerDown');\nconst $handleSinglePointerDown = Symbol('handleSinglePointerDown');\nconst $handlePointerUp = Symbol('handlePointerUp');\nconst $handleWheel = Symbol('handleWheel');\nconst $handleKey = Symbol('handleKey');\n\n// Constants\nconst TOUCH_EVENT_RE = /^touch(start|end|move)$/;\nconst KEYBOARD_ORBIT_INCREMENT = Math.PI / 8;\nconst ZOOM_SENSITIVITY = 0.04;\n\nexport const KeyCode = {\n  PAGE_UP: 33,\n  PAGE_DOWN: 34,\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40\n};\n\nexport type ChangeSource = 'user-interaction'|'none';\n\nexport const ChangeSource: {[index: string]: ChangeSource} = {\n  USER_INTERACTION: 'user-interaction',\n  NONE: 'none'\n};\n\n/**\n * ChangEvents are dispatched whenever the camera position or orientation has\n * changed\n */\nexport interface ChangeEvent extends ThreeEvent {\n  /**\n   * determines what was the originating reason for the change event eg user or\n   * none\n   */\n  source: ChangeSource,\n}\n\nexport interface PointerChangeEvent extends ThreeEvent {\n  type: 'pointer-change-start'|'pointer-change-end';\n  pointer: Pointer;\n}\n\n/**\n * SmoothControls is a Three.js helper for adding delightful pointer and\n * keyboard-based input to a staged Three.js scene. Its API is very similar to\n * OrbitControls, but it offers more opinionated (subjectively more delightful)\n * defaults, easy extensibility and subjectively better out-of-the-box keyboard\n * support.\n *\n * One important change compared to OrbitControls is that the `update` method\n * of SmoothControls must be invoked on every frame, otherwise the controls\n * will not have an effect.\n *\n * Another notable difference compared to OrbitControls is that SmoothControls\n * does not currently support panning (but probably will in a future revision).\n *\n * Like OrbitControls, SmoothControls assumes that the orientation of the camera\n * has been set in terms of position, rotation and scale, so it is important to\n * ensure that the camera's matrixWorld is in sync before using SmoothControls.\n */\nexport class SmoothControls extends EventDispatcher {\n  private[$interactionEnabled]: boolean = false;\n\n  private[$options]: SmoothControlsOptions;\n  private[$isUserChange] = false;\n  private[$isUserPointing] = false;\n\n  private[$spherical] = new Spherical();\n  private[$goalSpherical] = new Spherical();\n  private[$thetaDamper] = new Damper();\n  private[$phiDamper] = new Damper();\n  private[$radiusDamper] = new Damper();\n  private[$logFov]: number;\n  private[$goalLogFov]: number;\n  private[$fovDamper] = new Damper();\n\n  private[$pointerIsDown] = false;\n  private[$lastPointerPosition]: Pointer = {\n    clientX: 0,\n    clientY: 0,\n  };\n  private[$lastTouches]: TouchList;\n  private[$touchMode]: TouchMode;\n\n  private[$onMouseMove]: (event: Event) => void;\n  private[$onMouseDown]: (event: Event) => void;\n  private[$onMouseUp]: (event: Event) => void;\n  private[$onWheel]: (event: Event) => void;\n  private[$onKeyDown]: (event: Event) => void;\n\n  private[$onTouchStart]: (event: Event) => void;\n  private[$onTouchEnd]: (event: Event) => void;\n  private[$onTouchMove]: (event: Event) => void;\n\n  constructor(\n      readonly camera: PerspectiveCamera, readonly element: HTMLElement) {\n    super();\n\n    this[$onMouseMove] = (event: Event) =>\n        this[$handlePointerMove](event as MouseEvent);\n    this[$onMouseDown] = (event: Event) =>\n        this[$handlePointerDown](event as MouseEvent);\n    this[$onMouseUp] = (event: Event) =>\n        this[$handlePointerUp](event as MouseEvent);\n    this[$onWheel] = (event: Event) => this[$handleWheel](event as WheelEvent);\n    this[$onKeyDown] = (event: Event) =>\n        this[$handleKey](event as KeyboardEvent);\n    this[$onTouchStart] = (event: Event) =>\n        this[$handlePointerDown](event as TouchEvent);\n    this[$onTouchEnd] = (event: Event) =>\n        this[$handlePointerUp](event as TouchEvent);\n    this[$onTouchMove] = (event: Event) =>\n        this[$handlePointerMove](event as TouchEvent);\n\n    this[$options] = Object.assign({}, DEFAULT_OPTIONS);\n\n    this.setOrbit(0, Math.PI / 2, 1);\n    this.setFieldOfView(100);\n    this.jumpToGoal();\n  }\n\n  get interactionEnabled(): boolean {\n    return this[$interactionEnabled];\n  }\n\n  enableInteraction() {\n    if (this[$interactionEnabled] === false) {\n      const {element} = this;\n      element.addEventListener('mousemove', this[$onMouseMove]);\n      element.addEventListener('mousedown', this[$onMouseDown]);\n      element.addEventListener('wheel', this[$onWheel]);\n      element.addEventListener('keydown', this[$onKeyDown]);\n      element.addEventListener('touchstart', this[$onTouchStart]);\n      element.addEventListener('touchmove', this[$onTouchMove]);\n\n      self.addEventListener('mouseup', this[$onMouseUp]);\n      self.addEventListener('touchend', this[$onTouchEnd]);\n\n      this.element.style.cursor = 'grab';\n      this[$interactionEnabled] = true;\n    }\n  }\n\n  disableInteraction() {\n    if (this[$interactionEnabled] === true) {\n      const {element} = this;\n\n      element.removeEventListener('mousemove', this[$onMouseMove]);\n      element.removeEventListener('mousedown', this[$onMouseDown]);\n      element.removeEventListener('wheel', this[$onWheel]);\n      element.removeEventListener('keydown', this[$onKeyDown]);\n      element.removeEventListener('touchstart', this[$onTouchStart]);\n      element.removeEventListener('touchmove', this[$onTouchMove]);\n\n      self.removeEventListener('mouseup', this[$onMouseUp]);\n      self.removeEventListener('touchend', this[$onTouchEnd]);\n\n      element.style.cursor = '';\n      this[$interactionEnabled] = false;\n    }\n  }\n\n  /**\n   * The options that are currently configured for the controls instance.\n   */\n  get options() {\n    return this[$options];\n  }\n\n  /**\n   * Copy the spherical values that represent the current camera orbital\n   * position relative to the configured target into a provided Spherical\n   * instance. If no Spherical is provided, a new Spherical will be allocated\n   * to copy the values into. The Spherical that values are copied into is\n   * returned.\n   */\n  getCameraSpherical(target: Spherical = new Spherical()) {\n    return target.copy(this[$spherical]);\n  }\n\n  /**\n   * Returns the camera's current vertical field of view in degrees.\n   */\n  getFieldOfView(): number {\n    return this.camera.fov;\n  }\n\n  /**\n   * Configure the options of the controls. Configured options will be\n   * merged with whatever options have already been configured for this\n   * controls instance.\n   */\n  applyOptions(options: SmoothControlsOptions) {\n    Object.assign(this[$options], options);\n    // Re-evaluates clamping based on potentially new values for min/max\n    // polar, azimuth and radius:\n    this.setOrbit();\n    this.setFieldOfView(Math.exp(this[$goalLogFov]));\n  }\n\n  /**\n   * Sets the near and far planes of the camera.\n   */\n  updateNearFar(nearPlane: number, farPlane: number) {\n    this.camera.near = Math.max(nearPlane, farPlane / 1000);\n    this.camera.far = farPlane;\n    this.camera.updateProjectionMatrix();\n  }\n\n  /**\n   * Sets the aspect ratio of the camera\n   */\n  updateAspect(aspect: number) {\n    this.camera.aspect = aspect;\n    this.camera.updateProjectionMatrix();\n  }\n\n  /**\n   * Set the absolute orbital goal of the camera. The change will be\n   * applied over a number of frames depending on configured acceleration and\n   * dampening options.\n   *\n   * Returns true if invoking the method will result in the camera changing\n   * position and/or rotation, otherwise false.\n   */\n  setOrbit(\n      goalTheta: number = this[$goalSpherical].theta,\n      goalPhi: number = this[$goalSpherical].phi,\n      goalRadius: number = this[$goalSpherical].radius): boolean {\n    const {\n      minimumAzimuthalAngle,\n      maximumAzimuthalAngle,\n      minimumPolarAngle,\n      maximumPolarAngle,\n      minimumRadius,\n      maximumRadius\n    } = this[$options];\n\n    const {theta, phi, radius} = this[$goalSpherical];\n\n    const nextTheta =\n        clamp(goalTheta, minimumAzimuthalAngle!, maximumAzimuthalAngle!);\n    if (!isFinite(minimumAzimuthalAngle!) &&\n        !isFinite(maximumAzimuthalAngle!)) {\n      this[$spherical].theta =\n          this[$wrapAngle](this[$spherical].theta - nextTheta) + nextTheta;\n    }\n\n    const nextPhi = clamp(goalPhi, minimumPolarAngle!, maximumPolarAngle!);\n    const nextRadius = clamp(goalRadius, minimumRadius!, maximumRadius!);\n\n    if (nextTheta === theta && nextPhi === phi && nextRadius === radius) {\n      return false;\n    }\n\n    this[$goalSpherical].theta = nextTheta;\n    this[$goalSpherical].phi = nextPhi;\n    this[$goalSpherical].radius = nextRadius;\n    this[$goalSpherical].makeSafe();\n\n    this[$isUserChange] = false;\n\n    return true;\n  }\n\n  /**\n   * Subset of setOrbit() above, which only sets the camera's radius.\n   */\n  setRadius(radius: number) {\n    this[$goalSpherical].radius = radius;\n    this.setOrbit();\n  }\n\n  /**\n   * Sets the goal field of view for the camera\n   */\n  setFieldOfView(fov: number) {\n    const {minimumFieldOfView, maximumFieldOfView} = this[$options];\n    fov = clamp(fov, minimumFieldOfView!, maximumFieldOfView!);\n    this[$goalLogFov] = Math.log(fov);\n  }\n\n  /**\n   * Adjust the orbital position of the camera relative to its current orbital\n   * position. Does not let the theta goal get more than pi ahead of the current\n   * theta, which ensures interpolation continues in the direction of the delta.\n   * The deltaZoom parameter adjusts both the field of view and the orbit radius\n   * such that they progress across their allowed ranges in sync.\n   */\n  adjustOrbit(deltaTheta: number, deltaPhi: number, deltaZoom: number):\n      boolean {\n    const {theta, phi, radius} = this[$goalSpherical];\n    const {\n      minimumRadius,\n      maximumRadius,\n      minimumFieldOfView,\n      maximumFieldOfView\n    } = this[$options];\n\n    const dTheta = this[$spherical].theta - theta;\n    const dThetaLimit = Math.PI - 0.001;\n    const goalTheta =\n        theta - clamp(deltaTheta, -dThetaLimit - dTheta, dThetaLimit - dTheta);\n    const goalPhi = phi - deltaPhi;\n\n    const deltaRatio = deltaZoom === 0 ?\n        0 :\n        deltaZoom > 0 ? (maximumRadius! - radius) /\n                (Math.log(maximumFieldOfView!) - this[$goalLogFov]) :\n                        (radius - minimumRadius!) /\n                (this[$goalLogFov] - Math.log(minimumFieldOfView!));\n\n    const goalRadius = radius +\n        deltaZoom *\n            Math.min(\n                isFinite(deltaRatio) ? deltaRatio : Infinity,\n                maximumRadius! - minimumRadius!);\n    let handled = this.setOrbit(goalTheta, goalPhi, goalRadius);\n\n    if (deltaZoom !== 0) {\n      const goalLogFov = this[$goalLogFov] + deltaZoom;\n      this.setFieldOfView(Math.exp(goalLogFov));\n      handled = true;\n    }\n\n    return handled;\n  }\n\n  /**\n   * Move the camera instantly instead of accelerating toward the goal\n   * parameters.\n   */\n  jumpToGoal() {\n    this.update(0, SETTLING_TIME);\n  }\n\n  /**\n   * Update controls. In most cases, this will result in the camera\n   * interpolating its position and rotation until it lines up with the\n   * designated goal orbital position.\n   *\n   * Time and delta are measured in milliseconds.\n   */\n  update(_time: number, delta: number) {\n    if (this[$isStationary]()) {\n      return;\n    }\n    const {maximumPolarAngle, maximumRadius} = this[$options];\n\n    const dTheta = this[$spherical].theta - this[$goalSpherical].theta;\n    if (Math.abs(dTheta) > Math.PI &&\n        !isFinite(this[$options].minimumAzimuthalAngle!) &&\n        !isFinite(this[$options].maximumAzimuthalAngle!)) {\n      this[$spherical].theta -= Math.sign(dTheta) * 2 * Math.PI;\n    }\n\n    this[$spherical].theta = this[$thetaDamper].update(\n        this[$spherical].theta, this[$goalSpherical].theta, delta, Math.PI);\n\n    this[$spherical].phi = this[$phiDamper].update(\n        this[$spherical].phi,\n        this[$goalSpherical].phi,\n        delta,\n        maximumPolarAngle!);\n\n    this[$spherical].radius = this[$radiusDamper].update(\n        this[$spherical].radius,\n        this[$goalSpherical].radius,\n        delta,\n        maximumRadius!);\n\n    this[$logFov] =\n        this[$fovDamper].update(this[$logFov], this[$goalLogFov], delta, 1);\n\n    this[$moveCamera]();\n  }\n\n  private[$isStationary](): boolean {\n    return this[$goalSpherical].theta === this[$spherical].theta &&\n        this[$goalSpherical].phi === this[$spherical].phi &&\n        this[$goalSpherical].radius === this[$spherical].radius &&\n        this[$goalLogFov] === this[$logFov];\n  }\n\n  private[$moveCamera]() {\n    // Derive the new camera position from the updated spherical:\n    this[$spherical].makeSafe();\n    this.camera.position.setFromSpherical(this[$spherical]);\n    this.camera.setRotationFromEuler(new Euler(\n        this[$spherical].phi - Math.PI / 2, this[$spherical].theta, 0, 'YXZ'));\n\n    if (this.camera.fov !== Math.exp(this[$logFov])) {\n      this.camera.fov = Math.exp(this[$logFov]);\n      this.camera.updateProjectionMatrix();\n    }\n\n    const source =\n        this[$isUserChange] ? ChangeSource.USER_INTERACTION : ChangeSource.NONE;\n\n    this.dispatchEvent({type: 'change', source});\n  }\n\n  private get[$canInteract](): boolean {\n    if (this[$options].interactionPolicy == 'allow-when-focused') {\n      const rootNode = this.element.getRootNode() as Document | ShadowRoot;\n      return rootNode.activeElement === this.element;\n    }\n\n    return this[$options].interactionPolicy === 'always-allow';\n  }\n\n  private[$userAdjustOrbit](\n      deltaTheta: number, deltaPhi: number, deltaZoom: number): boolean {\n    const handled = this.adjustOrbit(deltaTheta, deltaPhi, deltaZoom);\n\n    this[$isUserChange] = true;\n    // Always make sure that an initial event is triggered in case there is\n    // contention between user interaction and imperative changes. This initial\n    // event will give external observers that chance to observe that\n    // interaction occurred at all:\n    this.dispatchEvent({type: 'change', source: ChangeSource.USER_INTERACTION});\n\n    return handled;\n  }\n\n  // Wraps to bewteen -pi and pi\n  private[$wrapAngle](radians: number): number {\n    const normalized = (radians + Math.PI) / (2 * Math.PI);\n    const wrapped = normalized - Math.floor(normalized);\n    return wrapped * 2 * Math.PI - Math.PI;\n  }\n\n  private[$pixelLengthToSphericalAngle](pixelLength: number): number {\n    return 2 * Math.PI * pixelLength / this.element.clientHeight;\n  }\n\n  private[$twoTouchDistance](touchOne: Touch, touchTwo: Touch): number {\n    const {clientX: xOne, clientY: yOne} = touchOne;\n    const {clientX: xTwo, clientY: yTwo} = touchTwo;\n    const xDelta = xTwo - xOne;\n    const yDelta = yTwo - yOne;\n\n    return Math.sqrt(xDelta * xDelta + yDelta * yDelta);\n  }\n\n  private[$handlePointerMove](event: MouseEvent|TouchEvent) {\n    if (!this[$pointerIsDown] || !this[$canInteract]) {\n      return;\n    }\n\n    let handled = false;\n\n    // NOTE(cdata): We test event.type as some browsers do not have a global\n    // TouchEvent contructor.\n    if (TOUCH_EVENT_RE.test(event.type)) {\n      const {touches} = event as TouchEvent;\n\n      switch (this[$touchMode]) {\n        case 'zoom':\n          if (this[$lastTouches].length > 1 && touches.length > 1) {\n            const lastTouchDistance = this[$twoTouchDistance](\n                this[$lastTouches][0], this[$lastTouches][1]);\n            const touchDistance =\n                this[$twoTouchDistance](touches[0], touches[1]);\n            const deltaZoom =\n                ZOOM_SENSITIVITY * (lastTouchDistance - touchDistance) / 10.0;\n\n            handled = this[$userAdjustOrbit](0, 0, deltaZoom);\n          }\n\n          break;\n        case 'rotate':\n          handled = this[$handleSinglePointerMove](touches[0]);\n          break;\n      }\n\n      this[$lastTouches] = touches;\n    } else {\n      handled = this[$handleSinglePointerMove](event as MouseEvent);\n    }\n\n    if ((handled || this[$options].eventHandlingBehavior === 'prevent-all') &&\n        event.cancelable) {\n      event.preventDefault();\n    };\n  }\n\n  private[$handleSinglePointerMove](pointer: Pointer): boolean {\n    const {clientX, clientY} = pointer;\n    const deltaTheta = this[$pixelLengthToSphericalAngle](\n        clientX - this[$lastPointerPosition].clientX);\n    const deltaPhi = this[$pixelLengthToSphericalAngle](\n        clientY - this[$lastPointerPosition].clientY);\n\n    this[$lastPointerPosition].clientX = clientX;\n    this[$lastPointerPosition].clientY = clientY;\n\n    if (this[$isUserPointing] === false) {\n      this[$isUserPointing] = true;\n      this.dispatchEvent({type: 'pointer-change-start', pointer: {...pointer}});\n    }\n\n    return this[$userAdjustOrbit](deltaTheta, deltaPhi, 0);\n  }\n\n  private[$handlePointerDown](event: MouseEvent|TouchEvent) {\n    this[$pointerIsDown] = true;\n    this[$isUserPointing] = false;\n\n    if (TOUCH_EVENT_RE.test(event.type)) {\n      const {touches} = event as TouchEvent;\n\n      switch (touches.length) {\n        default:\n        case 1:\n          this[$touchMode] = 'rotate';\n          this[$handleSinglePointerDown](touches[0]);\n          break;\n        case 2:\n          this[$touchMode] = 'zoom';\n          break;\n      }\n\n      this[$lastTouches] = touches;\n    } else {\n      this[$handleSinglePointerDown](event as MouseEvent);\n    }\n  }\n\n  private[$handleSinglePointerDown](pointer: Pointer) {\n    this[$lastPointerPosition].clientX = pointer.clientX;\n    this[$lastPointerPosition].clientY = pointer.clientY;\n    this.element.style.cursor = 'grabbing';\n  }\n\n  private[$handlePointerUp](_event: MouseEvent|TouchEvent) {\n    this.element.style.cursor = 'grab';\n    this[$pointerIsDown] = false;\n\n    if (this[$isUserPointing]) {\n      this.dispatchEvent({\n        type: 'pointer-change-end',\n        pointer: {...this[$lastPointerPosition]}\n      });\n    }\n  }\n\n  private[$handleWheel](event: Event) {\n    if (!this[$canInteract]) {\n      return;\n    }\n\n    const deltaZoom = (event as WheelEvent).deltaY * ZOOM_SENSITIVITY / 30;\n\n    if ((this[$userAdjustOrbit](0, 0, deltaZoom) ||\n         this[$options].eventHandlingBehavior === 'prevent-all') &&\n        event.cancelable) {\n      event.preventDefault();\n    }\n  }\n\n  private[$handleKey](event: KeyboardEvent) {\n    // We track if the key is actually one we respond to, so as not to\n    // accidentally clober unrelated key inputs when the <model-viewer> has\n    // focus and eventHandlingBehavior is set to 'prevent-all'.\n    let relevantKey = false;\n    let handled = false;\n\n    switch (event.keyCode) {\n      case KeyCode.PAGE_UP:\n        relevantKey = true;\n        handled = this[$userAdjustOrbit](0, 0, ZOOM_SENSITIVITY);\n        break;\n      case KeyCode.PAGE_DOWN:\n        relevantKey = true;\n        handled = this[$userAdjustOrbit](0, 0, -1 * ZOOM_SENSITIVITY);\n        break;\n      case KeyCode.UP:\n        relevantKey = true;\n        handled = this[$userAdjustOrbit](0, -KEYBOARD_ORBIT_INCREMENT, 0);\n        break;\n      case KeyCode.DOWN:\n        relevantKey = true;\n        handled = this[$userAdjustOrbit](0, KEYBOARD_ORBIT_INCREMENT, 0);\n        break;\n      case KeyCode.LEFT:\n        relevantKey = true;\n        handled = this[$userAdjustOrbit](-KEYBOARD_ORBIT_INCREMENT, 0, 0);\n        break;\n      case KeyCode.RIGHT:\n        relevantKey = true;\n        handled = this[$userAdjustOrbit](KEYBOARD_ORBIT_INCREMENT, 0, 0);\n        break;\n    }\n\n    if (relevantKey &&\n        (handled || this[$options].eventHandlingBehavior === 'prevent-all') &&\n        event.cancelable) {\n      event.preventDefault();\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}