{"ast":null,"code":"/**\n * This mixin function is designed to be applied to a class that inherits\n * from HTMLElement. It makes it easy for a custom element to coordinate with\n * the :focus-visible polyfill.\n *\n * NOTE(cdata): The code here was adapted from an example proposed with the\n * introduction of ShadowDOM support in the :focus-visible polyfill.\n *\n * @see https://github.com/WICG/focus-visible/pull/196\n * @param {Function} SuperClass The base class implementation to decorate with\n * implementation that coordinates with the :focus-visible polyfill\n */\nexport const FocusVisiblePolyfillMixin = SuperClass => {\n  var _a;\n\n  const coordinateWithPolyfill = instance => {\n    // If there is no shadow root, there is no need to coordinate with\n    // the polyfill. If we already coordinated with the polyfill, we can\n    // skip subsequent invokcations:\n    if (instance.shadowRoot == null || instance.hasAttribute('data-js-focus-visible')) {\n      return () => {};\n    } // The polyfill might already be loaded. If so, we can apply it to\n    // the shadow root immediately:\n\n\n    if (self.applyFocusVisiblePolyfill) {\n      self.applyFocusVisiblePolyfill(instance.shadowRoot);\n    } else {\n      const coordinationHandler = () => {\n        self.applyFocusVisiblePolyfill(instance.shadowRoot);\n      }; // Otherwise, wait for the polyfill to be loaded lazily. It might\n      // never be loaded, but if it is then we can apply it to the\n      // shadow root at the appropriate time by waiting for the ready\n      // event:\n\n\n      self.addEventListener('focus-visible-polyfill-ready', coordinationHandler, {\n        once: true\n      });\n      return () => {\n        self.removeEventListener('focus-visible-polyfill-ready', coordinationHandler);\n      };\n    }\n\n    return () => {};\n  };\n\n  const $endPolyfillCoordination = Symbol('endPolyfillCoordination'); // IE11 doesn't natively support custom elements or JavaScript class\n  // syntax The mixin implementation assumes that the user will take the\n  // appropriate steps to support both:\n\n  class FocusVisibleCoordinator extends SuperClass {\n    constructor() {\n      super(...arguments);\n      this[_a] = null;\n    } // Attempt to coordinate with the polyfill when connected to the\n    // document:\n\n\n    connectedCallback() {\n      super.connectedCallback && super.connectedCallback();\n\n      if (this[$endPolyfillCoordination] == null) {\n        this[$endPolyfillCoordination] = coordinateWithPolyfill(this);\n      }\n    }\n\n    disconnectedCallback() {\n      super.disconnectedCallback && super.disconnectedCallback(); // It's important to remove the polyfill event listener when we\n      // disconnect, otherwise we will leak the whole element via window:\n\n      if (this[$endPolyfillCoordination] != null) {\n        this[$endPolyfillCoordination]();\n        this[$endPolyfillCoordination] = null;\n      }\n    }\n\n  }\n\n  _a = $endPolyfillCoordination;\n  ;\n  return FocusVisibleCoordinator;\n};","map":{"version":3,"sources":["../../src/utilities/focus-visible.ts"],"names":[],"mappings":"AAyBA;;;;;;;;;;;;AAYA,OAAO,MAAM,yBAAyB,GACQ,UAA1C,IAA8D;;;AAC5D,QAAM,sBAAsB,GACvB,QAAD,IAAgE;AAC9D;AACA;AACA;AACA,QAAI,QAAQ,CAAC,UAAT,IAAuB,IAAvB,IACA,QAAQ,CAAC,YAAT,CAAsB,uBAAtB,CADJ,EACoD;AAClD,aAAO,MAAK,CAAG,CAAf;AACD,KAP6D,CAS9D;AACA;;;AACA,QAAK,IAAY,CAAC,yBAAlB,EAA6C;AAC1C,MAAA,IAAY,CAAC,yBAAb,CAAuC,QAAQ,CAAC,UAAhD;AACF,KAFD,MAEO;AACL,YAAM,mBAAmB,GAAG,MAAK;AAC9B,QAAA,IAAY,CAAC,yBAAb,CAAuC,QAAQ,CAAC,UAAhD;AACF,OAFD,CADK,CAIL;AACA;AACA;AACA;;;AACA,MAAA,IAAI,CAAC,gBAAL,CACI,8BADJ,EAEI,mBAFJ,EAGI;AAAC,QAAA,IAAI,EAAE;AAAP,OAHJ;AAKA,aAAO,MAAK;AACV,QAAA,IAAI,CAAC,mBAAL,CACI,8BADJ,EACoC,mBADpC;AAED,OAHD;AAID;;AAED,WAAO,MAAK,CAAG,CAAf;AACD,GAlCL;;AAoCA,QAAM,wBAAwB,GAAG,MAAM,CAAC,yBAAD,CAAvC,CArC4D,CAuC5D;AACA;AACA;;AACA,QAAM,uBAAN,SAAsC,UAAtC,CAAgD;AAAhD,IAAA,WAAA,GAAA;;AACS,WAAA,EAAA,IACI,IADJ;AAoBR,KArB+C,CAG9C;AACA;;;AACA,IAAA,iBAAiB,GAAA;AACf,YAAM,iBAAN,IAA2B,MAAM,iBAAN,EAA3B;;AACA,UAAI,KAAK,wBAAL,KAAkC,IAAtC,EAA4C;AAC1C,aAAK,wBAAL,IAAiC,sBAAsB,CAAC,IAAD,CAAvD;AACD;AACF;;AAED,IAAA,oBAAoB,GAAA;AAClB,YAAM,oBAAN,IAA8B,MAAM,oBAAN,EAA9B,CADkB,CAElB;AACA;;AACA,UAAI,KAAK,wBAAL,KAAkC,IAAtC,EAA4C;AAC1C,aAAK,wBAAL;AACA,aAAK,wBAAL,IAAiC,IAAjC;AACD;AACF;;AApB6C;;OACtC,wB;AAoBT;AAED,SAAO,uBAAP;AACD,CAnEE","sourcesContent":["/* @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {Constructor} from '../utilities.js';\n\nexport interface OptionalLifecycleCallbacks {\n  connectedCallback?(): void;\n  disconnectedCallback?(): void;\n}\n\nexport type MixableBaseClass = HTMLElement&OptionalLifecycleCallbacks;\n\ntype EndPolyfillCoordinationCallback = () => void;\n\n/**\n * This mixin function is designed to be applied to a class that inherits\n * from HTMLElement. It makes it easy for a custom element to coordinate with\n * the :focus-visible polyfill.\n *\n * NOTE(cdata): The code here was adapted from an example proposed with the\n * introduction of ShadowDOM support in the :focus-visible polyfill.\n *\n * @see https://github.com/WICG/focus-visible/pull/196\n * @param {Function} SuperClass The base class implementation to decorate with\n * implementation that coordinates with the :focus-visible polyfill\n */\nexport const FocusVisiblePolyfillMixin =\n    <T extends Constructor<MixableBaseClass>>(SuperClass: T): T => {\n      const coordinateWithPolyfill =\n          (instance: MixableBaseClass): EndPolyfillCoordinationCallback => {\n            // If there is no shadow root, there is no need to coordinate with\n            // the polyfill. If we already coordinated with the polyfill, we can\n            // skip subsequent invokcations:\n            if (instance.shadowRoot == null ||\n                instance.hasAttribute('data-js-focus-visible')) {\n              return () => {};\n            }\n\n            // The polyfill might already be loaded. If so, we can apply it to\n            // the shadow root immediately:\n            if ((self as any).applyFocusVisiblePolyfill) {\n              (self as any).applyFocusVisiblePolyfill(instance.shadowRoot);\n            } else {\n              const coordinationHandler = () => {\n                (self as any).applyFocusVisiblePolyfill(instance.shadowRoot);\n              };\n              // Otherwise, wait for the polyfill to be loaded lazily. It might\n              // never be loaded, but if it is then we can apply it to the\n              // shadow root at the appropriate time by waiting for the ready\n              // event:\n              self.addEventListener(\n                  'focus-visible-polyfill-ready',\n                  coordinationHandler,\n                  {once: true});\n\n              return () => {\n                self.removeEventListener(\n                    'focus-visible-polyfill-ready', coordinationHandler);\n              };\n            }\n\n            return () => {};\n          };\n\n      const $endPolyfillCoordination = Symbol('endPolyfillCoordination');\n\n      // IE11 doesn't natively support custom elements or JavaScript class\n      // syntax The mixin implementation assumes that the user will take the\n      // appropriate steps to support both:\n      class FocusVisibleCoordinator extends SuperClass {\n        private[$endPolyfillCoordination]: EndPolyfillCoordinationCallback|\n            null = null;\n        // Attempt to coordinate with the polyfill when connected to the\n        // document:\n        connectedCallback() {\n          super.connectedCallback && super.connectedCallback();\n          if (this[$endPolyfillCoordination] == null) {\n            this[$endPolyfillCoordination] = coordinateWithPolyfill(this);\n          }\n        }\n\n        disconnectedCallback() {\n          super.disconnectedCallback && super.disconnectedCallback();\n          // It's important to remove the polyfill event listener when we\n          // disconnect, otherwise we will leak the whole element via window:\n          if (this[$endPolyfillCoordination] != null) {\n            this[$endPolyfillCoordination]!();\n            this[$endPolyfillCoordination] = null;\n          }\n        }\n      };\n\n      return FocusVisibleCoordinator;\n    };"],"sourceRoot":""},"metadata":{},"sourceType":"module"}