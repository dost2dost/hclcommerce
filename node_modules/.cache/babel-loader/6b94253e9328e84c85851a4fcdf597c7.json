{"ast":null,"code":"var utils = require('../utils/');\n\nvar PropertyTypes = require('./propertyTypes');\n\nvar debug = utils.debug;\nvar isValidDefaultValue = PropertyTypes.isValidDefaultValue;\nvar propertyTypes = PropertyTypes.propertyTypes;\nvar warn = debug('core:schema:warn');\n/**\n * A schema is classified as a schema for a single property if:\n * - `type` is defined on the schema as a string.\n * - OR `default` is defined on the schema, as a reserved keyword.\n * - OR schema is empty.\n */\n\nfunction isSingleProperty(schema) {\n  if ('type' in schema) {\n    return typeof schema.type === 'string';\n  }\n\n  return 'default' in schema;\n}\n\nmodule.exports.isSingleProperty = isSingleProperty;\n/**\n * Build step to schema to use `type` to inject default value, parser, and stringifier.\n *\n * @param {object} schema\n * @param {string} componentName\n * @returns {object} Schema.\n */\n\nmodule.exports.process = function (schema, componentName) {\n  var propName; // For single property schema, run processPropDefinition over the whole schema.\n\n  if (isSingleProperty(schema)) {\n    return processPropertyDefinition(schema, componentName);\n  } // For multi-property schema, run processPropDefinition over each property definition.\n\n\n  for (propName in schema) {\n    schema[propName] = processPropertyDefinition(schema[propName], componentName);\n  }\n\n  return schema;\n};\n/**\n * Inject default value, parser, stringifier for single property.\n *\n * @param {object} propDefinition\n * @param {string} componentName\n */\n\n\nfunction processPropertyDefinition(propDefinition, componentName) {\n  var defaultVal = propDefinition.default;\n  var isCustomType;\n  var propType;\n  var typeName = propDefinition.type; // Type inference.\n\n  if (!propDefinition.type) {\n    if (defaultVal !== undefined && (typeof defaultVal === 'boolean' || typeof defaultVal === 'number')) {\n      // Type inference.\n      typeName = typeof defaultVal;\n    } else if (Array.isArray(defaultVal)) {\n      typeName = 'array';\n    } else {\n      // Fall back to string.\n      typeName = 'string';\n    }\n  } else if (propDefinition.type === 'bool') {\n    typeName = 'boolean';\n  } else if (propDefinition.type === 'float') {\n    typeName = 'number';\n  }\n\n  propType = propertyTypes[typeName];\n\n  if (!propType) {\n    warn('Unknown property type for component `' + componentName + '`: ' + typeName);\n  } // Fill in parse and stringify using property types.\n\n\n  isCustomType = !!propDefinition.parse;\n  propDefinition.parse = propDefinition.parse || propType.parse;\n  propDefinition.stringify = propDefinition.stringify || propType.stringify; // Fill in type name.\n\n  propDefinition.type = typeName; // Check that default value exists.\n\n  if ('default' in propDefinition) {\n    // Check that default values are valid.\n    if (!isCustomType && !isValidDefaultValue(typeName, defaultVal)) {\n      warn('Default value `' + defaultVal + '` does not match type `' + typeName + '` in component `' + componentName + '`');\n    }\n  } else {\n    // Fill in default value.\n    propDefinition.default = propType.default;\n  }\n\n  return propDefinition;\n}\n\nmodule.exports.processPropertyDefinition = processPropertyDefinition;\n/**\n * Parse propData using schema. Use default values if not existing in propData.\n *\n * @param {object} propData - Unparsed properties.\n * @param {object} schema - Property types definition.\n * @param {boolean} getPartialData - Whether to return full component data or just the data\n *        with keys in `propData`.\n * @param {string } componentName - Name of the component, used for the property warning.\n * @param {boolean} silent - Suppress warning messages.\n */\n\nmodule.exports.parseProperties = function () {\n  var propNames = [];\n  return function (propData, schema, getPartialData, componentName, silent) {\n    var i;\n    var propName;\n    var propDefinition;\n    var propValue;\n    propNames.length = 0;\n\n    for (propName in getPartialData ? propData : schema) {\n      if (getPartialData && propData[propName] === undefined) {\n        continue;\n      }\n\n      propNames.push(propName);\n    }\n\n    if (propData === null || typeof propData !== 'object') {\n      return propData;\n    } // Validation errors.\n\n\n    for (propName in propData) {\n      if (propData[propName] !== undefined && !schema[propName] && !silent) {\n        warn('Unknown property `' + propName + '` for component/system `' + componentName + '`.');\n      }\n    }\n\n    for (i = 0; i < propNames.length; i++) {\n      propName = propNames[i];\n      propDefinition = schema[propName];\n      propValue = propData[propName];\n\n      if (!schema[propName]) {\n        return;\n      }\n\n      propData[propName] = parseProperty(propValue, propDefinition);\n    }\n\n    return propData;\n  };\n}();\n/**\n * Deserialize a single property.\n */\n\n\nfunction parseProperty(value, propDefinition) {\n  // Use default value if value is falsy.\n  if (value === undefined || value === null || value === '') {\n    value = propDefinition.default;\n\n    if (Array.isArray(value)) {\n      value = value.slice();\n    }\n  } // Invoke property type parser.\n\n\n  return propDefinition.parse(value, propDefinition.default);\n}\n\nmodule.exports.parseProperty = parseProperty;\n/**\n * Serialize a group of properties.\n */\n\nmodule.exports.stringifyProperties = function (propData, schema) {\n  var propName;\n  var propDefinition;\n  var propValue;\n  var stringifiedData = {};\n  var value;\n\n  for (propName in propData) {\n    propDefinition = schema[propName];\n    propValue = propData[propName];\n    value = propValue;\n\n    if (typeof value === 'object') {\n      value = stringifyProperty(propValue, propDefinition);\n\n      if (!propDefinition) {\n        warn('Unknown component property: ' + propName);\n      }\n    }\n\n    stringifiedData[propName] = value;\n  }\n\n  return stringifiedData;\n};\n/**\n * Serialize a single property.\n */\n\n\nfunction stringifyProperty(value, propDefinition) {\n  // This function stringifies but it's used in a context where\n  // there's always second stringification pass. By returning the original\n  // value when it's not an object we save one unnecessary call\n  // to JSON.stringify.\n  if (typeof value !== 'object') {\n    return value;\n  } // if there's no schema for the property we use standar JSON stringify\n\n\n  if (!propDefinition || value === null) {\n    return JSON.stringify(value);\n  }\n\n  return propDefinition.stringify(value);\n}\n\nmodule.exports.stringifyProperty = stringifyProperty;","map":{"version":3,"sources":["C:/Users/Hannuri/Desktop/RoyalCyber/my-first-app/node_modules/aframe/src/core/schema.js"],"names":["utils","require","PropertyTypes","debug","isValidDefaultValue","propertyTypes","warn","isSingleProperty","schema","type","module","exports","process","componentName","propName","processPropertyDefinition","propDefinition","defaultVal","default","isCustomType","propType","typeName","undefined","Array","isArray","parse","stringify","parseProperties","propNames","propData","getPartialData","silent","i","propValue","length","push","parseProperty","value","slice","stringifyProperties","stringifiedData","stringifyProperty","JSON"],"mappings":"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","sourcesContent":["var utils = require('../utils/');\nvar PropertyTypes = require('./propertyTypes');\n\nvar debug = utils.debug;\nvar isValidDefaultValue = PropertyTypes.isValidDefaultValue;\nvar propertyTypes = PropertyTypes.propertyTypes;\n\nvar warn = debug('core:schema:warn');\n\n/**\n * A schema is classified as a schema for a single property if:\n * - `type` is defined on the schema as a string.\n * - OR `default` is defined on the schema, as a reserved keyword.\n * - OR schema is empty.\n */\nfunction isSingleProperty (schema) {\n  if ('type' in schema) {\n    return typeof schema.type === 'string';\n  }\n  return 'default' in schema;\n}\nmodule.exports.isSingleProperty = isSingleProperty;\n\n/**\n * Build step to schema to use `type` to inject default value, parser, and stringifier.\n *\n * @param {object} schema\n * @param {string} componentName\n * @returns {object} Schema.\n */\nmodule.exports.process = function (schema, componentName) {\n  var propName;\n\n  // For single property schema, run processPropDefinition over the whole schema.\n  if (isSingleProperty(schema)) {\n    return processPropertyDefinition(schema, componentName);\n  }\n\n  // For multi-property schema, run processPropDefinition over each property definition.\n  for (propName in schema) {\n    schema[propName] = processPropertyDefinition(schema[propName], componentName);\n  }\n  return schema;\n};\n\n/**\n * Inject default value, parser, stringifier for single property.\n *\n * @param {object} propDefinition\n * @param {string} componentName\n */\nfunction processPropertyDefinition (propDefinition, componentName) {\n  var defaultVal = propDefinition.default;\n  var isCustomType;\n  var propType;\n  var typeName = propDefinition.type;\n\n  // Type inference.\n  if (!propDefinition.type) {\n    if (defaultVal !== undefined &&\n        (typeof defaultVal === 'boolean' || typeof defaultVal === 'number')) {\n      // Type inference.\n      typeName = typeof defaultVal;\n    } else if (Array.isArray(defaultVal)) {\n      typeName = 'array';\n    } else {\n      // Fall back to string.\n      typeName = 'string';\n    }\n  } else if (propDefinition.type === 'bool') {\n    typeName = 'boolean';\n  } else if (propDefinition.type === 'float') {\n    typeName = 'number';\n  }\n\n  propType = propertyTypes[typeName];\n  if (!propType) {\n    warn('Unknown property type for component `' + componentName + '`: ' + typeName);\n  }\n\n  // Fill in parse and stringify using property types.\n  isCustomType = !!propDefinition.parse;\n  propDefinition.parse = propDefinition.parse || propType.parse;\n  propDefinition.stringify = propDefinition.stringify || propType.stringify;\n\n  // Fill in type name.\n  propDefinition.type = typeName;\n\n  // Check that default value exists.\n  if ('default' in propDefinition) {\n    // Check that default values are valid.\n    if (!isCustomType && !isValidDefaultValue(typeName, defaultVal)) {\n      warn('Default value `' + defaultVal + '` does not match type `' + typeName +\n           '` in component `' + componentName + '`');\n    }\n  } else {\n    // Fill in default value.\n    propDefinition.default = propType.default;\n  }\n\n  return propDefinition;\n}\nmodule.exports.processPropertyDefinition = processPropertyDefinition;\n\n/**\n * Parse propData using schema. Use default values if not existing in propData.\n *\n * @param {object} propData - Unparsed properties.\n * @param {object} schema - Property types definition.\n * @param {boolean} getPartialData - Whether to return full component data or just the data\n *        with keys in `propData`.\n * @param {string } componentName - Name of the component, used for the property warning.\n * @param {boolean} silent - Suppress warning messages.\n */\nmodule.exports.parseProperties = (function () {\n  var propNames = [];\n\n  return function (propData, schema, getPartialData, componentName, silent) {\n    var i;\n    var propName;\n    var propDefinition;\n    var propValue;\n\n    propNames.length = 0;\n    for (propName in (getPartialData ? propData : schema)) {\n      if (getPartialData && propData[propName] === undefined) { continue; }\n      propNames.push(propName);\n    }\n\n    if (propData === null || typeof propData !== 'object') { return propData; }\n\n    // Validation errors.\n    for (propName in propData) {\n      if (propData[propName] !== undefined && !schema[propName] && !silent) {\n        warn('Unknown property `' + propName +\n             '` for component/system `' + componentName + '`.');\n      }\n    }\n\n    for (i = 0; i < propNames.length; i++) {\n      propName = propNames[i];\n      propDefinition = schema[propName];\n      propValue = propData[propName];\n      if (!(schema[propName])) { return; }\n      propData[propName] = parseProperty(propValue, propDefinition);\n    }\n\n    return propData;\n  };\n})();\n\n/**\n * Deserialize a single property.\n */\nfunction parseProperty (value, propDefinition) {\n  // Use default value if value is falsy.\n  if (value === undefined || value === null || value === '') {\n    value = propDefinition.default;\n    if (Array.isArray(value)) { value = value.slice(); }\n  }\n  // Invoke property type parser.\n  return propDefinition.parse(value, propDefinition.default);\n}\nmodule.exports.parseProperty = parseProperty;\n\n/**\n * Serialize a group of properties.\n */\nmodule.exports.stringifyProperties = function (propData, schema) {\n  var propName;\n  var propDefinition;\n  var propValue;\n  var stringifiedData = {};\n  var value;\n\n  for (propName in propData) {\n    propDefinition = schema[propName];\n    propValue = propData[propName];\n    value = propValue;\n    if (typeof value === 'object') {\n      value = stringifyProperty(propValue, propDefinition);\n      if (!propDefinition) { warn('Unknown component property: ' + propName); }\n    }\n    stringifiedData[propName] = value;\n  }\n  return stringifiedData;\n};\n\n/**\n * Serialize a single property.\n */\nfunction stringifyProperty (value, propDefinition) {\n  // This function stringifies but it's used in a context where\n  // there's always second stringification pass. By returning the original\n  // value when it's not an object we save one unnecessary call\n  // to JSON.stringify.\n  if (typeof value !== 'object') { return value; }\n  // if there's no schema for the property we use standar JSON stringify\n  if (!propDefinition || value === null) { return JSON.stringify(value); }\n  return propDefinition.stringify(value);\n}\nmodule.exports.stringifyProperty = stringifyProperty;\n"]},"metadata":{},"sourceType":"script"}