{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { StyleEvaluator } from './styles/evaluators';\nimport { parseExpressions } from './styles/parsers';\nimport { StyleEffector } from './styles/style-effector';\n/**\n * The @style decorator is responsible for coordinating the conversion of a\n * CSS-like string property value into numbers that can be applied to\n * lower-level constructs. It also can optionally manage the lifecycle of a\n * StyleEffector which allows automatic updates for styles that use env() or\n * var() functions.\n *\n * The decorator is configured with Intrinsics and the property key for a\n * method that handles updates. The named update handler is invoked with the\n * result of parsing and evaluating the raw property string value. The format of\n * the evaluated result is derived from the basis of the configured Intrinsics,\n * and is always an array of numbers of fixed length.\n *\n * NOTE: This decorator depends on the property updating mechanism defined by\n * UpdatingElement as exported by the lit-element module. That means it *must*\n * be used in conjunction with the @property decorator, or equivalent\n * JavaScript.\n *\n * Supported configurations are:\n *\n *  - `intrinsics`: An Intrinsics struct that describes how to interpret a\n * serialized style attribute. For more detail on intrinsics see\n * ./styles/evaluators.ts\n *  - `updateHandler`: A string or Symbol that is the key of a method to be\n * invoked with the result of parsing and evaluating a serialized style string.\n *  - `observeEffects`: Optional, if set to true then styles that use env() will\n * cause their update handlers to be invoked every time the corresponding\n * environment variable changes (even if the style attribute itself remains\n * static).\n */\n\nexport const style = config => {\n  const observeEffects = config.observeEffects || false;\n  const getIntrinsics = config.intrinsics instanceof Function ? config.intrinsics : () => config.intrinsics;\n  return (proto, propertyName) => {\n    const originalUpdated = proto.updated;\n    const originalConnectedCallback = proto.connectedCallback;\n    const originalDisconnectedCallback = proto.disconnectedCallback;\n    const $styleEffector = Symbol(`${propertyName}StyleEffector`);\n    const $styleEvaluator = Symbol(`${propertyName}StyleEvaluator`);\n    const $updateEvaluator = Symbol(`${propertyName}UpdateEvaluator`);\n    const $evaluateAndSync = Symbol(`${propertyName}EvaluateAndSync`);\n    Object.defineProperties(proto, {\n      [$styleEffector]: {\n        value: null,\n        writable: true\n      },\n      [$styleEvaluator]: {\n        value: null,\n        writable: true\n      },\n      [$updateEvaluator]: {\n        value: function () {\n          const ast = parseExpressions(this[propertyName]);\n          this[$styleEvaluator] = new StyleEvaluator(ast, getIntrinsics(this));\n\n          if (this[$styleEffector] == null && observeEffects) {\n            this[$styleEffector] = new StyleEffector(() => this[$evaluateAndSync]());\n          }\n\n          if (this[$styleEffector] != null) {\n            this[$styleEffector].observeEffectsFor(ast);\n          }\n        }\n      },\n      [$evaluateAndSync]: {\n        value: function () {\n          if (this[$styleEvaluator] == null) {\n            return;\n          }\n\n          const result = this[$styleEvaluator].evaluate(); // @see https://github.com/microsoft/TypeScript/pull/30769\n          // @see https://github.com/Microsoft/TypeScript/issues/1863\n\n          this[config.updateHandler](result);\n        }\n      },\n      updated: {\n        value: function (changedProperties) {\n          // Always invoke updates to styles first. This gives a class that\n          // uses this decorator the opportunity to override the effect, or\n          // respond to it, in its own implementation of `updated`.\n          if (changedProperties.has(propertyName)) {\n            this[$updateEvaluator]();\n            this[$evaluateAndSync]();\n          }\n\n          originalUpdated.call(this, changedProperties);\n        }\n      },\n      connectedCallback: {\n        value: function () {\n          originalConnectedCallback.call(this);\n          this.requestUpdate(propertyName, this[propertyName]);\n        }\n      },\n      disconnectedCallback: {\n        value: function () {\n          originalDisconnectedCallback.call(this);\n\n          if (this[$styleEffector] != null) {\n            this[$styleEffector].dispose();\n            this[$styleEffector] = null;\n          }\n        }\n      }\n    });\n  };\n};","map":{"version":3,"sources":["../src/decorators.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {UpdatingElement} from 'lit-element/lib/updating-element';\nimport {EvaluatedStyle, Intrinsics, StyleEvaluator} from './styles/evaluators';\nimport {parseExpressions, Unit} from './styles/parsers';\nimport {StyleEffector} from './styles/style-effector';\n\n// An IntrinsicsFactory generates up-to-date intrinsics for a given ModelViewer\n// element instance when it is invoked.\nexport type IntrinsicsFactory<T extends Intrinsics<Array<Unit>>,\n                                        U extends UpdatingElement> =\n    (element: U) => T;\n\n// When applying the @style decorator, it needs to be configured with\n// corresponding Intrinsics and the property key of a method to receive updated\n// values. Optionally, it can also be configured to observe environment effects,\n// which causes a StyleEffector to be created for the property.\nexport interface StyleDecoratorConfig<T extends Intrinsics<Array<Unit>>,\n                                                U extends UpdatingElement> {\n  intrinsics: T|IntrinsicsFactory<T, U>;\n  updateHandler: symbol;\n  observeEffects?: boolean;\n}\n\n/**\n * The @style decorator is responsible for coordinating the conversion of a\n * CSS-like string property value into numbers that can be applied to\n * lower-level constructs. It also can optionally manage the lifecycle of a\n * StyleEffector which allows automatic updates for styles that use env() or\n * var() functions.\n *\n * The decorator is configured with Intrinsics and the property key for a\n * method that handles updates. The named update handler is invoked with the\n * result of parsing and evaluating the raw property string value. The format of\n * the evaluated result is derived from the basis of the configured Intrinsics,\n * and is always an array of numbers of fixed length.\n *\n * NOTE: This decorator depends on the property updating mechanism defined by\n * UpdatingElement as exported by the lit-element module. That means it *must*\n * be used in conjunction with the @property decorator, or equivalent\n * JavaScript.\n *\n * Supported configurations are:\n *\n *  - `intrinsics`: An Intrinsics struct that describes how to interpret a\n * serialized style attribute. For more detail on intrinsics see\n * ./styles/evaluators.ts\n *  - `updateHandler`: A string or Symbol that is the key of a method to be\n * invoked with the result of parsing and evaluating a serialized style string.\n *  - `observeEffects`: Optional, if set to true then styles that use env() will\n * cause their update handlers to be invoked every time the corresponding\n * environment variable changes (even if the style attribute itself remains\n * static).\n */\nexport const style =\n    <T extends Intrinsics<Array<Unit>>, U extends UpdatingElement>(\n        config: StyleDecoratorConfig<T, U>) => {\n      const observeEffects: boolean = config.observeEffects || false;\n      const getIntrinsics = config.intrinsics instanceof Function ?\n          config.intrinsics :\n          (() => config.intrinsics) as IntrinsicsFactory<T, U>;\n\n      return <U extends typeof UpdatingElement['prototype']>(\n                 proto: U, propertyName: string) => {\n        const originalUpdated = (proto as any).updated;\n        const originalConnectedCallback = proto.connectedCallback;\n        const originalDisconnectedCallback = proto.disconnectedCallback;\n\n        const $styleEffector = Symbol(`${propertyName}StyleEffector`);\n        const $styleEvaluator = Symbol(`${propertyName}StyleEvaluator`);\n        const $updateEvaluator = Symbol(`${propertyName}UpdateEvaluator`);\n        const $evaluateAndSync = Symbol(`${propertyName}EvaluateAndSync`);\n\n        Object.defineProperties(proto, {\n          [$styleEffector]:\n              {value: null as StyleEffector | null, writable: true},\n          [$styleEvaluator]:\n              {value: null as StyleEvaluator<T>| null, writable: true},\n\n          [$updateEvaluator]: {\n            value: function() {\n              const ast = parseExpressions(\n                  this[propertyName as keyof UpdatingElement] as string);\n              this[$styleEvaluator] =\n                  new StyleEvaluator(ast, getIntrinsics(this));\n\n              if (this[$styleEffector] == null && observeEffects) {\n                this[$styleEffector] =\n                    new StyleEffector(() => this[$evaluateAndSync]());\n              }\n\n              if (this[$styleEffector] != null) {\n                this[$styleEffector].observeEffectsFor(ast);\n              }\n            }\n          },\n\n          [$evaluateAndSync]: {\n            value: function() {\n              if (this[$styleEvaluator] == null) {\n                return;\n              }\n\n              const result = this[$styleEvaluator].evaluate();\n\n              // @see https://github.com/microsoft/TypeScript/pull/30769\n              // @see https://github.com/Microsoft/TypeScript/issues/1863\n              (this as unknown as Record<\n                   string,\n                   (style: EvaluatedStyle<T>) =>\n                       void>)[config.updateHandler as unknown as string](\n                  result);\n            }\n          },\n\n          updated: {\n            value: function(changedProperties: Map<string, any>) {\n              // Always invoke updates to styles first. This gives a class that\n              // uses this decorator the opportunity to override the effect, or\n              // respond to it, in its own implementation of `updated`.\n              if (changedProperties.has(propertyName)) {\n                this[$updateEvaluator]();\n                this[$evaluateAndSync]();\n              }\n\n              originalUpdated.call(this, changedProperties);\n            }\n          },\n\n          connectedCallback: {\n            value: function() {\n              originalConnectedCallback.call(this);\n              this.requestUpdate(propertyName, this[propertyName]);\n            }\n          },\n\n          disconnectedCallback: {\n            value: function() {\n              originalDisconnectedCallback.call(this);\n              if (this[$styleEffector] != null) {\n                this[$styleEffector].dispose();\n                this[$styleEffector] = null;\n              }\n            }\n          }\n        });\n      };\n    };"],"sourceRoot":""},"metadata":{},"sourceType":"module"}