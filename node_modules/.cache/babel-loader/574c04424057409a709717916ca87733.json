{"ast":null,"code":"/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a;\n\nimport { BackSide, DoubleSide, FrontSide, Mesh } from 'three';\nimport { RoughnessMipmapper } from 'three/examples/jsm/utils/RoughnessMipmapper.js';\nimport { $clone, $prepare, GLTFInstance } from '../GLTFInstance.js';\nimport { Renderer } from '../Renderer.js';\nimport { alphaChunk } from '../shader-chunk/alphatest_fragment.glsl.js';\nconst $roughnessMipmapper = Symbol('roughnessMipmapper');\nconst $cloneAndPatchMaterial = Symbol('cloneAndPatchMaterial');\n/**\n * This specialization of GLTFInstance collects all of the processing needed\n * to prepare a model and to clone it making special considerations for\n * <model-viewer> use cases.\n */\n\nexport class ModelViewerGLTFInstance extends GLTFInstance {\n  /**\n   * @override\n   */\n  static [(_a = $roughnessMipmapper, $prepare)](source) {\n    const prepared = super[$prepare](source);\n    const scene = prepared.scene;\n    const meshesToDuplicate = [];\n    scene.traverse(node => {\n      // Set a high renderOrder while we're here to ensure the model\n      // always renders on top of the skysphere\n      node.renderOrder = 1000; // Three.js seems to cull some animated models incorrectly. Since we\n      // expect to view our whole scene anyway, we turn off the frustum\n      // culling optimization here.\n\n      node.frustumCulled = false; // Animations for objects without names target their UUID instead. When\n      // objects are cloned, they get new UUIDs which the animation can't\n      // find. To fix this, we assign their UUID as their name.\n\n      if (!node.name) {\n        node.name = node.uuid;\n      }\n\n      if (!node.isMesh) {\n        return;\n      }\n\n      node.castShadow = true;\n      const mesh = node;\n      let transparent = false;\n      const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];\n      materials.forEach(material => {\n        if (material.isMeshStandardMaterial) {\n          if (material.transparent && material.side === DoubleSide) {\n            transparent = true;\n            material.side = FrontSide;\n          }\n\n          this[$roughnessMipmapper].generateMipmaps(material);\n        }\n      });\n\n      if (transparent) {\n        meshesToDuplicate.push(mesh);\n      }\n    }); // We duplicate transparent, double-sided meshes and render the back face\n    // before the front face. This creates perfect triangle sorting for all\n    // convex meshes. Sorting artifacts can still appear when you can see\n    // through more than two layers of a given mesh, but this can usually be\n    // mitigated by the author splitting the mesh into mostly convex regions.\n    // The performance cost is not too great as the same shader is reused and\n    // the same number of fragments are processed; only the vertex shader is run\n    // twice. @see https://threejs.org/examples/webgl_materials_physical_transparency.html\n\n    for (const mesh of meshesToDuplicate) {\n      const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];\n      const duplicateMaterials = materials.map(material => {\n        const backMaterial = material.clone();\n        backMaterial.side = BackSide;\n        return backMaterial;\n      });\n      const duplicateMaterial = Array.isArray(mesh.material) ? duplicateMaterials : duplicateMaterials[0];\n      const meshBack = new Mesh(mesh.geometry, duplicateMaterial);\n      meshBack.renderOrder = -1;\n      mesh.add(meshBack);\n    }\n\n    return prepared;\n  }\n  /**\n   * @override\n   */\n\n\n  [$clone]() {\n    const clone = super[$clone]();\n    const sourceUUIDToClonedMaterial = new Map();\n    clone.scene.traverse(node => {\n      // Materials aren't cloned when cloning meshes; geometry\n      // and materials are copied by reference. This is necessary\n      // for the same model to be used twice with different\n      // environment maps.\n      if (node.isMesh) {\n        const mesh = node;\n\n        if (Array.isArray(mesh.material)) {\n          mesh.material = mesh.material.map(material => this[$cloneAndPatchMaterial](material, sourceUUIDToClonedMaterial));\n        } else if (mesh.material != null) {\n          mesh.material = this[$cloneAndPatchMaterial](mesh.material, sourceUUIDToClonedMaterial);\n        }\n      }\n    });\n    return clone;\n  }\n  /**\n   * Creates a clone of the given material, and applies a patch to the\n   * shader program.\n   */\n\n\n  [$cloneAndPatchMaterial](material, sourceUUIDToClonedMaterial) {\n    // If we already cloned this material (determined by tracking the UUID of\n    // source materials that have been cloned), then return that previously\n    // cloned instance:\n    if (sourceUUIDToClonedMaterial.has(material.uuid)) {\n      return sourceUUIDToClonedMaterial.get(material.uuid);\n    }\n\n    const clone = material.clone(); // This allows us to patch three's materials, on top of patches already\n    // made, for instance GLTFLoader patches SpecularGlossiness materials.\n    // Unfortunately, three's program cache differentiates SpecGloss materials\n    // via onBeforeCompile.toString(), so these two functions do the same\n    // thing but look different in order to force a proper recompile.\n\n    const oldOnBeforeCompile = material.onBeforeCompile;\n    clone.onBeforeCompile = material.isGLTFSpecularGlossinessMaterial ? shader => {\n      oldOnBeforeCompile(shader, undefined);\n      shader.fragmentShader = shader.fragmentShader.replace('#include <alphatest_fragment>', alphaChunk);\n    } : shader => {\n      shader.fragmentShader = shader.fragmentShader.replace('#include <alphatest_fragment>', alphaChunk);\n      oldOnBeforeCompile(shader, undefined);\n    }; // This makes shadows better for non-manifold meshes\n\n    clone.shadowSide = FrontSide; // This improves transparent rendering and can be removed whenever\n    // https://github.com/mrdoob/three.js/pull/18235 finally lands.\n\n    if (clone.transparent) {\n      clone.depthWrite = false;\n    } // This little hack ignores alpha for opaque materials, in order to comply\n    // with the glTF spec.\n\n\n    if (!clone.alphaTest && !clone.transparent) {\n      clone.alphaTest = -0.5;\n    }\n\n    sourceUUIDToClonedMaterial.set(material.uuid, clone);\n    return clone;\n  }\n\n}\nModelViewerGLTFInstance[_a] = new RoughnessMipmapper(Renderer.singleton.threeRenderer);","map":{"version":3,"sources":["../../../src/three-components/gltf-instance/ModelViewerGLTFInstance.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {BackSide, DoubleSide, FrontSide, Material, Mesh, MeshStandardMaterial, Object3D, Shader} from 'three';\nimport {GLTF} from 'three/examples/jsm/loaders/GLTFLoader.js';\nimport {RoughnessMipmapper} from 'three/examples/jsm/utils/RoughnessMipmapper.js';\n\nimport {$clone, $prepare, GLTFInstance, PreparedGLTF} from '../GLTFInstance.js';\nimport {Renderer} from '../Renderer.js';\nimport {alphaChunk} from '../shader-chunk/alphatest_fragment.glsl.js';\n\n\nconst $roughnessMipmapper = Symbol('roughnessMipmapper');\nconst $cloneAndPatchMaterial = Symbol('cloneAndPatchMaterial');\n\n/**\n * This specialization of GLTFInstance collects all of the processing needed\n * to prepare a model and to clone it making special considerations for\n * <model-viewer> use cases.\n */\nexport class ModelViewerGLTFInstance extends GLTFInstance {\n  protected static[$roughnessMipmapper]: RoughnessMipmapper =\n      new RoughnessMipmapper(Renderer.singleton.threeRenderer);\n\n  /**\n   * @override\n   */\n  protected static[$prepare](source: GLTF) {\n    const prepared = super[$prepare](source);\n    const {scene} = prepared;\n\n    const meshesToDuplicate: Mesh[] = [];\n\n    scene.traverse((node: Object3D) => {\n      // Set a high renderOrder while we're here to ensure the model\n      // always renders on top of the skysphere\n      node.renderOrder = 1000;\n\n      // Three.js seems to cull some animated models incorrectly. Since we\n      // expect to view our whole scene anyway, we turn off the frustum\n      // culling optimization here.\n      node.frustumCulled = false;\n      // Animations for objects without names target their UUID instead. When\n      // objects are cloned, they get new UUIDs which the animation can't\n      // find. To fix this, we assign their UUID as their name.\n      if (!node.name) {\n        node.name = node.uuid;\n      }\n      if (!(node as Mesh).isMesh) {\n        return;\n      }\n      node.castShadow = true;\n      const mesh = node as Mesh;\n      let transparent = false;\n      const materials =\n          Array.isArray(mesh.material) ? mesh.material : [mesh.material];\n      materials.forEach(material => {\n        if ((material as any).isMeshStandardMaterial) {\n          if (material.transparent && material.side === DoubleSide) {\n            transparent = true;\n            material.side = FrontSide;\n          }\n          this[$roughnessMipmapper].generateMipmaps(\n              material as MeshStandardMaterial);\n        }\n      });\n\n      if (transparent) {\n        meshesToDuplicate.push(mesh);\n      }\n    });\n\n    // We duplicate transparent, double-sided meshes and render the back face\n    // before the front face. This creates perfect triangle sorting for all\n    // convex meshes. Sorting artifacts can still appear when you can see\n    // through more than two layers of a given mesh, but this can usually be\n    // mitigated by the author splitting the mesh into mostly convex regions.\n    // The performance cost is not too great as the same shader is reused and\n    // the same number of fragments are processed; only the vertex shader is run\n    // twice. @see https://threejs.org/examples/webgl_materials_physical_transparency.html\n    for (const mesh of meshesToDuplicate) {\n      const materials =\n          Array.isArray(mesh.material) ? mesh.material : [mesh.material];\n      const duplicateMaterials = materials.map((material) => {\n        const backMaterial = material.clone();\n        backMaterial.side = BackSide;\n        return backMaterial;\n      });\n      const duplicateMaterial = Array.isArray(mesh.material) ?\n          duplicateMaterials :\n          duplicateMaterials[0];\n      const meshBack = new Mesh(mesh.geometry, duplicateMaterial);\n      meshBack.renderOrder = -1;\n      mesh.add(meshBack);\n    }\n\n    return prepared;\n  }\n\n  /**\n   * @override\n   */\n  [$clone](): PreparedGLTF {\n    const clone = super[$clone]();\n    const sourceUUIDToClonedMaterial = new Map<string, Material>();\n\n    clone.scene.traverse((node: any) => {\n      // Materials aren't cloned when cloning meshes; geometry\n      // and materials are copied by reference. This is necessary\n      // for the same model to be used twice with different\n      // environment maps.\n      if ((node as Mesh).isMesh) {\n        const mesh = node as Mesh;\n        if (Array.isArray(mesh.material)) {\n          mesh.material = mesh.material.map(\n              (material) => this[$cloneAndPatchMaterial](\n                  material, sourceUUIDToClonedMaterial));\n        } else if (mesh.material != null) {\n          mesh.material = this[$cloneAndPatchMaterial](\n              mesh.material, sourceUUIDToClonedMaterial);\n        }\n      }\n    });\n\n    return clone;\n  }\n\n  /**\n   * Creates a clone of the given material, and applies a patch to the\n   * shader program.\n   */\n  [$cloneAndPatchMaterial](\n      material: Material, sourceUUIDToClonedMaterial: Map<string, Material>) {\n    // If we already cloned this material (determined by tracking the UUID of\n    // source materials that have been cloned), then return that previously\n    // cloned instance:\n    if (sourceUUIDToClonedMaterial.has(material.uuid)) {\n      return sourceUUIDToClonedMaterial.get(material.uuid)!;\n    }\n\n    const clone = material.clone();\n\n    // This allows us to patch three's materials, on top of patches already\n    // made, for instance GLTFLoader patches SpecularGlossiness materials.\n    // Unfortunately, three's program cache differentiates SpecGloss materials\n    // via onBeforeCompile.toString(), so these two functions do the same\n    // thing but look different in order to force a proper recompile.\n    const oldOnBeforeCompile = material.onBeforeCompile;\n    clone.onBeforeCompile = (material as any).isGLTFSpecularGlossinessMaterial ?\n        (shader: Shader) => {\n          oldOnBeforeCompile(shader, undefined as any);\n          shader.fragmentShader = shader.fragmentShader.replace(\n              '#include <alphatest_fragment>', alphaChunk);\n        } :\n        (shader: Shader) => {\n          shader.fragmentShader = shader.fragmentShader.replace(\n              '#include <alphatest_fragment>', alphaChunk);\n          oldOnBeforeCompile(shader, undefined as any);\n        };\n    // This makes shadows better for non-manifold meshes\n    clone.shadowSide = FrontSide;\n    // This improves transparent rendering and can be removed whenever\n    // https://github.com/mrdoob/three.js/pull/18235 finally lands.\n    if (clone.transparent) {\n      clone.depthWrite = false;\n    }\n    // This little hack ignores alpha for opaque materials, in order to comply\n    // with the glTF spec.\n    if (!clone.alphaTest && !clone.transparent) {\n      clone.alphaTest = -0.5;\n    }\n\n    sourceUUIDToClonedMaterial.set(material.uuid, clone);\n\n    return clone;\n  }\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}