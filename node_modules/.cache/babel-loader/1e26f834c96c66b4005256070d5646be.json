{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Box3, DirectionalLight, Mesh, PlaneBufferGeometry, ShadowMaterial, Vector3 } from 'three'; // Nothing within Offset of the bottom of the model casts a shadow\n// (this is to avoid having a baked-in shadow plane cast its own shadow).\n\nconst OFFSET = 0.001; // The softness [0, 1] of the shadow is mapped to a resolution between\n// 2^LOG_MAX_RESOLUTION and 2^LOG_MIN_RESOLUTION.\n\nconst LOG_MAX_RESOLUTION = 9;\nconst LOG_MIN_RESOLUTION = 6; // Animated models are not in general contained in their bounding box, as this\n// is calculated only for their resting pose. We create a cubic shadow volume\n// for animated models sized to their largest bounding box dimesion multiplied\n// by this scale factor.\n\nconst ANIMATION_SCALING = 2;\n/**\n * The Shadow class creates a shadow that fits a given model and follows a\n * target. This shadow will follow the model without any updates needed so long\n * as the shadow and model are both parented to the same object (call it the\n * scene) and this scene is passed as the target parameter to the shadow's\n * constructor. We also must constrain the scene to motion within the horizontal\n * plane and call the setRotation() method whenever the model's Y-axis rotation\n * changes. For motion outside of the horizontal plane, this.needsUpdate must be\n * set to true.\n *\n * The softness of the shadow is controlled by changing its resolution, making\n * softer shadows faster, but less precise.\n */\n\nexport class Shadow extends DirectionalLight {\n  constructor(model, softness) {\n    super();\n    this.shadowMaterial = new ShadowMaterial();\n    this.boundingBox = new Box3();\n    this.size = new Vector3();\n    this.isAnimated = false;\n    this.needsUpdate = false; // We use the light only to cast a shadow, not to light the scene.\n\n    this.intensity = 0;\n    this.castShadow = true;\n    this.frustumCulled = false;\n    this.floor = new Mesh(new PlaneBufferGeometry(), this.shadowMaterial);\n    this.floor.rotateX(-Math.PI / 2);\n    this.floor.receiveShadow = true;\n    this.floor.castShadow = false;\n    this.floor.frustumCulled = false;\n    this.add(this.floor);\n    this.shadow.camera.up.set(0, 0, 1);\n    model.add(this);\n    this.target = model;\n    this.setModel(model, softness);\n  }\n  /**\n   * Update the shadow's size and position for a new model. Softness is also\n   * needed, as this controls the shadow's resolution.\n   */\n\n\n  setModel(model, softness) {\n    this.isAnimated = model.animationNames.length > 0;\n    this.boundingBox.copy(model.boundingBox);\n    this.size.copy(model.size);\n    const boundingBox = this.boundingBox,\n          size = this.size;\n\n    if (this.isAnimated) {\n      const maxDimension = Math.max(size.x, size.y, size.z) * ANIMATION_SCALING;\n      size.y = maxDimension;\n      boundingBox.expandByVector(size.subScalar(maxDimension).multiplyScalar(-0.5));\n      boundingBox.max.y = boundingBox.min.y + maxDimension;\n      size.set(maxDimension, maxDimension, maxDimension);\n    }\n\n    const shadowOffset = size.y * OFFSET;\n    this.position.y = boundingBox.max.y + shadowOffset;\n    boundingBox.getCenter(this.floor.position);\n    this.setSoftness(softness);\n  }\n  /**\n   * Update the shadow's resolution based on softness (between 0 and 1). Should\n   * not be called frequently, as this results in reallocation.\n   */\n\n\n  setSoftness(softness) {\n    const resolution = Math.pow(2, LOG_MAX_RESOLUTION - softness * (LOG_MAX_RESOLUTION - LOG_MIN_RESOLUTION));\n    this.setMapSize(resolution);\n  }\n  /**\n   * Lower-level version of the above function.\n   */\n\n\n  setMapSize(maxMapSize) {\n    const _this$shadow = this.shadow,\n          camera = _this$shadow.camera,\n          mapSize = _this$shadow.mapSize,\n          map = _this$shadow.map;\n    const size = this.size,\n          boundingBox = this.boundingBox;\n\n    if (map != null) {\n      map.dispose();\n      this.shadow.map = null;\n    }\n\n    if (this.isAnimated) {\n      maxMapSize *= ANIMATION_SCALING;\n    }\n\n    const width = Math.floor(size.x > size.z ? maxMapSize : maxMapSize * size.x / size.z);\n    const height = Math.floor(size.x > size.z ? maxMapSize * size.z / size.x : maxMapSize);\n    mapSize.set(width, height); // These pads account for the softening radius around the shadow.\n\n    const widthPad = 2.5 * size.x / width;\n    const heightPad = 2.5 * size.z / height;\n    camera.left = -boundingBox.max.x - widthPad;\n    camera.right = -boundingBox.min.x + widthPad;\n    camera.bottom = boundingBox.min.z - heightPad;\n    camera.top = boundingBox.max.z + heightPad;\n    this.setScaleAndOffset(camera.zoom, 0);\n    this.shadow.updateMatrices(this);\n    this.floor.scale.set(size.x + 2 * widthPad, size.z + 2 * heightPad, 1);\n    this.needsUpdate = true;\n  }\n  /**\n   * Set the shadow's intensity (0 to 1), which is just its opacity. Turns off\n   * shadow rendering if zero.\n   */\n\n\n  setIntensity(intensity) {\n    this.shadowMaterial.opacity = intensity;\n\n    if (intensity > 0) {\n      this.visible = true;\n      this.floor.visible = true;\n    } else {\n      this.visible = false;\n      this.floor.visible = false;\n    }\n  }\n\n  getIntensity() {\n    return this.shadowMaterial.opacity;\n  }\n  /**\n   * The shadow does not rotate with its parent transforms, so the rotation must\n   * be manually updated here if it rotates in world space. The input is its\n   * absolute orientation about the Y-axis (other rotations are not supported).\n   */\n\n\n  setRotation(radiansY) {\n    this.shadow.camera.up.set(Math.sin(radiansY), 0, Math.cos(radiansY));\n    this.shadow.updateMatrices(this);\n  }\n  /**\n   * The scale is also not inherited from parents, so it must be set here in\n   * accordance with any transforms. An offset can also be specified to move the\n   * shadow vertically relative to the bottom of the model. Positive is up, so\n   * values are generally negative.\n   */\n\n\n  setScaleAndOffset(scale, offset) {\n    const sizeY = this.size.y;\n    const inverseScale = 1 / scale; // Floor plane is up slightly from the bottom of the bounding box to avoid\n    // Z-fighting with baked-in shadows and to stay inside the shadow camera.\n\n    const shadowOffset = sizeY * OFFSET;\n    this.floor.position.y = 2 * shadowOffset - sizeY + offset * inverseScale;\n    const camera = this.shadow.camera;\n    camera.zoom = scale;\n    camera.near = 0;\n    camera.far = sizeY * scale - offset;\n    camera.projectionMatrix.makeOrthographic(camera.left * scale, camera.right * scale, camera.top * scale, camera.bottom * scale, camera.near, camera.far);\n    camera.projectionMatrixInverse.getInverse(camera.projectionMatrix);\n  }\n\n}","map":{"version":3,"sources":["../../src/three-components/Shadow.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Box3, DirectionalLight, Mesh, PlaneBufferGeometry, ShadowMaterial, Vector3} from 'three';\n\nimport Model from './Model';\n\n// Nothing within Offset of the bottom of the model casts a shadow\n// (this is to avoid having a baked-in shadow plane cast its own shadow).\nconst OFFSET = 0.001;\n// The softness [0, 1] of the shadow is mapped to a resolution between\n// 2^LOG_MAX_RESOLUTION and 2^LOG_MIN_RESOLUTION.\nconst LOG_MAX_RESOLUTION = 9;\nconst LOG_MIN_RESOLUTION = 6;\n// Animated models are not in general contained in their bounding box, as this\n// is calculated only for their resting pose. We create a cubic shadow volume\n// for animated models sized to their largest bounding box dimesion multiplied\n// by this scale factor.\nconst ANIMATION_SCALING = 2;\n\n/**\n * The Shadow class creates a shadow that fits a given model and follows a\n * target. This shadow will follow the model without any updates needed so long\n * as the shadow and model are both parented to the same object (call it the\n * scene) and this scene is passed as the target parameter to the shadow's\n * constructor. We also must constrain the scene to motion within the horizontal\n * plane and call the setRotation() method whenever the model's Y-axis rotation\n * changes. For motion outside of the horizontal plane, this.needsUpdate must be\n * set to true.\n *\n * The softness of the shadow is controlled by changing its resolution, making\n * softer shadows faster, but less precise.\n */\nexport class Shadow extends DirectionalLight {\n  private shadowMaterial = new ShadowMaterial;\n  private floor: Mesh;\n  private boundingBox = new Box3;\n  private size = new Vector3;\n  private isAnimated = false;\n  public needsUpdate = false;\n\n  constructor(model: Model, softness: number) {\n    super();\n\n    // We use the light only to cast a shadow, not to light the scene.\n    this.intensity = 0;\n    this.castShadow = true;\n    this.frustumCulled = false;\n\n    this.floor = new Mesh(new PlaneBufferGeometry, this.shadowMaterial);\n    this.floor.rotateX(-Math.PI / 2);\n    this.floor.receiveShadow = true;\n    this.floor.castShadow = false;\n    this.floor.frustumCulled = false;\n    this.add(this.floor);\n\n    this.shadow.camera.up.set(0, 0, 1);\n\n    model.add(this);\n    this.target = model;\n\n    this.setModel(model, softness);\n  }\n\n  /**\n   * Update the shadow's size and position for a new model. Softness is also\n   * needed, as this controls the shadow's resolution.\n   */\n  setModel(model: Model, softness: number) {\n    this.isAnimated = model.animationNames.length > 0;\n    this.boundingBox.copy(model.boundingBox);\n    this.size.copy(model.size);\n    const {boundingBox, size} = this;\n\n    if (this.isAnimated) {\n      const maxDimension = Math.max(size.x, size.y, size.z) * ANIMATION_SCALING;\n      size.y = maxDimension;\n      boundingBox.expandByVector(\n          size.subScalar(maxDimension).multiplyScalar(-0.5));\n      boundingBox.max.y = boundingBox.min.y + maxDimension;\n      size.set(maxDimension, maxDimension, maxDimension);\n    }\n\n    const shadowOffset = size.y * OFFSET;\n    this.position.y = boundingBox.max.y + shadowOffset;\n    boundingBox.getCenter(this.floor.position);\n\n    this.setSoftness(softness);\n  }\n\n  /**\n   * Update the shadow's resolution based on softness (between 0 and 1). Should\n   * not be called frequently, as this results in reallocation.\n   */\n  setSoftness(softness: number) {\n    const resolution = Math.pow(\n        2,\n        LOG_MAX_RESOLUTION -\n            softness * (LOG_MAX_RESOLUTION - LOG_MIN_RESOLUTION));\n    this.setMapSize(resolution);\n  }\n\n  /**\n   * Lower-level version of the above function.\n   */\n  setMapSize(maxMapSize: number) {\n    const {camera, mapSize, map} = this.shadow;\n    const {size, boundingBox} = this;\n\n    if (map != null) {\n      (map as any).dispose();\n      (this.shadow.map as any) = null;\n    }\n\n    if (this.isAnimated) {\n      maxMapSize *= ANIMATION_SCALING;\n    }\n\n    const width =\n        Math.floor(size.x > size.z ? maxMapSize : maxMapSize * size.x / size.z);\n    const height =\n        Math.floor(size.x > size.z ? maxMapSize * size.z / size.x : maxMapSize);\n\n    mapSize.set(width, height);\n    // These pads account for the softening radius around the shadow.\n    const widthPad = 2.5 * size.x / width;\n    const heightPad = 2.5 * size.z / height;\n\n    camera.left = -boundingBox.max.x - widthPad;\n    camera.right = -boundingBox.min.x + widthPad;\n    camera.bottom = boundingBox.min.z - heightPad;\n    camera.top = boundingBox.max.z + heightPad;\n\n    this.setScaleAndOffset(camera.zoom, 0);\n    this.shadow.updateMatrices(this);\n\n    this.floor.scale.set(size.x + 2 * widthPad, size.z + 2 * heightPad, 1);\n    this.needsUpdate = true;\n  }\n\n  /**\n   * Set the shadow's intensity (0 to 1), which is just its opacity. Turns off\n   * shadow rendering if zero.\n   */\n  setIntensity(intensity: number) {\n    this.shadowMaterial.opacity = intensity;\n    if (intensity > 0) {\n      this.visible = true;\n      this.floor.visible = true;\n    } else {\n      this.visible = false;\n      this.floor.visible = false;\n    }\n  }\n\n  getIntensity(): number {\n    return this.shadowMaterial.opacity;\n  }\n\n  /**\n   * The shadow does not rotate with its parent transforms, so the rotation must\n   * be manually updated here if it rotates in world space. The input is its\n   * absolute orientation about the Y-axis (other rotations are not supported).\n   */\n  setRotation(radiansY: number) {\n    this.shadow.camera.up.set(Math.sin(radiansY), 0, Math.cos(radiansY));\n    this.shadow.updateMatrices(this);\n  }\n\n  /**\n   * The scale is also not inherited from parents, so it must be set here in\n   * accordance with any transforms. An offset can also be specified to move the\n   * shadow vertically relative to the bottom of the model. Positive is up, so\n   * values are generally negative.\n   */\n  setScaleAndOffset(scale: number, offset: number) {\n    const sizeY = this.size.y;\n    const inverseScale = 1 / scale;\n    // Floor plane is up slightly from the bottom of the bounding box to avoid\n    // Z-fighting with baked-in shadows and to stay inside the shadow camera.\n    const shadowOffset = sizeY * OFFSET;\n    this.floor.position.y = 2 * shadowOffset - sizeY + offset * inverseScale;\n    const {camera} = this.shadow;\n    camera.zoom = scale;\n    camera.near = 0;\n    camera.far = sizeY * scale - offset;\n\n    camera.projectionMatrix.makeOrthographic(\n        camera.left * scale,\n        camera.right * scale,\n        camera.top * scale,\n        camera.bottom * scale,\n        camera.near,\n        camera.far);\n    camera.projectionMatrixInverse.getInverse(camera.projectionMatrix);\n  }\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}