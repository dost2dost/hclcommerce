{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { property } from 'lit-element';\nimport { $needsRender, $onModelLoad, $renderer, $scene, $tick, $updateSource } from '../model-viewer-base.js';\nconst MILLISECONDS_PER_SECOND = 1000.0;\nconst $changeAnimation = Symbol('changeAnimation');\nconst $paused = Symbol('paused');\nexport const AnimationMixin = ModelViewerElement => {\n  var _a;\n\n  class AnimationModelViewerElement extends ModelViewerElement {\n    constructor() {\n      super(...arguments);\n      this.autoplay = false;\n      this.animationName = undefined;\n      this.animationCrossfadeDuration = 300;\n      this[_a] = true;\n    }\n    /**\n     * Returns an array\n     */\n\n\n    get availableAnimations() {\n      if (this.loaded) {\n        return this[$scene].model.animationNames;\n      }\n\n      return [];\n    }\n\n    get paused() {\n      return this[$paused];\n    }\n\n    get currentTime() {\n      return this[$scene].model.animationTime;\n    }\n\n    set currentTime(value) {\n      this[$scene].model.animationTime = value;\n      this[$renderer].threeRenderer.shadowMap.needsUpdate = true;\n      this[$needsRender]();\n    }\n\n    pause() {\n      if (this[$paused]) {\n        return;\n      }\n\n      this[$paused] = true;\n      this[$renderer].threeRenderer.shadowMap.autoUpdate = false;\n      this.dispatchEvent(new CustomEvent('pause'));\n    }\n\n    play() {\n      if (this[$paused] && this.availableAnimations.length > 0) {\n        this[$paused] = false;\n        this[$renderer].threeRenderer.shadowMap.autoUpdate = true;\n\n        if (!this[$scene].model.hasActiveAnimation) {\n          this[$changeAnimation]();\n        }\n\n        this.dispatchEvent(new CustomEvent('play'));\n      }\n    }\n\n    [(_a = $paused, $onModelLoad)]() {\n      this[$paused] = true;\n\n      if (this.autoplay) {\n        this[$changeAnimation]();\n        this.play();\n      }\n    }\n\n    [$tick](_time, delta) {\n      super[$tick](_time, delta);\n\n      if (this[$paused]) {\n        return;\n      }\n\n      const model = this[$scene].model;\n      model.updateAnimation(delta / MILLISECONDS_PER_SECOND);\n      this[$needsRender]();\n    }\n\n    updated(changedProperties) {\n      super.updated(changedProperties);\n\n      if (changedProperties.has('autoplay') && this.autoplay) {\n        this.play();\n      }\n\n      if (changedProperties.has('animationName')) {\n        this[$changeAnimation]();\n      }\n    }\n\n    async [$updateSource]() {\n      // If we are loading a new model, we need to stop the animation of\n      // the current one (if any is playing). Otherwise, we might lose\n      // the reference to the scene root and running actions start to\n      // throw exceptions and/or behave in unexpected ways:\n      this[$scene].model.stopAnimation();\n      return super[$updateSource]();\n    }\n\n    [$changeAnimation]() {\n      const model = this[$scene].model;\n      model.playAnimation(this.animationName, this.animationCrossfadeDuration / MILLISECONDS_PER_SECOND); // If we are currently paused, we need to force a render so that\n      // the model updates to the first frame of the new animation\n\n      if (this[$paused]) {\n        model.updateAnimation(0);\n        this[$needsRender]();\n      }\n    }\n\n  }\n\n  __decorate([property({\n    type: Boolean\n  })], AnimationModelViewerElement.prototype, \"autoplay\", void 0);\n\n  __decorate([property({\n    type: String,\n    attribute: 'animation-name'\n  })], AnimationModelViewerElement.prototype, \"animationName\", void 0);\n\n  __decorate([property({\n    type: Number,\n    attribute: 'animation-crossfade-duration'\n  })], AnimationModelViewerElement.prototype, \"animationCrossfadeDuration\", void 0);\n\n  return AnimationModelViewerElement;\n};","map":{"version":3,"sources":["../../src/features/animation.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {property} from 'lit-element';\n\nimport ModelViewerElementBase, {$needsRender, $onModelLoad, $renderer, $scene, $tick, $updateSource} from '../model-viewer-base.js';\nimport {Constructor} from '../utilities.js';\n\nconst MILLISECONDS_PER_SECOND = 1000.0\n\nconst $changeAnimation = Symbol('changeAnimation');\nconst $paused = Symbol('paused');\n\nexport declare interface AnimationInterface {\n  autoplay: boolean;\n  animationName: string|void;\n  animationCrossfadeDuration: number;\n  readonly availableAnimations: Array<string>;\n  readonly paused: boolean;\n  currentTime: number;\n  pause(): void;\n  play(): void;\n}\n\nexport const AnimationMixin = <T extends Constructor<ModelViewerElementBase>>(\n    ModelViewerElement: T): Constructor<AnimationInterface>&T => {\n  class AnimationModelViewerElement extends ModelViewerElement {\n    @property({type: Boolean}) autoplay: boolean = false;\n    @property({type: String, attribute: 'animation-name'})\n    animationName: string|undefined = undefined;\n    @property({type: Number, attribute: 'animation-crossfade-duration'})\n    animationCrossfadeDuration: number = 300;\n\n    protected[$paused]: boolean = true;\n\n    /**\n     * Returns an array\n     */\n    get availableAnimations(): Array<string> {\n      if (this.loaded) {\n        return this[$scene].model.animationNames;\n      }\n\n      return [];\n    }\n\n    get paused(): boolean {\n      return this[$paused];\n    }\n\n    get currentTime(): number {\n      return this[$scene].model.animationTime;\n    }\n\n    set currentTime(value: number) {\n      this[$scene].model.animationTime = value;\n      this[$renderer].threeRenderer.shadowMap.needsUpdate = true;\n      this[$needsRender]();\n    }\n\n    pause() {\n      if (this[$paused]) {\n        return;\n      }\n\n      this[$paused] = true;\n      this[$renderer].threeRenderer.shadowMap.autoUpdate = false;\n      this.dispatchEvent(new CustomEvent('pause'));\n    }\n\n    play() {\n      if (this[$paused] && this.availableAnimations.length > 0) {\n        this[$paused] = false;\n        this[$renderer].threeRenderer.shadowMap.autoUpdate = true;\n\n        if (!this[$scene].model.hasActiveAnimation) {\n          this[$changeAnimation]();\n        }\n\n        this.dispatchEvent(new CustomEvent('play'));\n      }\n    }\n\n    [$onModelLoad]() {\n      this[$paused] = true;\n\n      if (this.autoplay) {\n        this[$changeAnimation]();\n        this.play();\n      }\n    }\n\n    [$tick](_time: number, delta: number) {\n      super[$tick](_time, delta);\n\n      if (this[$paused]) {\n        return;\n      }\n\n      const {model} = this[$scene];\n      model.updateAnimation(delta / MILLISECONDS_PER_SECOND);\n\n      this[$needsRender]();\n    }\n\n    updated(changedProperties: Map<string, any>) {\n      super.updated(changedProperties);\n\n      if (changedProperties.has('autoplay') && this.autoplay) {\n        this.play();\n      }\n\n      if (changedProperties.has('animationName')) {\n        this[$changeAnimation]();\n      }\n    }\n\n    async[$updateSource]() {\n      // If we are loading a new model, we need to stop the animation of\n      // the current one (if any is playing). Otherwise, we might lose\n      // the reference to the scene root and running actions start to\n      // throw exceptions and/or behave in unexpected ways:\n      this[$scene].model.stopAnimation();\n\n      return super[$updateSource]();\n    }\n\n    [$changeAnimation]() {\n      const {model} = this[$scene];\n\n      model.playAnimation(\n          this.animationName,\n          this.animationCrossfadeDuration / MILLISECONDS_PER_SECOND);\n\n      // If we are currently paused, we need to force a render so that\n      // the model updates to the first frame of the new animation\n      if (this[$paused]) {\n        model.updateAnimation(0);\n        this[$needsRender]();\n      }\n    }\n  }\n\n  return AnimationModelViewerElement;\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}