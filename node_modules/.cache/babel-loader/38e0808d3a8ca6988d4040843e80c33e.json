{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b, _c, _d;\n\nimport { ASTWalker } from './parsers';\nconst $instances = Symbol('instances');\nconst $activateListener = Symbol('activateListener');\nconst $deactivateListener = Symbol('deactivateListener');\nconst $notifyInstances = Symbol('notifyInstances');\nconst $notify = Symbol('notify');\nconst $scrollCallback = Symbol('callback');\n/**\n * This internal helper is intended to work as a reference-counting manager of\n * scroll event listeners. Only one scroll listener is ever registered for all\n * instances of the class, and when the last ScrollObserver \"disconnects\", that\n * event listener is removed. This spares us from thrashing\n * the {add,remove}EventListener API (the binding cost of these methods has been\n * known to show up in performance anlyses) as well as potential memory leaks.\n */\n\nclass ScrollObserver {\n  constructor(callback) {\n    this[$scrollCallback] = callback;\n  }\n\n  static [$notifyInstances]() {\n    for (const instance of ScrollObserver[$instances]) {\n      instance[$notify]();\n    }\n  }\n\n  static [(_a = $instances, $activateListener)]() {\n    window.addEventListener('scroll', this[$notifyInstances], {\n      passive: true\n    });\n  }\n\n  static [$deactivateListener]() {\n    window.removeEventListener('scroll', this[$notifyInstances]);\n  }\n  /**\n   * Listen for scroll events. The configured callback (passed to the\n   * constructor) will be invoked for subsequent global scroll events.\n   */\n\n\n  observe() {\n    if (ScrollObserver[$instances].size === 0) {\n      ScrollObserver[$activateListener]();\n    }\n\n    ScrollObserver[$instances].add(this);\n  }\n  /**\n   * Stop listening for scroll events.\n   */\n\n\n  disconnect() {\n    ScrollObserver[$instances].delete(this);\n\n    if (ScrollObserver[$instances].size === 0) {\n      ScrollObserver[$deactivateListener]();\n    }\n  }\n\n  [$notify]() {\n    this[$scrollCallback]();\n  }\n\n}\n\nScrollObserver[_a] = new Set();\nconst $computeStyleCallback = Symbol('computeStyleCallback');\nconst $astWalker = Symbol('astWalker');\nconst $dependencies = Symbol('dependencies');\nconst $scrollHandler = Symbol('scrollHandler');\nconst $onScroll = Symbol('onScroll');\n/**\n * The StyleEffector is configured with a callback that will be invoked at the\n * optimal time that some array of CSS expression ASTs ought to be evaluated.\n *\n * For example, our CSS-like expression syntax supports usage of the env()\n * function to incorporate the current top-level scroll position into a CSS\n * expression: env(window-scroll-y).\n *\n * This \"environment variable\" will change dynamically as the user scrolls the\n * page. If an AST contains such a usage of env(), we would have to evaluate the\n * AST on every frame in order to be sure that the computed style stays up to\n * date.\n *\n * The StyleEffector spares us from evaluating the expressions on every frame by\n * correlating specific parts of an AST with observers of the external effects\n * that they refer to (if any). So, if the AST contains env(window-scroll-y),\n * the StyleEffector manages the lifetime of a global scroll event listener and\n * notifies the user at the optimal time to evaluate the computed style.\n */\n\nexport class StyleEffector {\n  constructor(callback) {\n    this[_b] = {};\n    this[_c] = new ASTWalker(['function']);\n\n    this[_d] = () => this[$onScroll]();\n\n    this[$computeStyleCallback] = callback;\n  }\n  /**\n   * Sets the expressions that govern when the StyleEffector callback will be\n   * invoked.\n   */\n\n\n  observeEffectsFor(ast) {\n    const newDependencies = {};\n    const oldDependencies = this[$dependencies];\n    this[$astWalker].walk(ast, functionNode => {\n      const name = functionNode.name;\n      const firstArgument = functionNode.arguments[0];\n      const firstTerm = firstArgument.terms[0];\n\n      if (name.value !== 'env' || firstTerm == null || firstTerm.type !== 'ident') {\n        return;\n      }\n\n      switch (firstTerm.value) {\n        case 'window-scroll-y':\n          if (newDependencies['window-scroll'] == null) {\n            const observer = 'window-scroll' in oldDependencies ? oldDependencies['window-scroll'] : new ScrollObserver(this[$scrollHandler]);\n            observer.observe();\n            delete oldDependencies['window-scroll'];\n            newDependencies['window-scroll'] = observer;\n          }\n\n          break;\n      }\n    });\n\n    for (const environmentState in oldDependencies) {\n      const observer = oldDependencies[environmentState];\n      observer.disconnect();\n    }\n\n    this[$dependencies] = newDependencies;\n  }\n  /**\n   * Disposes of the StyleEffector by disconnecting all observers of external\n   * effects.\n   */\n\n\n  dispose() {\n    for (const environmentState in this[$dependencies]) {\n      const observer = this[$dependencies][environmentState];\n      observer.disconnect();\n    }\n  }\n\n  [(_b = $dependencies, _c = $astWalker, _d = $scrollHandler, $onScroll)]() {\n    this[$computeStyleCallback]({\n      relatedState: 'window-scroll'\n    });\n  }\n\n}","map":{"version":3,"sources":["../../src/styles/style-effector.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {ASTWalker, ExpressionNode, FunctionNode} from './parsers';\n\ninterface AnyObserver {\n  observe(): void;\n  disconnect(): void;\n}\n\nconst $instances = Symbol('instances');\nconst $activateListener = Symbol('activateListener');\nconst $deactivateListener = Symbol('deactivateListener');\nconst $notifyInstances = Symbol('notifyInstances');\nconst $notify = Symbol('notify');\nconst $scrollCallback = Symbol('callback');\n\ntype ScrollObserverCallback = () => void;\n\n/**\n * This internal helper is intended to work as a reference-counting manager of\n * scroll event listeners. Only one scroll listener is ever registered for all\n * instances of the class, and when the last ScrollObserver \"disconnects\", that\n * event listener is removed. This spares us from thrashing\n * the {add,remove}EventListener API (the binding cost of these methods has been\n * known to show up in performance anlyses) as well as potential memory leaks.\n */\nclass ScrollObserver {\n  private static[$notifyInstances]() {\n    for (const instance of ScrollObserver[$instances]) {\n      instance[$notify]();\n    }\n  }\n  private static[$instances]: Set<ScrollObserver> = new Set();\n  private static[$activateListener]() {\n    window.addEventListener('scroll', this[$notifyInstances], {passive: true});\n  }\n  private static[$deactivateListener]() {\n    window.removeEventListener('scroll', this[$notifyInstances]);\n  }\n\n  private[$scrollCallback]: ScrollObserverCallback;\n\n  constructor(callback: ScrollObserverCallback) {\n    this[$scrollCallback] = callback;\n  }\n\n  /**\n   * Listen for scroll events. The configured callback (passed to the\n   * constructor) will be invoked for subsequent global scroll events.\n   */\n  observe() {\n    if (ScrollObserver[$instances].size === 0) {\n      ScrollObserver[$activateListener]();\n    }\n    ScrollObserver[$instances].add(this);\n  }\n\n  /**\n   * Stop listening for scroll events.\n   */\n  disconnect() {\n    ScrollObserver[$instances].delete(this);\n    if (ScrollObserver[$instances].size === 0) {\n      ScrollObserver[$deactivateListener]();\n    }\n  }\n\n  private[$notify]() {\n    this[$scrollCallback]();\n  };\n}\n\n\nexport type EnvironmentState = 'window-scroll';\n\nexport type StyleEffectorCallback = (record: EnvironmentChangeRecord) => void;\nexport interface EnvironmentChangeRecord {\n  relatedState: EnvironmentState;\n}\n\ntype EnvironmentDependencies = {\n  [key in EnvironmentState]?: AnyObserver\n};\n\nconst $computeStyleCallback = Symbol('computeStyleCallback');\nconst $astWalker = Symbol('astWalker');\nconst $dependencies = Symbol('dependencies');\n\nconst $scrollHandler = Symbol('scrollHandler');\nconst $onScroll = Symbol('onScroll');\n\n/**\n * The StyleEffector is configured with a callback that will be invoked at the\n * optimal time that some array of CSS expression ASTs ought to be evaluated.\n *\n * For example, our CSS-like expression syntax supports usage of the env()\n * function to incorporate the current top-level scroll position into a CSS\n * expression: env(window-scroll-y).\n *\n * This \"environment variable\" will change dynamically as the user scrolls the\n * page. If an AST contains such a usage of env(), we would have to evaluate the\n * AST on every frame in order to be sure that the computed style stays up to\n * date.\n *\n * The StyleEffector spares us from evaluating the expressions on every frame by\n * correlating specific parts of an AST with observers of the external effects\n * that they refer to (if any). So, if the AST contains env(window-scroll-y),\n * the StyleEffector manages the lifetime of a global scroll event listener and\n * notifies the user at the optimal time to evaluate the computed style.\n */\nexport class StyleEffector {\n  protected[$dependencies]: EnvironmentDependencies = {};\n\n  protected[$computeStyleCallback]: StyleEffectorCallback;\n  protected[$astWalker] = new ASTWalker<FunctionNode>(['function']);\n\n  protected[$scrollHandler] = () => this[$onScroll]();\n\n  constructor(callback: StyleEffectorCallback) {\n    this[$computeStyleCallback] = callback;\n  }\n\n  /**\n   * Sets the expressions that govern when the StyleEffector callback will be\n   * invoked.\n   */\n  observeEffectsFor(ast: Array<ExpressionNode>) {\n    const newDependencies: EnvironmentDependencies = {};\n    const oldDependencies = this[$dependencies];\n\n    this[$astWalker].walk(ast, functionNode => {\n      const {name} = functionNode;\n      const firstArgument = functionNode.arguments[0];\n      const firstTerm = firstArgument.terms[0];\n\n      if (name.value !== 'env' || firstTerm == null ||\n          firstTerm.type !== 'ident') {\n        return;\n      }\n\n      switch (firstTerm.value) {\n        case 'window-scroll-y':\n          if (newDependencies['window-scroll'] == null) {\n            const observer = 'window-scroll' in oldDependencies ?\n                oldDependencies['window-scroll'] :\n                new ScrollObserver(this[$scrollHandler]);\n            observer!.observe();\n            delete oldDependencies['window-scroll'];\n            newDependencies['window-scroll'] = observer;\n          }\n          break;\n      }\n    });\n\n    for (const environmentState in oldDependencies) {\n      const observer = oldDependencies[environmentState as EnvironmentState]!;\n      observer.disconnect();\n    }\n\n    this[$dependencies] = newDependencies;\n  }\n\n  /**\n   * Disposes of the StyleEffector by disconnecting all observers of external\n   * effects.\n   */\n  dispose() {\n    for (const environmentState in this[$dependencies]) {\n      const observer =\n          this[$dependencies][environmentState as EnvironmentState]!;\n      observer.disconnect();\n    }\n  }\n\n  protected[$onScroll]() {\n    this[$computeStyleCallback]({relatedState: 'window-scroll'});\n  }\n}"],"sourceRoot":""},"metadata":{},"sourceType":"module"}