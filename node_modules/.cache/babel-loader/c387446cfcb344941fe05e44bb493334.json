{"ast":null,"code":"import _slicedToArray from \"F:\\\\_HCLCommece\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\n\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { property } from 'lit-element';\nimport { Spherical, Vector3 } from 'three';\nimport { style } from '../decorators.js';\nimport { $ariaLabel, $container, $loadedTime, $needsRender, $onModelLoad, $onResize, $renderer, $scene, $tick, $userInputElement } from '../model-viewer-base.js';\nimport { degreesToRadians, normalizeUnit } from '../styles/conversions.js';\nimport { StyleEvaluator } from '../styles/evaluators.js';\nimport { numberNode, parseExpressions } from '../styles/parsers.js';\nimport { SAFE_RADIUS_RATIO } from '../three-components/Model.js';\nimport { ChangeSource, SmoothControls } from '../three-components/SmoothControls.js';\nimport { timeline } from '../utilities/animation.js'; // NOTE(cdata): The following \"animation\" timing functions are deliberately\n// being used in favor of CSS animations. In Safari 12.1 and 13, CSS animations\n// would cause the interaction prompt to glitch unexpectedly\n// @see https://github.com/GoogleWebComponents/model-viewer/issues/839\n\nconst PROMPT_ANIMATION_TIME = 5000; // For timing purposes, a \"frame\" is a timing agnostic relative unit of time\n// and a \"value\" is a target value for the keyframe.\n\nconst wiggle = timeline(0, [{\n  frames: 6,\n  value: 0\n}, {\n  frames: 5,\n  value: -1\n}, {\n  frames: 1,\n  value: -1\n}, {\n  frames: 8,\n  value: 1\n}, {\n  frames: 1,\n  value: 1\n}, {\n  frames: 5,\n  value: 0\n}, {\n  frames: 12,\n  value: 0\n}]);\nconst fade = timeline(0, [{\n  frames: 2,\n  value: 0\n}, {\n  frames: 1,\n  value: 1\n}, {\n  frames: 5,\n  value: 1\n}, {\n  frames: 1,\n  value: 0\n}, {\n  frames: 4,\n  value: 0\n}]);\nexport const DEFAULT_CAMERA_ORBIT = '0deg 75deg 105%';\nconst DEFAULT_CAMERA_TARGET = 'auto auto auto';\nconst DEFAULT_FIELD_OF_VIEW = 'auto';\nconst MINIMUM_RADIUS_RATIO = 1.1 * SAFE_RADIUS_RATIO;\nconst AZIMUTHAL_QUADRANT_LABELS = ['front', 'right', 'back', 'left'];\nconst POLAR_TRIENT_LABELS = ['upper-', '', 'lower-'];\nexport const DEFAULT_INTERACTION_PROMPT_THRESHOLD = 3000;\nexport const INTERACTION_PROMPT = 'Use mouse, touch or arrow keys to control the camera!';\nexport const InteractionPromptStrategy = {\n  AUTO: 'auto',\n  WHEN_FOCUSED: 'when-focused',\n  NONE: 'none'\n};\nexport const InteractionPromptStyle = {\n  BASIC: 'basic',\n  WIGGLE: 'wiggle'\n};\nexport const InteractionPolicy = {\n  ALWAYS_ALLOW: 'always-allow',\n  WHEN_FOCUSED: 'allow-when-focused'\n};\nexport const fieldOfViewIntrinsics = element => {\n  return {\n    basis: [numberNode(element[$zoomAdjustedFieldOfView] * Math.PI / 180, 'rad')],\n    keywords: {\n      auto: [null]\n    }\n  };\n};\nconst minFieldOfViewIntrinsics = {\n  basis: [degreesToRadians(numberNode(25, 'deg'))],\n  keywords: {\n    auto: [null]\n  }\n};\n\nconst maxFieldOfViewIntrinsics = element => {\n  const scene = element[$scene];\n  return {\n    basis: [degreesToRadians(numberNode(45, 'deg'))],\n    keywords: {\n      auto: [numberNode(scene.framedFieldOfView, 'deg')]\n    }\n  };\n};\n\nexport const cameraOrbitIntrinsics = (() => {\n  const defaultTerms = parseExpressions(DEFAULT_CAMERA_ORBIT)[0].terms;\n  const theta = normalizeUnit(defaultTerms[0]);\n  const phi = normalizeUnit(defaultTerms[1]);\n  return element => {\n    const radius = element[$scene].model.idealCameraDistance;\n    return {\n      basis: [theta, phi, numberNode(radius, 'm')],\n      keywords: {\n        auto: [null, null, numberNode(105, '%')]\n      }\n    };\n  };\n})();\n\nconst minCameraOrbitIntrinsics = element => {\n  const radius = MINIMUM_RADIUS_RATIO * element[$scene].model.idealCameraDistance;\n  return {\n    basis: [numberNode(-Infinity, 'rad'), numberNode(Math.PI / 8, 'rad'), numberNode(radius, 'm')],\n    keywords: {\n      auto: [null, null, null]\n    }\n  };\n};\n\nconst maxCameraOrbitIntrinsics = element => {\n  const orbitIntrinsics = cameraOrbitIntrinsics(element);\n  const evaluator = new StyleEvaluator([], orbitIntrinsics);\n  const defaultRadius = evaluator.evaluate()[2];\n  return {\n    basis: [numberNode(Infinity, 'rad'), numberNode(Math.PI - Math.PI / 8, 'rad'), numberNode(defaultRadius, 'm')],\n    keywords: {\n      auto: [null, null, null]\n    }\n  };\n};\n\nexport const cameraTargetIntrinsics = element => {\n  const center = element[$scene].model.boundingBox.getCenter(new Vector3());\n  return {\n    basis: [numberNode(center.x, 'm'), numberNode(center.y, 'm'), numberNode(center.z, 'm')],\n    keywords: {\n      auto: [null, null, null]\n    }\n  };\n};\nconst HALF_PI = Math.PI / 2.0;\nconst THIRD_PI = Math.PI / 3.0;\nconst QUARTER_PI = HALF_PI / 2.0;\nconst TAU = 2.0 * Math.PI;\nexport const $controls = Symbol('controls');\nexport const $promptElement = Symbol('promptElement');\nexport const $promptAnimatedContainer = Symbol('promptAnimatedContainer');\nexport const $idealCameraDistance = Symbol('idealCameraDistance');\nconst $deferInteractionPrompt = Symbol('deferInteractionPrompt');\nconst $updateAria = Symbol('updateAria');\nconst $updateCameraForRadius = Symbol('updateCameraForRadius');\nconst $blurHandler = Symbol('blurHandler');\nconst $focusHandler = Symbol('focusHandler');\nconst $changeHandler = Symbol('changeHandler');\nconst $pointerChangeHandler = Symbol('pointerChangeHandler');\nconst $onBlur = Symbol('onBlur');\nconst $onFocus = Symbol('onFocus');\nconst $onChange = Symbol('onChange');\nconst $onPointerChange = Symbol('onPointerChange');\nconst $waitingToPromptUser = Symbol('waitingToPromptUser');\nconst $userHasInteracted = Symbol('userHasInteracted');\nconst $promptElementVisibleTime = Symbol('promptElementVisibleTime');\nconst $lastPromptOffset = Symbol('lastPromptOffset');\nconst $focusedTime = Symbol('focusedTime');\nconst $zoomAdjustedFieldOfView = Symbol('zoomAdjustedFieldOfView');\nconst $lastSpherical = Symbol('lastSpherical');\nconst $jumpCamera = Symbol('jumpCamera');\nconst $syncCameraOrbit = Symbol('syncCameraOrbit');\nconst $syncFieldOfView = Symbol('syncFieldOfView');\nconst $syncCameraTarget = Symbol('syncCameraTarget');\nconst $syncMinCameraOrbit = Symbol('syncMinCameraOrbit');\nconst $syncMaxCameraOrbit = Symbol('syncMaxCameraOrbit');\nconst $syncMinFieldOfView = Symbol('syncMinFieldOfView');\nconst $syncMaxFieldOfView = Symbol('syncMaxFieldOfView');\nexport const ControlsMixin = ModelViewerElement => {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;\n\n  class ControlsModelViewerElement extends ModelViewerElement {\n    constructor() {\n      super(...arguments);\n      this.cameraControls = false;\n      this.cameraOrbit = DEFAULT_CAMERA_ORBIT;\n      this.cameraTarget = DEFAULT_CAMERA_TARGET;\n      this.fieldOfView = DEFAULT_FIELD_OF_VIEW;\n      this.minCameraOrbit = 'auto';\n      this.maxCameraOrbit = 'auto';\n      this.minFieldOfView = 'auto';\n      this.maxFieldOfView = 'auto';\n      this.interactionPromptThreshold = DEFAULT_INTERACTION_PROMPT_THRESHOLD;\n      this.interactionPromptStyle = InteractionPromptStyle.WIGGLE;\n      this.interactionPrompt = InteractionPromptStrategy.AUTO;\n      this.interactionPolicy = InteractionPolicy.ALWAYS_ALLOW;\n      this[_a] = this.shadowRoot.querySelector('.interaction-prompt');\n      this[_b] = this.shadowRoot.querySelector('.interaction-prompt > .animated-container');\n      this[_c] = Infinity;\n      this[_d] = 0;\n      this[_e] = Infinity;\n      this[_f] = false;\n      this[_g] = false;\n      this[_h] = new SmoothControls(this[$scene].camera, this[$userInputElement]);\n      this[_j] = 0;\n      this[_k] = new Spherical();\n      this[_l] = false;\n\n      this[_m] = event => this[$onChange](event);\n\n      this[_o] = event => this[$onPointerChange](event);\n\n      this[_p] = () => this[$onFocus]();\n\n      this[_q] = () => this[$onBlur]();\n    }\n\n    getCameraOrbit() {\n      const _this$$lastSpherical = this[$lastSpherical],\n            theta = _this$$lastSpherical.theta,\n            phi = _this$$lastSpherical.phi,\n            radius = _this$$lastSpherical.radius;\n      return {\n        theta,\n        phi,\n        radius\n      };\n    }\n\n    getCameraTarget() {\n      return this[$scene].getTarget();\n    }\n\n    getFieldOfView() {\n      return this[$controls].getFieldOfView();\n    }\n\n    jumpCameraToGoal() {\n      this[$jumpCamera] = true;\n      this.requestUpdate($jumpCamera, false);\n    }\n\n    resetInteractionPrompt() {\n      this[$lastPromptOffset] = 0;\n      this[$promptElementVisibleTime] = Infinity;\n      this[$userHasInteracted] = false;\n      this[$waitingToPromptUser] = this.interactionPrompt === InteractionPromptStrategy.AUTO && this.cameraControls;\n    }\n\n    connectedCallback() {\n      super.connectedCallback();\n      this[$controls].addEventListener('change', this[$changeHandler]);\n      this[$controls].addEventListener('pointer-change-start', this[$pointerChangeHandler]);\n      this[$controls].addEventListener('pointer-change-end', this[$pointerChangeHandler]);\n    }\n\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      this[$controls].removeEventListener('change', this[$changeHandler]);\n      this[$controls].removeEventListener('pointer-change-start', this[$pointerChangeHandler]);\n      this[$controls].removeEventListener('pointer-change-end', this[$pointerChangeHandler]);\n    }\n\n    updated(changedProperties) {\n      super.updated(changedProperties);\n      const controls = this[$controls];\n      const input = this[$userInputElement];\n\n      if (changedProperties.has('cameraControls')) {\n        if (this.cameraControls) {\n          controls.enableInteraction();\n\n          if (this.interactionPrompt === InteractionPromptStrategy.AUTO) {\n            this[$waitingToPromptUser] = true;\n          }\n\n          input.addEventListener('focus', this[$focusHandler]);\n          input.addEventListener('blur', this[$blurHandler]);\n        } else {\n          input.removeEventListener('focus', this[$focusHandler]);\n          input.removeEventListener('blur', this[$blurHandler]);\n          controls.disableInteraction();\n          this[$deferInteractionPrompt]();\n        }\n      }\n\n      if (changedProperties.has('interactionPrompt') || changedProperties.has('cameraControls') || changedProperties.has('src')) {\n        if (this.interactionPrompt === InteractionPromptStrategy.AUTO && this.cameraControls) {\n          this[$waitingToPromptUser] = true;\n        } else {\n          this[$deferInteractionPrompt]();\n        }\n      }\n\n      if (changedProperties.has('interactionPromptStyle')) {\n        this[$promptElement].classList.toggle('wiggle', this.interactionPromptStyle === InteractionPromptStyle.WIGGLE);\n      }\n\n      if (changedProperties.has('interactionPolicy')) {\n        const interactionPolicy = this.interactionPolicy;\n        controls.applyOptions({\n          interactionPolicy\n        });\n      }\n\n      if (this[$jumpCamera] === true) {\n        Promise.resolve().then(() => {\n          this[$controls].jumpToGoal();\n          this[$scene].jumpToGoal();\n          this[$jumpCamera] = false;\n        });\n      }\n    }\n\n    [(_a = $promptElement, _b = $promptAnimatedContainer, _c = $focusedTime, _d = $lastPromptOffset, _e = $promptElementVisibleTime, _f = $userHasInteracted, _g = $waitingToPromptUser, _h = $controls, _j = $zoomAdjustedFieldOfView, _k = $lastSpherical, _l = $jumpCamera, _m = $changeHandler, _o = $pointerChangeHandler, _p = $focusHandler, _q = $blurHandler, $syncFieldOfView)](style) {\n      this[$controls].setFieldOfView(style[0] * 180 / Math.PI);\n    }\n\n    [$syncCameraOrbit](style) {\n      this[$updateCameraForRadius](style[2]);\n      this[$controls].setOrbit(style[0], style[1], style[2]);\n    }\n\n    [$syncMinCameraOrbit](style) {\n      this[$controls].applyOptions({\n        minimumAzimuthalAngle: style[0],\n        minimumPolarAngle: style[1],\n        minimumRadius: style[2]\n      });\n      this.jumpCameraToGoal();\n    }\n\n    [$syncMaxCameraOrbit](style) {\n      this[$controls].applyOptions({\n        maximumAzimuthalAngle: style[0],\n        maximumPolarAngle: style[1],\n        maximumRadius: style[2]\n      });\n      this.jumpCameraToGoal();\n    }\n\n    [$syncMinFieldOfView](style) {\n      this[$controls].applyOptions({\n        minimumFieldOfView: style[0] * 180 / Math.PI\n      });\n      this.jumpCameraToGoal();\n    }\n\n    [$syncMaxFieldOfView](style) {\n      this[$controls].applyOptions({\n        maximumFieldOfView: style[0] * 180 / Math.PI\n      });\n      this.jumpCameraToGoal();\n    }\n\n    [$syncCameraTarget](style) {\n      const _style = _slicedToArray(style, 3),\n            x = _style[0],\n            y = _style[1],\n            z = _style[2];\n\n      this[$scene].setTarget(x, y, z);\n    }\n\n    [$tick](time, delta) {\n      super[$tick](time, delta);\n\n      if (this[$renderer].isPresenting) {\n        return;\n      }\n\n      const now = performance.now();\n\n      if (this[$waitingToPromptUser]) {\n        const thresholdTime = this.interactionPrompt === InteractionPromptStrategy.AUTO ? this[$loadedTime] : this[$focusedTime];\n\n        if (this.loaded && now > thresholdTime + this.interactionPromptThreshold) {\n          this[$userInputElement].setAttribute('aria-label', INTERACTION_PROMPT);\n          this[$waitingToPromptUser] = false;\n          this[$promptElementVisibleTime] = now;\n          this[$promptElement].classList.add('visible');\n        }\n      }\n\n      if (isFinite(this[$promptElementVisibleTime]) && this.interactionPromptStyle === InteractionPromptStyle.WIGGLE) {\n        const scene = this[$scene];\n        const animationTime = (now - this[$promptElementVisibleTime]) / PROMPT_ANIMATION_TIME % 1;\n        const offset = wiggle(animationTime);\n        const opacity = fade(animationTime);\n        const xOffset = offset * scene.width * 0.05;\n        const deltaTheta = (offset - this[$lastPromptOffset]) * Math.PI / 16;\n        this[$promptAnimatedContainer].style.transform = `translateX(${xOffset}px)`;\n        this[$promptAnimatedContainer].style.opacity = `${opacity}`;\n        this[$controls].adjustOrbit(deltaTheta, 0, 0);\n        this[$lastPromptOffset] = offset;\n        this[$needsRender]();\n      }\n\n      this[$controls].update(time, delta);\n      this[$scene].updateTarget(delta);\n    }\n\n    [$deferInteractionPrompt]() {\n      // Effectively cancel the timer waiting for user interaction:\n      this[$waitingToPromptUser] = false;\n      this[$promptElement].classList.remove('visible');\n      this[$promptElementVisibleTime] = Infinity;\n    }\n    /**\n     * Updates the camera's near and far planes to enclose the scene when\n     * orbiting at the supplied radius.\n     */\n\n\n    [$updateCameraForRadius](radius) {\n      const idealCameraDistance = this[$scene].model.idealCameraDistance;\n      const maximumRadius = Math.max(idealCameraDistance, radius);\n      const near = 0;\n      const far = 2 * maximumRadius;\n      this[$controls].updateNearFar(near, far);\n    }\n\n    [$updateAria]() {\n      // NOTE(cdata): It is possible that we might want to record the\n      // last spherical when the label actually changed. Right now, the\n      // side-effect the current implementation is that we will only\n      // announce the first view change that occurs after the element\n      // becomes focused.\n      const _this$$lastSpherical2 = this[$lastSpherical],\n            lastTheta = _this$$lastSpherical2.theta,\n            lastPhi = _this$$lastSpherical2.phi;\n\n      const _this$$controls$getCa = this[$controls].getCameraSpherical(this[$lastSpherical]),\n            theta = _this$$controls$getCa.theta,\n            phi = _this$$controls$getCa.phi;\n\n      const rootNode = this.getRootNode(); // Only change the aria-label if <model-viewer> is currently focused:\n\n      if (rootNode != null && rootNode.activeElement === this) {\n        const lastAzimuthalQuadrant = (4 + Math.floor((lastTheta % TAU + QUARTER_PI) / HALF_PI)) % 4;\n        const azimuthalQuadrant = (4 + Math.floor((theta % TAU + QUARTER_PI) / HALF_PI)) % 4;\n        const lastPolarTrient = Math.floor(lastPhi / THIRD_PI);\n        const polarTrient = Math.floor(phi / THIRD_PI);\n\n        if (azimuthalQuadrant !== lastAzimuthalQuadrant || polarTrient !== lastPolarTrient) {\n          const azimuthalQuadrantLabel = AZIMUTHAL_QUADRANT_LABELS[azimuthalQuadrant];\n          const polarTrientLabel = POLAR_TRIENT_LABELS[polarTrient];\n          const ariaLabel = `View from stage ${polarTrientLabel}${azimuthalQuadrantLabel}`;\n          this[$userInputElement].setAttribute('aria-label', ariaLabel);\n        }\n      }\n    }\n\n    [$onResize](event) {\n      const controls = this[$controls];\n      const oldFramedFieldOfView = this[$scene].framedFieldOfView; // The super of $onResize will update the scene's framedFieldOfView, so we\n      // compare the before and after to calculate the proper zoom.\n\n      super[$onResize](event);\n      const newFramedFieldOfView = this[$scene].framedFieldOfView;\n      const zoom = controls.getFieldOfView() / oldFramedFieldOfView;\n      this[$zoomAdjustedFieldOfView] = newFramedFieldOfView * zoom;\n      controls.updateAspect(this[$scene].aspect);\n      this.requestUpdate('maxFieldOfView', this.maxFieldOfView);\n      this.requestUpdate('fieldOfView', this.fieldOfView);\n      this.jumpCameraToGoal();\n    }\n\n    [$onModelLoad](event) {\n      super[$onModelLoad](event);\n      const framedFieldOfView = this[$scene].framedFieldOfView;\n      this[$zoomAdjustedFieldOfView] = framedFieldOfView;\n      this.requestUpdate('maxFieldOfView', this.maxFieldOfView);\n      this.requestUpdate('fieldOfView', this.fieldOfView);\n      this.requestUpdate('cameraOrbit', this.cameraOrbit);\n      this.requestUpdate('minCameraOrbit', this.minCameraOrbit);\n      this.requestUpdate('maxCameraOrbit', this.maxCameraOrbit);\n      this.requestUpdate('cameraTarget', this.cameraTarget);\n      this.jumpCameraToGoal();\n    }\n\n    [$onFocus]() {\n      const input = this[$userInputElement];\n\n      if (!isFinite(this[$focusedTime])) {\n        this[$focusedTime] = performance.now();\n      } // NOTE(cdata): On every re-focus, we switch the aria-label back to\n      // the original, non-prompt label if appropriate. If the user has\n      // already interacted, they no longer need to hear the prompt.\n      // Otherwise, they will hear it again after the idle prompt threshold\n      // has been crossed.\n\n\n      const ariaLabel = this[$ariaLabel];\n\n      if (input.getAttribute('aria-label') !== ariaLabel) {\n        input.setAttribute('aria-label', ariaLabel);\n      }\n\n      if (this.interactionPrompt === InteractionPromptStrategy.WHEN_FOCUSED && !this[$userHasInteracted]) {\n        this[$waitingToPromptUser] = true;\n      }\n    }\n\n    [$onBlur]() {\n      this[$waitingToPromptUser] = false;\n      this[$promptElement].classList.remove('visible');\n      this[$promptElementVisibleTime] = Infinity;\n      this[$focusedTime] = Infinity;\n    }\n\n    [$onChange]({\n      source\n    }) {\n      this[$updateAria]();\n      this[$needsRender]();\n\n      if (source === ChangeSource.USER_INTERACTION) {\n        this[$userHasInteracted] = true;\n        this[$deferInteractionPrompt]();\n      }\n\n      this.dispatchEvent(new CustomEvent('camera-change', {\n        detail: {\n          source\n        }\n      }));\n    }\n\n    [$onPointerChange](event) {\n      if (event.type === 'pointer-change-start') {\n        this[$container].classList.add('pointer-tumbling');\n      } else {\n        this[$container].classList.remove('pointer-tumbling');\n      }\n    }\n\n  }\n\n  __decorate([property({\n    type: Boolean,\n    attribute: 'camera-controls'\n  })], ControlsModelViewerElement.prototype, \"cameraControls\", void 0);\n\n  __decorate([style({\n    intrinsics: cameraOrbitIntrinsics,\n    observeEffects: true,\n    updateHandler: $syncCameraOrbit\n  }), property({\n    type: String,\n    attribute: 'camera-orbit',\n    hasChanged: () => true\n  })], ControlsModelViewerElement.prototype, \"cameraOrbit\", void 0);\n\n  __decorate([style({\n    intrinsics: cameraTargetIntrinsics,\n    observeEffects: true,\n    updateHandler: $syncCameraTarget\n  }), property({\n    type: String,\n    attribute: 'camera-target',\n    hasChanged: () => true\n  })], ControlsModelViewerElement.prototype, \"cameraTarget\", void 0);\n\n  __decorate([style({\n    intrinsics: fieldOfViewIntrinsics,\n    observeEffects: true,\n    updateHandler: $syncFieldOfView\n  }), property({\n    type: String,\n    attribute: 'field-of-view',\n    hasChanged: () => true\n  })], ControlsModelViewerElement.prototype, \"fieldOfView\", void 0);\n\n  __decorate([style({\n    intrinsics: minCameraOrbitIntrinsics,\n    updateHandler: $syncMinCameraOrbit\n  }), property({\n    type: String,\n    attribute: 'min-camera-orbit',\n    hasChanged: () => true\n  })], ControlsModelViewerElement.prototype, \"minCameraOrbit\", void 0);\n\n  __decorate([style({\n    intrinsics: maxCameraOrbitIntrinsics,\n    updateHandler: $syncMaxCameraOrbit\n  }), property({\n    type: String,\n    attribute: 'max-camera-orbit',\n    hasChanged: () => true\n  })], ControlsModelViewerElement.prototype, \"maxCameraOrbit\", void 0);\n\n  __decorate([style({\n    intrinsics: minFieldOfViewIntrinsics,\n    updateHandler: $syncMinFieldOfView\n  }), property({\n    type: String,\n    attribute: 'min-field-of-view',\n    hasChanged: () => true\n  })], ControlsModelViewerElement.prototype, \"minFieldOfView\", void 0);\n\n  __decorate([style({\n    intrinsics: maxFieldOfViewIntrinsics,\n    updateHandler: $syncMaxFieldOfView\n  }), property({\n    type: String,\n    attribute: 'max-field-of-view',\n    hasChanged: () => true\n  })], ControlsModelViewerElement.prototype, \"maxFieldOfView\", void 0);\n\n  __decorate([property({\n    type: Number,\n    attribute: 'interaction-prompt-threshold'\n  })], ControlsModelViewerElement.prototype, \"interactionPromptThreshold\", void 0);\n\n  __decorate([property({\n    type: String,\n    attribute: 'interaction-prompt-style'\n  })], ControlsModelViewerElement.prototype, \"interactionPromptStyle\", void 0);\n\n  __decorate([property({\n    type: String,\n    attribute: 'interaction-prompt'\n  })], ControlsModelViewerElement.prototype, \"interactionPrompt\", void 0);\n\n  __decorate([property({\n    type: String,\n    attribute: 'interaction-policy'\n  })], ControlsModelViewerElement.prototype, \"interactionPolicy\", void 0);\n\n  return ControlsModelViewerElement;\n};","map":{"version":3,"sources":["../../src/features/controls.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {property} from 'lit-element';\nimport {Event, PerspectiveCamera, Spherical, Vector3} from 'three';\n\nimport {style} from '../decorators.js';\nimport ModelViewerElementBase, {$ariaLabel, $container, $loadedTime, $needsRender, $onModelLoad, $onResize, $renderer, $scene, $tick, $userInputElement, Vector3D} from '../model-viewer-base.js';\nimport {degreesToRadians, normalizeUnit} from '../styles/conversions.js';\nimport {EvaluatedStyle, Intrinsics, SphericalIntrinsics, StyleEvaluator, Vector3Intrinsics} from '../styles/evaluators.js';\nimport {IdentNode, NumberNode, numberNode, parseExpressions} from '../styles/parsers.js';\nimport {SAFE_RADIUS_RATIO} from '../three-components/Model.js';\nimport {ChangeEvent, ChangeSource, PointerChangeEvent, SmoothControls} from '../three-components/SmoothControls.js';\nimport {Constructor} from '../utilities.js';\nimport {timeline} from '../utilities/animation.js';\n\n\n\n// NOTE(cdata): The following \"animation\" timing functions are deliberately\n// being used in favor of CSS animations. In Safari 12.1 and 13, CSS animations\n// would cause the interaction prompt to glitch unexpectedly\n// @see https://github.com/GoogleWebComponents/model-viewer/issues/839\nconst PROMPT_ANIMATION_TIME = 5000;\n\n// For timing purposes, a \"frame\" is a timing agnostic relative unit of time\n// and a \"value\" is a target value for the keyframe.\nconst wiggle = timeline(0, [\n  {frames: 6, value: 0},\n  {frames: 5, value: -1},\n  {frames: 1, value: -1},\n  {frames: 8, value: 1},\n  {frames: 1, value: 1},\n  {frames: 5, value: 0},\n  {frames: 12, value: 0}\n]);\n\nconst fade = timeline(0, [\n  {frames: 2, value: 0},\n  {frames: 1, value: 1},\n  {frames: 5, value: 1},\n  {frames: 1, value: 0},\n  {frames: 4, value: 0}\n]);\n\nexport const DEFAULT_CAMERA_ORBIT = '0deg 75deg 105%';\nconst DEFAULT_CAMERA_TARGET = 'auto auto auto';\nconst DEFAULT_FIELD_OF_VIEW = 'auto';\n\nconst MINIMUM_RADIUS_RATIO = 1.1 * SAFE_RADIUS_RATIO;\n\nconst AZIMUTHAL_QUADRANT_LABELS = ['front', 'right', 'back', 'left'];\nconst POLAR_TRIENT_LABELS = ['upper-', '', 'lower-'];\n\nexport const DEFAULT_INTERACTION_PROMPT_THRESHOLD = 3000;\nexport const INTERACTION_PROMPT =\n    'Use mouse, touch or arrow keys to control the camera!';\n\nexport interface CameraChangeDetails {\n  source: ChangeSource;\n}\n\nexport interface SphericalPosition {\n  theta: number;  // equator angle around the y (up) axis.\n  phi: number;    // polar angle from the y (up) axis.\n  radius: number;\n}\n\nexport type InteractionPromptStrategy = 'auto'|'when-focused'|'none';\nexport type InteractionPromptStyle = 'basic'|'wiggle';\nexport type InteractionPolicy = 'always-allow'|'allow-when-focused';\n\nexport const InteractionPromptStrategy:\n    {[index: string]: InteractionPromptStrategy} = {\n      AUTO: 'auto',\n      WHEN_FOCUSED: 'when-focused',\n      NONE: 'none'\n    };\n\nexport const InteractionPromptStyle:\n    {[index: string]: InteractionPromptStyle} = {\n      BASIC: 'basic',\n      WIGGLE: 'wiggle'\n    };\n\nexport const InteractionPolicy: {[index: string]: InteractionPolicy} = {\n  ALWAYS_ALLOW: 'always-allow',\n  WHEN_FOCUSED: 'allow-when-focused'\n};\n\nexport const fieldOfViewIntrinsics = (element: ModelViewerElementBase) => {\n  return {\n    basis: [numberNode(\n        (element as any)[$zoomAdjustedFieldOfView] * Math.PI / 180, 'rad')],\n    keywords: {auto: [null]}\n  };\n};\n\nconst minFieldOfViewIntrinsics = {\n  basis: [degreesToRadians(numberNode(25, 'deg')) as NumberNode<'rad'>],\n  keywords: {auto: [null]}\n};\n\nconst maxFieldOfViewIntrinsics = (element: ModelViewerElementBase) => {\n  const scene = element[$scene];\n\n  return {\n    basis: [degreesToRadians(numberNode(45, 'deg')) as NumberNode<'rad'>],\n    keywords: {auto: [numberNode(scene.framedFieldOfView, 'deg')]}\n  };\n};\n\nexport const cameraOrbitIntrinsics = (() => {\n  const defaultTerms =\n      parseExpressions(DEFAULT_CAMERA_ORBIT)[0]\n          .terms as [NumberNode<'rad'>, NumberNode<'rad'>, IdentNode];\n\n  const theta = normalizeUnit(defaultTerms[0]) as NumberNode<'rad'>;\n  const phi = normalizeUnit(defaultTerms[1]) as NumberNode<'rad'>;\n\n  return (element: ModelViewerElementBase) => {\n    const radius = element[$scene].model.idealCameraDistance;\n\n    return {\n      basis: [theta, phi, numberNode(radius, 'm')],\n      keywords: {auto: [null, null, numberNode(105, '%')]}\n    };\n  };\n})();\n\nconst minCameraOrbitIntrinsics = (element: ModelViewerElementBase) => {\n  const radius =\n      MINIMUM_RADIUS_RATIO * element[$scene].model.idealCameraDistance;\n\n  return {\n    basis: [\n      numberNode(-Infinity, 'rad'),\n      numberNode(Math.PI / 8, 'rad'),\n      numberNode(radius, 'm')\n    ],\n    keywords: {auto: [null, null, null]}\n  };\n};\n\nconst maxCameraOrbitIntrinsics = (element: ModelViewerElementBase) => {\n  const orbitIntrinsics = cameraOrbitIntrinsics(element);\n  const evaluator = new StyleEvaluator([], orbitIntrinsics);\n  const defaultRadius = evaluator.evaluate()[2];\n\n  return {\n    basis: [\n      numberNode(Infinity, 'rad'),\n      numberNode(Math.PI - Math.PI / 8, 'rad'),\n      numberNode(defaultRadius, 'm')\n    ],\n    keywords: {auto: [null, null, null]}\n  };\n};\n\nexport const cameraTargetIntrinsics = (element: ModelViewerElementBase) => {\n  const center = element[$scene].model.boundingBox.getCenter(new Vector3);\n\n  return {\n    basis: [\n      numberNode(center.x, 'm'),\n      numberNode(center.y, 'm'),\n      numberNode(center.z, 'm')\n    ],\n    keywords: {auto: [null, null, null]}\n  };\n};\n\nconst HALF_PI = Math.PI / 2.0;\nconst THIRD_PI = Math.PI / 3.0;\nconst QUARTER_PI = HALF_PI / 2.0;\nconst TAU = 2.0 * Math.PI;\n\nexport const $controls = Symbol('controls');\nexport const $promptElement = Symbol('promptElement');\nexport const $promptAnimatedContainer = Symbol('promptAnimatedContainer');\nexport const $idealCameraDistance = Symbol('idealCameraDistance');\n\nconst $deferInteractionPrompt = Symbol('deferInteractionPrompt');\nconst $updateAria = Symbol('updateAria');\nconst $updateCameraForRadius = Symbol('updateCameraForRadius');\n\nconst $blurHandler = Symbol('blurHandler');\nconst $focusHandler = Symbol('focusHandler');\nconst $changeHandler = Symbol('changeHandler');\nconst $pointerChangeHandler = Symbol('pointerChangeHandler');\n\nconst $onBlur = Symbol('onBlur');\nconst $onFocus = Symbol('onFocus');\nconst $onChange = Symbol('onChange');\nconst $onPointerChange = Symbol('onPointerChange');\n\nconst $waitingToPromptUser = Symbol('waitingToPromptUser');\nconst $userHasInteracted = Symbol('userHasInteracted');\nconst $promptElementVisibleTime = Symbol('promptElementVisibleTime');\nconst $lastPromptOffset = Symbol('lastPromptOffset');\nconst $focusedTime = Symbol('focusedTime');\n\nconst $zoomAdjustedFieldOfView = Symbol('zoomAdjustedFieldOfView');\nconst $lastSpherical = Symbol('lastSpherical');\nconst $jumpCamera = Symbol('jumpCamera');\n\nconst $syncCameraOrbit = Symbol('syncCameraOrbit');\nconst $syncFieldOfView = Symbol('syncFieldOfView');\nconst $syncCameraTarget = Symbol('syncCameraTarget');\n\nconst $syncMinCameraOrbit = Symbol('syncMinCameraOrbit');\nconst $syncMaxCameraOrbit = Symbol('syncMaxCameraOrbit');\nconst $syncMinFieldOfView = Symbol('syncMinFieldOfView');\nconst $syncMaxFieldOfView = Symbol('syncMaxFieldOfView');\n\nexport declare interface ControlsInterface {\n  cameraControls: boolean;\n  cameraOrbit: string;\n  cameraTarget: string;\n  fieldOfView: string;\n  minCameraOrbit: string;\n  maxCameraOrbit: string;\n  minFieldOfView: string;\n  maxFieldOfView: string;\n  interactionPrompt: InteractionPromptStrategy;\n  interactionPromptStyle: InteractionPromptStyle;\n  interactionPolicy: InteractionPolicy;\n  interactionPromptThreshold: number;\n  getCameraOrbit(): SphericalPosition;\n  getCameraTarget(): Vector3D;\n  getFieldOfView(): number;\n  jumpCameraToGoal(): void;\n  resetInteractionPrompt(): void;\n}\n\nexport const ControlsMixin = <T extends Constructor<ModelViewerElementBase>>(\n    ModelViewerElement: T): Constructor<ControlsInterface>&T => {\n  class ControlsModelViewerElement extends ModelViewerElement {\n    @property({type: Boolean, attribute: 'camera-controls'})\n    cameraControls: boolean = false;\n\n    @style({\n      intrinsics: cameraOrbitIntrinsics,\n      observeEffects: true,\n      updateHandler: $syncCameraOrbit\n    })\n    @property({type: String, attribute: 'camera-orbit', hasChanged: () => true})\n    cameraOrbit: string = DEFAULT_CAMERA_ORBIT;\n\n    @style({\n      intrinsics: cameraTargetIntrinsics,\n      observeEffects: true,\n      updateHandler: $syncCameraTarget\n    })\n    @property(\n        {type: String, attribute: 'camera-target', hasChanged: () => true})\n    cameraTarget: string = DEFAULT_CAMERA_TARGET;\n\n    @style({\n      intrinsics: fieldOfViewIntrinsics,\n      observeEffects: true,\n      updateHandler: $syncFieldOfView\n    })\n    @property(\n        {type: String, attribute: 'field-of-view', hasChanged: () => true})\n    fieldOfView: string = DEFAULT_FIELD_OF_VIEW;\n\n    @style({\n      intrinsics: minCameraOrbitIntrinsics,\n      updateHandler: $syncMinCameraOrbit\n    })\n    @property(\n        {type: String, attribute: 'min-camera-orbit', hasChanged: () => true})\n    minCameraOrbit: string = 'auto';\n\n    @style({\n      intrinsics: maxCameraOrbitIntrinsics,\n      updateHandler: $syncMaxCameraOrbit\n    })\n    @property(\n        {type: String, attribute: 'max-camera-orbit', hasChanged: () => true})\n    maxCameraOrbit: string = 'auto';\n\n    @style({\n      intrinsics: minFieldOfViewIntrinsics,\n      updateHandler: $syncMinFieldOfView\n    })\n    @property(\n        {type: String, attribute: 'min-field-of-view', hasChanged: () => true})\n    minFieldOfView: string = 'auto';\n\n    @style({\n      intrinsics: maxFieldOfViewIntrinsics,\n      updateHandler: $syncMaxFieldOfView\n    })\n    @property(\n        {type: String, attribute: 'max-field-of-view', hasChanged: () => true})\n    maxFieldOfView: string = 'auto';\n\n    @property({type: Number, attribute: 'interaction-prompt-threshold'})\n    interactionPromptThreshold: number = DEFAULT_INTERACTION_PROMPT_THRESHOLD;\n\n    @property({type: String, attribute: 'interaction-prompt-style'})\n    interactionPromptStyle: InteractionPromptStyle =\n        InteractionPromptStyle.WIGGLE;\n\n    @property({type: String, attribute: 'interaction-prompt'})\n    interactionPrompt: InteractionPromptStrategy =\n        InteractionPromptStrategy.AUTO;\n\n    @property({type: String, attribute: 'interaction-policy'})\n    interactionPolicy: InteractionPolicy = InteractionPolicy.ALWAYS_ALLOW;\n\n    protected[$promptElement] =\n        this.shadowRoot!.querySelector('.interaction-prompt') as HTMLElement;\n    protected[$promptAnimatedContainer] =\n        this.shadowRoot!.querySelector(\n            '.interaction-prompt > .animated-container') as HTMLElement;\n\n    protected[$focusedTime] = Infinity;\n    protected[$lastPromptOffset] = 0;\n    protected[$promptElementVisibleTime] = Infinity;\n    protected[$userHasInteracted] = false;\n    protected[$waitingToPromptUser] = false;\n\n    protected[$controls] = new SmoothControls(\n        this[$scene].camera as PerspectiveCamera, this[$userInputElement]);\n\n    protected[$zoomAdjustedFieldOfView] = 0;\n    protected[$lastSpherical] = new Spherical();\n    protected[$jumpCamera] = false;\n\n    protected[$changeHandler] = (event: Event) =>\n        this[$onChange](event as ChangeEvent);\n\n    protected[$pointerChangeHandler] = (event: Event) =>\n        this[$onPointerChange](event as PointerChangeEvent);\n\n    protected[$focusHandler] = () => this[$onFocus]();\n    protected[$blurHandler] = () => this[$onBlur]();\n\n    getCameraOrbit(): SphericalPosition {\n      const {theta, phi, radius} = this[$lastSpherical];\n      return {theta, phi, radius};\n    }\n\n    getCameraTarget(): Vector3D {\n      return this[$scene].getTarget();\n    }\n\n    getFieldOfView(): number {\n      return this[$controls].getFieldOfView();\n    }\n\n    jumpCameraToGoal() {\n      this[$jumpCamera] = true;\n      this.requestUpdate($jumpCamera, false);\n    }\n\n    resetInteractionPrompt() {\n      this[$lastPromptOffset] = 0;\n      this[$promptElementVisibleTime] = Infinity;\n      this[$userHasInteracted] = false;\n      this[$waitingToPromptUser] =\n          this.interactionPrompt === InteractionPromptStrategy.AUTO &&\n          this.cameraControls;\n    }\n\n    connectedCallback() {\n      super.connectedCallback();\n\n      this[$controls].addEventListener('change', this[$changeHandler]);\n      this[$controls].addEventListener(\n          'pointer-change-start', this[$pointerChangeHandler]);\n      this[$controls].addEventListener(\n          'pointer-change-end', this[$pointerChangeHandler]);\n    }\n\n    disconnectedCallback() {\n      super.disconnectedCallback();\n\n      this[$controls].removeEventListener('change', this[$changeHandler]);\n      this[$controls].removeEventListener(\n          'pointer-change-start', this[$pointerChangeHandler]);\n      this[$controls].removeEventListener(\n          'pointer-change-end', this[$pointerChangeHandler]);\n    }\n\n    updated(changedProperties: Map<string|number|symbol, unknown>) {\n      super.updated(changedProperties);\n\n      const controls = this[$controls];\n      const input = this[$userInputElement];\n\n      if (changedProperties.has('cameraControls')) {\n        if (this.cameraControls) {\n          controls.enableInteraction();\n          if (this.interactionPrompt === InteractionPromptStrategy.AUTO) {\n            this[$waitingToPromptUser] = true;\n          }\n\n          input.addEventListener('focus', this[$focusHandler]);\n          input.addEventListener('blur', this[$blurHandler]);\n        } else {\n          input.removeEventListener('focus', this[$focusHandler]);\n          input.removeEventListener('blur', this[$blurHandler]);\n\n          controls.disableInteraction();\n          this[$deferInteractionPrompt]();\n        }\n      }\n\n      if (changedProperties.has('interactionPrompt') ||\n          changedProperties.has('cameraControls') ||\n          changedProperties.has('src')) {\n        if (this.interactionPrompt === InteractionPromptStrategy.AUTO &&\n            this.cameraControls) {\n          this[$waitingToPromptUser] = true;\n        } else {\n          this[$deferInteractionPrompt]();\n        }\n      }\n\n      if (changedProperties.has('interactionPromptStyle')) {\n        this[$promptElement].classList.toggle(\n            'wiggle',\n            this.interactionPromptStyle === InteractionPromptStyle.WIGGLE);\n      }\n\n      if (changedProperties.has('interactionPolicy')) {\n        const interactionPolicy = this.interactionPolicy;\n        controls.applyOptions({interactionPolicy});\n      }\n\n      if (this[$jumpCamera] === true) {\n        Promise.resolve().then(() => {\n          this[$controls].jumpToGoal();\n          this[$scene].jumpToGoal();\n          this[$jumpCamera] = false;\n        });\n      }\n    }\n\n    [$syncFieldOfView](style: EvaluatedStyle<Intrinsics<['rad']>>) {\n      this[$controls].setFieldOfView(style[0] * 180 / Math.PI);\n    }\n\n    [$syncCameraOrbit](style: EvaluatedStyle<SphericalIntrinsics>) {\n      this[$updateCameraForRadius](style[2]);\n      this[$controls].setOrbit(style[0], style[1], style[2]);\n    }\n\n    [$syncMinCameraOrbit](style: EvaluatedStyle<SphericalIntrinsics>) {\n      this[$controls].applyOptions({\n        minimumAzimuthalAngle: style[0],\n        minimumPolarAngle: style[1],\n        minimumRadius: style[2]\n      });\n      this.jumpCameraToGoal();\n    }\n\n    [$syncMaxCameraOrbit](style: EvaluatedStyle<SphericalIntrinsics>) {\n      this[$controls].applyOptions({\n        maximumAzimuthalAngle: style[0],\n        maximumPolarAngle: style[1],\n        maximumRadius: style[2]\n      });\n      this.jumpCameraToGoal();\n    }\n\n    [$syncMinFieldOfView](style: EvaluatedStyle<Intrinsics<['rad']>>) {\n      this[$controls].applyOptions(\n          {minimumFieldOfView: style[0] * 180 / Math.PI});\n      this.jumpCameraToGoal();\n    }\n\n    [$syncMaxFieldOfView](style: EvaluatedStyle<Intrinsics<['rad']>>) {\n      this[$controls].applyOptions(\n          {maximumFieldOfView: style[0] * 180 / Math.PI});\n      this.jumpCameraToGoal();\n    }\n\n    [$syncCameraTarget](style: EvaluatedStyle<Vector3Intrinsics>) {\n      const [x, y, z] = style;\n      this[$scene].setTarget(x, y, z);\n    }\n\n    [$tick](time: number, delta: number) {\n      super[$tick](time, delta);\n\n      if (this[$renderer].isPresenting) {\n        return;\n      }\n\n      const now = performance.now();\n      if (this[$waitingToPromptUser]) {\n        const thresholdTime =\n            this.interactionPrompt === InteractionPromptStrategy.AUTO ?\n            this[$loadedTime] :\n            this[$focusedTime];\n\n        if (this.loaded &&\n            now > thresholdTime + this.interactionPromptThreshold) {\n          this[$userInputElement].setAttribute(\n              'aria-label', INTERACTION_PROMPT);\n\n          this[$waitingToPromptUser] = false;\n          this[$promptElementVisibleTime] = now;\n\n          this[$promptElement].classList.add('visible');\n        }\n      }\n\n\n      if (isFinite(this[$promptElementVisibleTime]) &&\n          this.interactionPromptStyle === InteractionPromptStyle.WIGGLE) {\n        const scene = this[$scene];\n        const animationTime =\n            ((now - this[$promptElementVisibleTime]) / PROMPT_ANIMATION_TIME) %\n            1;\n        const offset = wiggle(animationTime);\n        const opacity = fade(animationTime);\n\n        const xOffset = offset * scene.width * 0.05;\n        const deltaTheta = (offset - this[$lastPromptOffset]) * Math.PI / 16;\n\n        this[$promptAnimatedContainer].style.transform =\n            `translateX(${xOffset}px)`;\n        this[$promptAnimatedContainer].style.opacity = `${opacity}`;\n\n        this[$controls].adjustOrbit(deltaTheta, 0, 0);\n\n        this[$lastPromptOffset] = offset;\n        this[$needsRender]();\n      }\n\n      this[$controls].update(time, delta);\n      this[$scene].updateTarget(delta);\n    }\n\n    [$deferInteractionPrompt]() {\n      // Effectively cancel the timer waiting for user interaction:\n      this[$waitingToPromptUser] = false;\n      this[$promptElement].classList.remove('visible');\n      this[$promptElementVisibleTime] = Infinity;\n    }\n\n    /**\n     * Updates the camera's near and far planes to enclose the scene when\n     * orbiting at the supplied radius.\n     */\n    [$updateCameraForRadius](radius: number) {\n      const {idealCameraDistance} = this[$scene].model;\n      const maximumRadius = Math.max(idealCameraDistance, radius);\n\n      const near = 0;\n      const far = 2 * maximumRadius;\n      this[$controls].updateNearFar(near, far);\n    }\n\n    [$updateAria]() {\n      // NOTE(cdata): It is possible that we might want to record the\n      // last spherical when the label actually changed. Right now, the\n      // side-effect the current implementation is that we will only\n      // announce the first view change that occurs after the element\n      // becomes focused.\n      const {theta: lastTheta, phi: lastPhi} = this[$lastSpherical];\n      const {theta, phi} =\n          this[$controls]!.getCameraSpherical(this[$lastSpherical]);\n\n      const rootNode = this.getRootNode() as Document | ShadowRoot | null;\n\n      // Only change the aria-label if <model-viewer> is currently focused:\n      if (rootNode != null && rootNode.activeElement === this) {\n        const lastAzimuthalQuadrant =\n            (4 + Math.floor(((lastTheta % TAU) + QUARTER_PI) / HALF_PI)) % 4;\n        const azimuthalQuadrant =\n            (4 + Math.floor(((theta % TAU) + QUARTER_PI) / HALF_PI)) % 4;\n\n        const lastPolarTrient = Math.floor(lastPhi / THIRD_PI);\n        const polarTrient = Math.floor(phi / THIRD_PI);\n\n        if (azimuthalQuadrant !== lastAzimuthalQuadrant ||\n            polarTrient !== lastPolarTrient) {\n          const azimuthalQuadrantLabel =\n              AZIMUTHAL_QUADRANT_LABELS[azimuthalQuadrant];\n          const polarTrientLabel = POLAR_TRIENT_LABELS[polarTrient];\n\n          const ariaLabel =\n              `View from stage ${polarTrientLabel}${azimuthalQuadrantLabel}`;\n\n          this[$userInputElement].setAttribute('aria-label', ariaLabel);\n        }\n      }\n    }\n\n    [$onResize](event: any) {\n      const controls = this[$controls];\n      const oldFramedFieldOfView = this[$scene].framedFieldOfView;\n\n      // The super of $onResize will update the scene's framedFieldOfView, so we\n      // compare the before and after to calculate the proper zoom.\n      super[$onResize](event);\n\n      const newFramedFieldOfView = this[$scene].framedFieldOfView;\n      const zoom = controls.getFieldOfView() / oldFramedFieldOfView;\n      this[$zoomAdjustedFieldOfView] = newFramedFieldOfView * zoom;\n\n      controls.updateAspect(this[$scene].aspect);\n\n      this.requestUpdate('maxFieldOfView', this.maxFieldOfView);\n      this.requestUpdate('fieldOfView', this.fieldOfView);\n      this.jumpCameraToGoal();\n    }\n\n    [$onModelLoad](event: any) {\n      super[$onModelLoad](event);\n\n      const {framedFieldOfView} = this[$scene];\n      this[$zoomAdjustedFieldOfView] = framedFieldOfView;\n\n      this.requestUpdate('maxFieldOfView', this.maxFieldOfView);\n      this.requestUpdate('fieldOfView', this.fieldOfView);\n      this.requestUpdate('cameraOrbit', this.cameraOrbit);\n      this.requestUpdate('minCameraOrbit', this.minCameraOrbit);\n      this.requestUpdate('maxCameraOrbit', this.maxCameraOrbit);\n      this.requestUpdate('cameraTarget', this.cameraTarget);\n      this.jumpCameraToGoal();\n    }\n\n    [$onFocus]() {\n      const input = this[$userInputElement];\n\n      if (!isFinite(this[$focusedTime])) {\n        this[$focusedTime] = performance.now();\n      }\n\n      // NOTE(cdata): On every re-focus, we switch the aria-label back to\n      // the original, non-prompt label if appropriate. If the user has\n      // already interacted, they no longer need to hear the prompt.\n      // Otherwise, they will hear it again after the idle prompt threshold\n      // has been crossed.\n      const ariaLabel = this[$ariaLabel];\n\n      if (input.getAttribute('aria-label') !== ariaLabel) {\n        input.setAttribute('aria-label', ariaLabel);\n      }\n\n      if (this.interactionPrompt === InteractionPromptStrategy.WHEN_FOCUSED &&\n          !this[$userHasInteracted]) {\n        this[$waitingToPromptUser] = true;\n      }\n    }\n\n    [$onBlur]() {\n      this[$waitingToPromptUser] = false;\n      this[$promptElement].classList.remove('visible');\n\n      this[$promptElementVisibleTime] = Infinity;\n      this[$focusedTime] = Infinity;\n    }\n\n    [$onChange]({source}: ChangeEvent) {\n      this[$updateAria]();\n      this[$needsRender]();\n\n      if (source === ChangeSource.USER_INTERACTION) {\n        this[$userHasInteracted] = true;\n        this[$deferInteractionPrompt]();\n      }\n\n      this.dispatchEvent(new CustomEvent<CameraChangeDetails>(\n          'camera-change', {detail: {source}}));\n    }\n\n    [$onPointerChange](event: PointerChangeEvent) {\n      if (event.type === 'pointer-change-start') {\n        this[$container].classList.add('pointer-tumbling');\n      } else {\n        this[$container].classList.remove('pointer-tumbling');\n      }\n    }\n  }\n\n  return ControlsModelViewerElement;\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}