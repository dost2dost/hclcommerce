{"ast":null,"code":"var THREE = require('../lib/three');\n\nvar HLS_MIMETYPES = ['application/x-mpegurl', 'application/vnd.apple.mpegurl'];\nvar COLOR_MAPS = new Set(['emissiveMap', 'envMap', 'map', 'specularMap']);\n/**\n * Update `material` texture property (usually but not always `map`)\n * from `data` property (usually but not always `src`)\n *\n * @param {object} shader - A-Frame shader instance.\n * @param {object} data\n */\n\nmodule.exports.updateMapMaterialFromData = function (materialName, dataName, shader, data) {\n  var el = shader.el;\n  var material = shader.material;\n  var rendererSystem = el.sceneEl.systems.renderer;\n  var src = data[dataName]; // Because a single material / shader may have multiple textures,\n  // we need to remember the source value for this data property\n  // to avoid redundant operations which can be expensive otherwise\n  // (e.g. video texture loads).\n\n  if (!shader.materialSrcs) {\n    shader.materialSrcs = {};\n  }\n\n  if (!src) {\n    // Forget the prior material src.\n    delete shader.materialSrcs[materialName]; // Remove the texture.\n\n    setMap(null);\n    return;\n  } // Don't process if material src hasn't changed.\n\n\n  if (src === shader.materialSrcs[materialName]) {\n    return;\n  } // Remember the new src for this texture (there may be multiple).\n\n\n  shader.materialSrcs[materialName] = src; // If the new material src is already a texture, just use it.\n\n  if (src instanceof THREE.Texture) {\n    setMap(src);\n  } else {\n    // Load texture for the new material src.\n    // (And check if we should still use it once available in callback.)\n    el.sceneEl.systems.material.loadTexture(src, {\n      src: src,\n      repeat: data.repeat,\n      offset: data.offset,\n      npot: data.npot\n    }, checkSetMap);\n  }\n\n  function checkSetMap(texture) {\n    // If the source has been changed, don't use loaded texture.\n    if (shader.materialSrcs[materialName] !== src) {\n      return;\n    }\n\n    setMap(texture);\n  }\n\n  function setMap(texture) {\n    material[materialName] = texture;\n\n    if (texture && COLOR_MAPS.has(materialName)) {\n      rendererSystem.applyColorCorrection(texture);\n    }\n\n    material.needsUpdate = true;\n    handleTextureEvents(el, texture);\n  }\n};\n/**\n * Update `material.map` given `data.src`. For standard and flat shaders.\n *\n * @param {object} shader - A-Frame shader instance.\n * @param {object} data\n */\n\n\nmodule.exports.updateMap = function (shader, data) {\n  return module.exports.updateMapMaterialFromData('map', 'src', shader, data);\n};\n/**\n * Updates the material's maps which give the illusion of extra geometry.\n *\n * @param {string} longType - The friendly name of the map from the component e.g. ambientOcclusionMap becomes aoMap in THREE.js\n * @param {object} shader - A-Frame shader instance\n * @param {object} data\n */\n\n\nmodule.exports.updateDistortionMap = function (longType, shader, data) {\n  var shortType = longType;\n\n  if (longType === 'ambientOcclusion') {\n    shortType = 'ao';\n  }\n\n  var el = shader.el;\n  var material = shader.material;\n  var rendererSystem = el.sceneEl.systems.renderer;\n  var src = data[longType + 'Map'];\n  var info = {};\n  info.src = src; // Pass through the repeat and offset to be handled by the material loader.\n\n  info.offset = data[longType + 'TextureOffset'];\n  info.repeat = data[longType + 'TextureRepeat'];\n  info.wrap = data[longType + 'TextureWrap'];\n\n  if (src) {\n    if (src === shader[longType + 'TextureSrc']) {\n      return;\n    } // Texture added or changed.\n\n\n    shader[longType + 'TextureSrc'] = src;\n    el.sceneEl.systems.material.loadTexture(src, info, setMap);\n    return;\n  } // Texture removed.\n\n\n  if (!material.map) {\n    return;\n  }\n\n  setMap(null);\n\n  function setMap(texture) {\n    var slot = shortType + 'Map';\n    material[slot] = texture;\n\n    if (texture && COLOR_MAPS.has(slot)) {\n      rendererSystem.applyColorCorrection(texture);\n    }\n\n    material.needsUpdate = true;\n    handleTextureEvents(el, texture);\n  }\n};\n/**\n * Emit event on entities on texture-related events.\n *\n * @param {Element} el - Entity.\n * @param {object} texture - three.js Texture.\n */\n\n\nfunction handleTextureEvents(el, texture) {\n  if (!texture) {\n    return;\n  }\n\n  el.emit('materialtextureloaded', {\n    src: texture.image,\n    texture: texture\n  }); // Video events.\n\n  if (!texture.image || texture.image.tagName !== 'VIDEO') {\n    return;\n  }\n\n  texture.image.addEventListener('loadeddata', function emitVideoTextureLoadedDataAll() {\n    // Check to see if we need to use iOS 10 HLS shader.\n    // Only override the shader if it is stock shader that we know doesn't correct.\n    if (!el.components || !el.components.material) {\n      return;\n    }\n\n    if (texture.needsCorrectionBGRA && texture.needsCorrectionFlipY && ['standard', 'flat'].indexOf(el.components.material.data.shader) !== -1) {\n      el.setAttribute('material', 'shader', 'ios10hls');\n    }\n\n    el.emit('materialvideoloadeddata', {\n      src: texture.image,\n      texture: texture\n    });\n  });\n  texture.image.addEventListener('ended', function emitVideoTextureEndedAll() {\n    // Works for non-looping videos only.\n    el.emit('materialvideoended', {\n      src: texture.image,\n      texture: texture\n    });\n  });\n}\n\nmodule.exports.handleTextureEvents = handleTextureEvents;\n/**\n * Given video element src and type, guess whether stream is HLS.\n *\n * @param {string} src - src from video element (generally URL to content).\n * @param {string} type - type from video element (generally MIME type if present).\n */\n\nmodule.exports.isHLS = function (src, type) {\n  if (type && HLS_MIMETYPES.includes(type.toLowerCase())) {\n    return true;\n  }\n\n  if (src && src.toLowerCase().indexOf('.m3u8') > 0) {\n    return true;\n  }\n\n  return false;\n};","map":{"version":3,"sources":["C:/Users/Hannuri/Desktop/RoyalCyber/my-first-app/node_modules/aframe/src/utils/material.js"],"names":["THREE","require","HLS_MIMETYPES","COLOR_MAPS","Set","module","exports","updateMapMaterialFromData","materialName","dataName","shader","data","el","material","rendererSystem","sceneEl","systems","renderer","src","materialSrcs","setMap","Texture","loadTexture","repeat","offset","npot","checkSetMap","texture","has","applyColorCorrection","needsUpdate","handleTextureEvents","updateMap","updateDistortionMap","longType","shortType","info","wrap","map","slot","emit","image","tagName","addEventListener","emitVideoTextureLoadedDataAll","components","needsCorrectionBGRA","needsCorrectionFlipY","indexOf","setAttribute","emitVideoTextureEndedAll","isHLS","type","includes","toLowerCase"],"mappings":"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","sourcesContent":["var THREE = require('../lib/three');\n\nvar HLS_MIMETYPES = ['application/x-mpegurl', 'application/vnd.apple.mpegurl'];\n\nvar COLOR_MAPS = new Set([\n  'emissiveMap',\n  'envMap',\n  'map',\n  'specularMap'\n]);\n\n/**\n * Update `material` texture property (usually but not always `map`)\n * from `data` property (usually but not always `src`)\n *\n * @param {object} shader - A-Frame shader instance.\n * @param {object} data\n */\nmodule.exports.updateMapMaterialFromData = function (materialName, dataName, shader, data) {\n  var el = shader.el;\n  var material = shader.material;\n  var rendererSystem = el.sceneEl.systems.renderer;\n  var src = data[dataName];\n\n  // Because a single material / shader may have multiple textures,\n  // we need to remember the source value for this data property\n  // to avoid redundant operations which can be expensive otherwise\n  // (e.g. video texture loads).\n  if (!shader.materialSrcs) { shader.materialSrcs = {}; }\n\n  if (!src) {\n    // Forget the prior material src.\n    delete shader.materialSrcs[materialName];\n    // Remove the texture.\n    setMap(null);\n    return;\n  }\n\n  // Don't process if material src hasn't changed.\n  if (src === shader.materialSrcs[materialName]) { return; }\n\n  // Remember the new src for this texture (there may be multiple).\n  shader.materialSrcs[materialName] = src;\n\n  // If the new material src is already a texture, just use it.\n  if (src instanceof THREE.Texture) { setMap(src); } else {\n    // Load texture for the new material src.\n    // (And check if we should still use it once available in callback.)\n    el.sceneEl.systems.material.loadTexture(src,\n      {src: src, repeat: data.repeat, offset: data.offset, npot: data.npot},\n      checkSetMap);\n  }\n\n  function checkSetMap (texture) {\n    // If the source has been changed, don't use loaded texture.\n    if (shader.materialSrcs[materialName] !== src) { return; }\n    setMap(texture);\n  }\n\n  function setMap (texture) {\n    material[materialName] = texture;\n    if (texture && COLOR_MAPS.has(materialName)) {\n      rendererSystem.applyColorCorrection(texture);\n    }\n    material.needsUpdate = true;\n    handleTextureEvents(el, texture);\n  }\n};\n\n/**\n * Update `material.map` given `data.src`. For standard and flat shaders.\n *\n * @param {object} shader - A-Frame shader instance.\n * @param {object} data\n */\nmodule.exports.updateMap = function (shader, data) {\n  return module.exports.updateMapMaterialFromData('map', 'src', shader, data);\n};\n\n/**\n * Updates the material's maps which give the illusion of extra geometry.\n *\n * @param {string} longType - The friendly name of the map from the component e.g. ambientOcclusionMap becomes aoMap in THREE.js\n * @param {object} shader - A-Frame shader instance\n * @param {object} data\n */\nmodule.exports.updateDistortionMap = function (longType, shader, data) {\n  var shortType = longType;\n  if (longType === 'ambientOcclusion') { shortType = 'ao'; }\n  var el = shader.el;\n  var material = shader.material;\n  var rendererSystem = el.sceneEl.systems.renderer;\n  var src = data[longType + 'Map'];\n  var info = {};\n  info.src = src;\n\n  // Pass through the repeat and offset to be handled by the material loader.\n  info.offset = data[longType + 'TextureOffset'];\n  info.repeat = data[longType + 'TextureRepeat'];\n  info.wrap = data[longType + 'TextureWrap'];\n\n  if (src) {\n    if (src === shader[longType + 'TextureSrc']) { return; }\n\n    // Texture added or changed.\n    shader[longType + 'TextureSrc'] = src;\n    el.sceneEl.systems.material.loadTexture(src, info, setMap);\n    return;\n  }\n\n  // Texture removed.\n  if (!material.map) { return; }\n  setMap(null);\n\n  function setMap (texture) {\n    var slot = shortType + 'Map';\n    material[slot] = texture;\n    if (texture && COLOR_MAPS.has(slot)) {\n      rendererSystem.applyColorCorrection(texture);\n    }\n    material.needsUpdate = true;\n    handleTextureEvents(el, texture);\n  }\n};\n\n/**\n * Emit event on entities on texture-related events.\n *\n * @param {Element} el - Entity.\n * @param {object} texture - three.js Texture.\n */\nfunction handleTextureEvents (el, texture) {\n  if (!texture) { return; }\n\n  el.emit('materialtextureloaded', {src: texture.image, texture: texture});\n\n  // Video events.\n  if (!texture.image || texture.image.tagName !== 'VIDEO') { return; }\n\n  texture.image.addEventListener('loadeddata', function emitVideoTextureLoadedDataAll () {\n    // Check to see if we need to use iOS 10 HLS shader.\n    // Only override the shader if it is stock shader that we know doesn't correct.\n    if (!el.components || !el.components.material) { return; }\n\n    if (texture.needsCorrectionBGRA && texture.needsCorrectionFlipY &&\n        ['standard', 'flat'].indexOf(el.components.material.data.shader) !== -1) {\n      el.setAttribute('material', 'shader', 'ios10hls');\n    }\n\n    el.emit('materialvideoloadeddata', {src: texture.image, texture: texture});\n  });\n  texture.image.addEventListener('ended', function emitVideoTextureEndedAll () {\n    // Works for non-looping videos only.\n    el.emit('materialvideoended', {src: texture.image, texture: texture});\n  });\n}\nmodule.exports.handleTextureEvents = handleTextureEvents;\n\n/**\n * Given video element src and type, guess whether stream is HLS.\n *\n * @param {string} src - src from video element (generally URL to content).\n * @param {string} type - type from video element (generally MIME type if present).\n */\nmodule.exports.isHLS = function (src, type) {\n  if (type && HLS_MIMETYPES.includes(type.toLowerCase())) { return true; }\n  if (src && src.toLowerCase().indexOf('.m3u8') > 0) { return true; }\n  return false;\n};\n"]},"metadata":{},"sourceType":"script"}